(function(){ try {var elementStyle = document.createElement('style'); elementStyle.innerText = `@-webkit-keyframes spin-2ebdabe3{to{transform:rotate(360deg)}}@keyframes spin-2ebdabe3{to{transform:rotate(360deg)}}svg[data-v-2ebdabe3]{-webkit-animation:spin-2ebdabe3 1s linear infinite;animation:spin-2ebdabe3 1s linear infinite}svg circle[data-v-2ebdabe3]{opacity:.25}svg path[data-v-2ebdabe3]{opacity:.75}.st0[data-v-246a9848]{fill:#e2761b;stroke:#e2761b;stroke-linecap:round;stroke-linejoin:round}.st1[data-v-246a9848]{fill:#e4761b;stroke:#e4761b;stroke-linecap:round;stroke-linejoin:round}.st2[data-v-246a9848]{fill:#d7c1b3;stroke:#d7c1b3;stroke-linecap:round;stroke-linejoin:round}.st3[data-v-246a9848]{fill:#233447;stroke:#233447;stroke-linecap:round;stroke-linejoin:round}.st4[data-v-246a9848]{fill:#cd6116;stroke:#cd6116;stroke-linecap:round;stroke-linejoin:round}.st5[data-v-246a9848]{fill:#e4751f;stroke:#e4751f;stroke-linecap:round;stroke-linejoin:round}.st6[data-v-246a9848]{fill:#f6851b;stroke:#f6851b;stroke-linecap:round;stroke-linejoin:round}.st7[data-v-246a9848]{fill:#c0ad9e;stroke:#c0ad9e;stroke-linecap:round;stroke-linejoin:round}.st8[data-v-246a9848]{fill:#161616;stroke:#161616;stroke-linecap:round;stroke-linejoin:round}.st9[data-v-246a9848]{fill:#763d16;stroke:#763d16;stroke-linecap:round;stroke-linejoin:round}.container[data-v-c0a30450]{text-align:center}.container h3[data-v-c0a30450]{font-size:1.125rem;font-weight:500;line-height:1.5rem;--tw-text-opacity: 1;color:rgb(17 24 39 / var(--tw-text-opacity))}.container>p[data-v-c0a30450]{margin-top:.5rem;padding-left:1rem;padding-right:1rem;font-size:.875rem;line-height:1.25rem;--tw-text-opacity: 1;color:rgb(107 114 128 / var(--tw-text-opacity))}.connecting[data-v-50b9deb1]{display:flex;flex-direction:column;align-items:center;justify-content:center;padding:2rem 2.5rem}@media (min-width: 640px){.connecting[data-v-50b9deb1]{padding:3rem}}.spinner[data-v-50b9deb1]{margin-left:auto;margin-right:auto;height:3rem;width:3rem;--tw-text-opacity: 1;color:rgb(234 88 12 / var(--tw-text-opacity))}.inner[data-v-50b9deb1]{margin-top:.75rem;text-align:center}@media (min-width: 640px){.inner[data-v-50b9deb1]{margin-top:1.25rem}}.avatar{position:relative;display:inline-block}.avatar img{pointer-events:none;height:5rem;width:5rem;border-radius:9999px;--tw-bg-opacity: 1;background-color:rgb(255 255 255 / var(--tw-bg-opacity))}.avatar img.ring{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000);--tw-ring-opacity: 1;--tw-ring-color: rgb(243 244 246 / var(--tw-ring-opacity)) }.avatar span{position:absolute;bottom:0px;right:0px;display:flex;height:1.5rem;width:1.5rem;align-items:center;justify-content:center;border-radius:9999px;--tw-bg-opacity: 1;background-color:rgb(234 88 12 / var(--tw-bg-opacity));--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000);--tw-ring-opacity: 1;--tw-ring-color: rgb(255 255 255 / var(--tw-ring-opacity)) }.avatar span svg{height:.875rem;width:.875rem;--tw-text-opacity: 1;color:rgb(255 247 237 / var(--tw-text-opacity))}.avatar[data-v-3c5b8d7a]{position:relative;display:inline-block}.avatar img[data-v-3c5b8d7a]{pointer-events:none;height:5rem;width:5rem;border-radius:9999px;--tw-bg-opacity: 1;background-color:rgb(255 255 255 / var(--tw-bg-opacity))}.avatar img.ring[data-v-3c5b8d7a]{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000);--tw-ring-opacity: 1;--tw-ring-color: rgb(243 244 246 / var(--tw-ring-opacity)) }.avatar span[data-v-3c5b8d7a]{position:absolute;bottom:0px;right:0px;display:flex;height:1.5rem;width:1.5rem;align-items:center;justify-content:center;border-radius:9999px;--tw-bg-opacity: 1;background-color:rgb(234 88 12 / var(--tw-bg-opacity));--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000);--tw-ring-opacity: 1;--tw-ring-color: rgb(255 255 255 / var(--tw-ring-opacity)) }.avatar span svg[data-v-3c5b8d7a]{height:.875rem;width:.875rem;--tw-text-opacity: 1;color:rgb(255 247 237 / var(--tw-text-opacity))}.avatar[data-v-6293b51d]{position:relative;display:inline-block}.avatar img[data-v-6293b51d]{pointer-events:none;height:4rem;width:4rem;border-radius:9999px}.avatar[data-v-50218e7c]{position:relative;display:inline-block}.avatar img[data-v-50218e7c]{pointer-events:none;height:5rem;width:5rem;border-radius:9999px;--tw-bg-opacity: 1;background-color:rgb(255 255 255 / var(--tw-bg-opacity))}.avatar img.ring[data-v-50218e7c]{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000);--tw-ring-opacity: 1;--tw-ring-color: rgb(243 244 246 / var(--tw-ring-opacity)) }.avatar span[data-v-50218e7c]{position:absolute;bottom:0px;right:0px;display:flex;height:1.5rem;width:1.5rem;align-items:center;justify-content:center;border-radius:9999px;--tw-bg-opacity: 1;background-color:rgb(234 88 12 / var(--tw-bg-opacity));--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000);--tw-ring-opacity: 1;--tw-ring-color: rgb(255 255 255 / var(--tw-ring-opacity)) }.avatar span svg[data-v-50218e7c]{height:.875rem;width:.875rem;--tw-text-opacity: 1;color:rgb(255 247 237 / var(--tw-text-opacity))}.avatar span[data-v-50218e7c]{--tw-bg-opacity: 1;background-color:rgb(220 38 38 / var(--tw-bg-opacity))}.avatar[data-v-1c35ac42]{position:relative;display:inline-block}.avatar img[data-v-1c35ac42]{pointer-events:none;height:5rem;width:5rem;border-radius:9999px;--tw-bg-opacity: 1;background-color:rgb(255 255 255 / var(--tw-bg-opacity))}.avatar img.ring[data-v-1c35ac42]{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000);--tw-ring-opacity: 1;--tw-ring-color: rgb(243 244 246 / var(--tw-ring-opacity)) }.avatar span[data-v-1c35ac42]{position:absolute;bottom:0px;right:0px;display:flex;height:1.5rem;width:1.5rem;align-items:center;justify-content:center;border-radius:9999px;--tw-bg-opacity: 1;background-color:rgb(234 88 12 / var(--tw-bg-opacity));--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000);--tw-ring-opacity: 1;--tw-ring-color: rgb(255 255 255 / var(--tw-ring-opacity)) }.avatar span svg[data-v-1c35ac42]{height:.875rem;width:.875rem;--tw-text-opacity: 1;color:rgb(255 247 237 / var(--tw-text-opacity))}.avatar span[data-v-1c35ac42]{--tw-bg-opacity: 1;background-color:rgb(220 38 38 / var(--tw-bg-opacity))}.avatar[data-v-1ebd8e85]{position:relative;display:inline-block}.avatar img[data-v-1ebd8e85]{pointer-events:none;height:5rem;width:5rem;border-radius:9999px;--tw-bg-opacity: 1;background-color:rgb(255 255 255 / var(--tw-bg-opacity))}.avatar img.ring[data-v-1ebd8e85]{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000);--tw-ring-opacity: 1;--tw-ring-color: rgb(243 244 246 / var(--tw-ring-opacity)) }.avatar span[data-v-1ebd8e85]{position:absolute;bottom:0px;right:0px;display:flex;height:1.5rem;width:1.5rem;align-items:center;justify-content:center;border-radius:9999px;--tw-bg-opacity: 1;background-color:rgb(234 88 12 / var(--tw-bg-opacity));--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000);--tw-ring-opacity: 1;--tw-ring-color: rgb(255 255 255 / var(--tw-ring-opacity)) }.avatar span svg[data-v-1ebd8e85]{height:.875rem;width:.875rem;--tw-text-opacity: 1;color:rgb(255 247 237 / var(--tw-text-opacity))}.avatar span[data-v-1ebd8e85]{--tw-bg-opacity: 1;background-color:rgb(22 163 74 / var(--tw-bg-opacity))}.links[data-v-0c884638]{margin-top:.75rem;display:flex;align-items:center;justify-content:center}.links[data-v-0c884638]>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(1rem * var(--tw-space-x-reverse));margin-left:calc(1rem * calc(1 - var(--tw-space-x-reverse)))}.links a[data-v-0c884638]{--tw-text-opacity: 1;color:rgb(156 163 175 / var(--tw-text-opacity))}.links a[data-v-0c884638]:hover{--tw-text-opacity: 1;color:rgb(107 114 128 / var(--tw-text-opacity))}.links a span[data-v-0c884638]{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0}.links a svg[data-v-0c884638]{height:1.5rem;width:1.5rem}.banner-img[data-v-459eb8e8]{position:relative;margin-bottom:3rem}.banner-img .img[data-v-459eb8e8]{pointer-events:none;overflow:hidden}.banner-img .img img[data-v-459eb8e8]{height:8rem;width:100%;-o-object-fit:cover;object-fit:cover}.banner-img .avatar-outer[data-v-459eb8e8]{position:absolute;left:0px;right:0px;bottom:-2rem;display:flex;align-items:center;justify-content:center}.banner[data-v-459eb8e8]{display:flex;align-items:center;justify-content:center;padding:1.25rem 1rem .75rem}@media (min-width: 640px){.banner[data-v-459eb8e8]{padding-left:1.5rem;padding-right:1.5rem}.banner[data-v-459eb8e8]{padding-top:1.75rem}.banner[data-v-459eb8e8]{padding-bottom:1.25rem}}.error[data-v-5b9e2840]{padding:1.25rem 1rem}@media (min-width: 640px){.error[data-v-5b9e2840]{padding-left:1.5rem;padding-right:1.5rem}.error[data-v-5b9e2840]{padding-top:1.75rem;padding-bottom:1.75rem}}.avatar-outer[data-v-5b9e2840]{margin-top:.25rem;margin-bottom:.75rem;display:flex;align-items:center;justify-content:center}@media (min-width: 640px){.avatar-outer[data-v-5b9e2840]{margin-bottom:1.25rem}}.link[data-v-5b9e2840]{font-weight:500;--tw-text-opacity: 1;color:rgb(234 88 12 / var(--tw-text-opacity))}.link[data-v-5b9e2840]:focus{outline:2px solid transparent;outline-offset:2px}.debug-info[data-v-5b9e2840]{margin-top:.75rem;text-align:center;font-size:.65em;--tw-text-opacity: 1;color:rgb(55 65 81 / var(--tw-text-opacity))}.debug-info code[data-v-5b9e2840]{display:block;background-color:transparent}.actions[data-v-5b9e2840]{margin-top:1.25rem;display:flex;justify-content:center}.actions[data-v-5b9e2840]>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(.5rem * var(--tw-space-x-reverse));margin-left:calc(.5rem * calc(1 - var(--tw-space-x-reverse)))}@media (min-width: 640px){.actions[data-v-5b9e2840]{margin-top:1.5rem}}.btn[data-v-5b9e2840]{display:flex;width:100%;align-items:center;justify-content:center;border-radius:.375rem;border-width:1px;border-color:transparent;--tw-bg-opacity: 1;background-color:rgb(243 244 246 / var(--tw-bg-opacity));padding:.5rem 1rem;font-size:.875rem;line-height:1.25rem;font-weight:500;--tw-text-opacity: 1;color:rgb(55 65 81 / var(--tw-text-opacity))}.btn[data-v-5b9e2840]:hover{--tw-bg-opacity: 1;background-color:rgb(229 231 235 / var(--tw-bg-opacity))}.btn[data-v-5b9e2840]:focus{outline:2px solid transparent;outline-offset:2px;--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000);--tw-ring-opacity: 1;--tw-ring-color: rgb(249 115 22 / var(--tw-ring-opacity));--tw-ring-offset-width: 2px }.btn.primary[data-v-5b9e2840]{--tw-bg-opacity: 1;background-color:rgb(255 237 213 / var(--tw-bg-opacity));--tw-text-opacity: 1;color:rgb(194 65 12 / var(--tw-text-opacity))}.btn.primary[data-v-5b9e2840]:hover{--tw-bg-opacity: 1;background-color:rgb(254 215 170 / var(--tw-bg-opacity))}.fields[data-v-5b9e2840]{margin-left:auto;margin-right:auto;margin-top:.75rem}.fields[data-v-5b9e2840]>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.25rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.25rem * var(--tw-space-y-reverse))}.fields[data-v-5b9e2840]{text-align:center;font-size:.875rem;line-height:1.25rem;--tw-text-opacity: 1;color:rgb(55 65 81 / var(--tw-text-opacity))}.rate-limited[data-v-3c7ee30b]{padding:1.25rem 1rem}@media (min-width: 640px){.rate-limited[data-v-3c7ee30b]{padding-left:1.5rem;padding-right:1.5rem}.rate-limited[data-v-3c7ee30b]{padding-top:1.75rem;padding-bottom:1.75rem}}.avatar[data-v-3c7ee30b]{margin-top:.25rem;margin-bottom:.75rem;display:flex;align-items:center;justify-content:center}@media (min-width: 640px){.avatar[data-v-3c7ee30b]{margin-bottom:1.25rem}}.avatar span[data-v-3c7ee30b]{position:relative;display:flex;height:4rem;width:4rem;align-items:center;justify-content:center;border-radius:9999px;--tw-bg-opacity: 1;background-color:rgb(254 242 242 / var(--tw-bg-opacity))}.avatar span svg[data-v-3c7ee30b]{height:2rem;width:2rem;--tw-text-opacity: 1;color:rgb(220 38 38 / var(--tw-text-opacity))}.debug-info[data-v-3c7ee30b]{margin-top:.75rem;text-align:center;font-size:.65em;--tw-text-opacity: 1;color:rgb(55 65 81 / var(--tw-text-opacity))}.debug-info code[data-v-3c7ee30b]{display:block}.failed[data-v-98959604]{padding:1.25rem 1rem}@media (min-width: 640px){.failed[data-v-98959604]{padding-left:1.5rem;padding-right:1.5rem}.failed[data-v-98959604]{padding-top:1.75rem;padding-bottom:1.75rem}}.avatar-outer[data-v-98959604]{margin-top:.25rem;margin-bottom:.75rem;display:flex;align-items:center;justify-content:center}@media (min-width: 640px){.avatar-outer[data-v-98959604]{margin-bottom:1.25rem}}.link[data-v-98959604]{font-weight:500}a.link[data-v-98959604]{--tw-text-opacity: 1;color:rgb(234 88 12 / var(--tw-text-opacity))}a.link[data-v-98959604]:focus{outline:2px solid transparent;outline-offset:2px}.actions[data-v-98959604]{margin-top:1.25rem;display:flex;flex-direction:column}.actions[data-v-98959604]>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.5rem * var(--tw-space-y-reverse))}@media (min-width: 640px){.actions[data-v-98959604]{margin-top:1.5rem}}.row[data-v-98959604]{display:flex}.row[data-v-98959604]>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(.5rem * var(--tw-space-x-reverse));margin-left:calc(.5rem * calc(1 - var(--tw-space-x-reverse)))}.btn[data-v-98959604]{display:flex;width:100%;align-items:center;justify-content:center;border-radius:.375rem;border-width:1px;border-color:transparent;--tw-bg-opacity: 1;background-color:rgb(243 244 246 / var(--tw-bg-opacity));padding:.5rem 1rem;font-size:.875rem;line-height:1.25rem;font-weight:500;--tw-text-opacity: 1;color:rgb(55 65 81 / var(--tw-text-opacity))}.btn[data-v-98959604]:hover{--tw-bg-opacity: 1;background-color:rgb(229 231 235 / var(--tw-bg-opacity))}.btn[data-v-98959604]:focus{outline:2px solid transparent;outline-offset:2px;--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000);--tw-ring-opacity: 1;--tw-ring-color: rgb(249 115 22 / var(--tw-ring-opacity));--tw-ring-offset-width: 2px }.btn.primary[data-v-98959604]{--tw-bg-opacity: 1;background-color:rgb(255 237 213 / var(--tw-bg-opacity));--tw-text-opacity: 1;color:rgb(194 65 12 / var(--tw-text-opacity))}.btn.primary[data-v-98959604]:hover{--tw-bg-opacity: 1;background-color:rgb(254 215 170 / var(--tw-bg-opacity))}.btn svg[data-v-98959604]{margin-left:-.25rem;margin-right:.375rem;height:1rem;width:1rem}.loading[data-v-38692a0e]{display:flex;flex-direction:column;align-items:center;justify-content:center;padding:2rem 2.5rem}@media (min-width: 640px){.loading[data-v-38692a0e]{padding:3rem}}.loading .spinner[data-v-38692a0e]{margin-top:1.5rem;margin-bottom:1.5rem;margin-left:auto;margin-right:auto;height:3rem;width:3rem;--tw-text-opacity: 1;color:rgb(234 88 12 / var(--tw-text-opacity))}p[data-v-38692a0e]{padding-left:1rem;padding-right:1rem;text-align:center;font-size:.875rem;line-height:1.25rem;--tw-text-opacity: 1;color:rgb(107 114 128 / var(--tw-text-opacity))}.signing[data-v-091ca39f]{display:flex;flex-direction:column;align-items:center;justify-content:center;padding:2rem 2.5rem}@media (min-width: 640px){.signing[data-v-091ca39f]{padding:3rem}}.spinner[data-v-091ca39f]{margin-left:auto;margin-right:auto;margin-bottom:.75rem;height:3rem;width:3rem;--tw-text-opacity: 1;color:rgb(234 88 12 / var(--tw-text-opacity))}@media (min-width: 640px){.spinner[data-v-091ca39f]{margin-bottom:1.25rem}}.link-wallet-btn[data-v-e3deb5ea]{display:flex;width:100%;align-items:center}.link-wallet-btn[data-v-e3deb5ea]>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(1rem * var(--tw-space-x-reverse));margin-left:calc(1rem * calc(1 - var(--tw-space-x-reverse)))}.link-wallet-btn[data-v-e3deb5ea]{border-radius:.5rem;border-width:1px;border-style:solid;--tw-border-opacity: 1;border-color:rgb(243 244 246 / var(--tw-border-opacity));--tw-bg-opacity: 1;background-color:rgb(249 250 251 / var(--tw-bg-opacity));padding:1rem;text-align:left}.link-wallet-btn[data-v-e3deb5ea]:hover{--tw-bg-opacity: 1;background-color:rgb(243 244 246 / var(--tw-bg-opacity))}.icon[data-v-e3deb5ea]{display:flex;height:3rem;width:3rem;flex-shrink:0;align-items:center;justify-content:center}.icon svg[data-v-e3deb5ea]{height:3rem;width:3rem}.content[data-v-e3deb5ea]{min-width:0px;flex:1 1 0%;font-size:.875rem;line-height:1.25rem}.content .title[data-v-e3deb5ea]{font-weight:500;--tw-text-opacity: 1;color:rgb(17 24 39 / var(--tw-text-opacity))}.content p[data-v-e3deb5ea]{font-size:.875rem;line-height:1.25rem;--tw-text-opacity: 1;color:rgb(107 114 128 / var(--tw-text-opacity))}.arrow[data-v-e3deb5ea]{flex-shrink:0;align-self:center}.arrow svg[data-v-e3deb5ea]{height:1.25rem;width:1.25rem;--tw-text-opacity: 1;color:rgb(156 163 175 / var(--tw-text-opacity))}.link-wallet-btn:hover .arrow svg[data-v-e3deb5ea]{--tw-text-opacity: 1;color:rgb(107 114 128 / var(--tw-text-opacity))}ul[data-v-51dbf680]>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.75rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.75rem * var(--tw-space-y-reverse))}.start[data-v-b624bf34]{padding-left:1rem;padding-right:1rem;padding-bottom:1.25rem}@media (min-width: 640px){.start[data-v-b624bf34]{padding-left:1.5rem;padding-right:1.5rem}.start[data-v-b624bf34]{padding-bottom:1.75rem}}.link[data-v-b624bf34]{font-weight:500}a.link[data-v-b624bf34]{--tw-text-opacity: 1;color:rgb(234 88 12 / var(--tw-text-opacity))}a.link[data-v-b624bf34]:focus{outline:2px solid transparent;outline-offset:2px}.btns[data-v-b624bf34]{margin-top:1.25rem}@media (min-width: 640px){.btns[data-v-b624bf34]{margin-top:1.5rem}}.success[data-v-84a90e9a]{padding:1.25rem 1rem}@media (min-width: 640px){.success[data-v-84a90e9a]{padding-left:1.5rem;padding-right:1.5rem}.success[data-v-84a90e9a]{padding-top:1.75rem;padding-bottom:1.75rem}}.avatar-outer[data-v-84a90e9a]{margin-top:.25rem;margin-bottom:.75rem;display:flex;align-items:center;justify-content:center}@media (min-width: 640px){.avatar-outer[data-v-84a90e9a]{margin-bottom:1.25rem}}.link[data-v-84a90e9a]{font-weight:500;--tw-text-opacity: 1;color:rgb(22 163 74 / var(--tw-text-opacity))}.link[data-v-84a90e9a]:focus{outline:2px solid transparent;outline-offset:2px}.actions[data-v-84a90e9a]{margin-top:1.25rem}.actions[data-v-84a90e9a]>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.5rem * var(--tw-space-y-reverse))}@media (min-width: 640px){.actions[data-v-84a90e9a]{margin-top:1.5rem}}.btn[data-v-84a90e9a]{display:flex;width:100%;align-items:center;justify-content:center;border-radius:.375rem;border-width:1px;border-color:transparent;--tw-bg-opacity: 1;background-color:rgb(220 252 231 / var(--tw-bg-opacity));padding:.5rem 1rem;font-size:.875rem;line-height:1.25rem;font-weight:500;--tw-text-opacity: 1;color:rgb(21 128 61 / var(--tw-text-opacity))}.btn[data-v-84a90e9a]:hover{--tw-bg-opacity: 1;background-color:rgb(187 247 208 / var(--tw-bg-opacity))}.btn[data-v-84a90e9a]:focus{outline:2px solid transparent;outline-offset:2px;--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000);--tw-ring-opacity: 1;--tw-ring-color: rgb(34 197 94 / var(--tw-ring-opacity));--tw-ring-offset-width: 2px }.dl-label[data-v-84a90e9a]{margin-top:1.5rem;margin-bottom:.75rem}.dl-label>.inner[data-v-84a90e9a]{position:relative}.dl-label>.inner .line[data-v-84a90e9a]{position:absolute;top:0px;right:0px;bottom:0px;left:0px;display:flex;align-items:center}.dl-label>.inner>.line>.inner[data-v-84a90e9a]{width:100%;border-top-width:1px;--tw-border-opacity: 1;border-color:rgb(209 213 219 / var(--tw-border-opacity))}.dl-label .text[data-v-84a90e9a]{position:relative;display:flex;justify-content:center}.dl-label .text>.inner[data-v-84a90e9a]{--tw-bg-opacity: 1;background-color:rgb(255 255 255 / var(--tw-bg-opacity));padding-left:.5rem;padding-right:.5rem;font-size:.875rem;line-height:1.25rem;--tw-text-opacity: 1;color:rgb(107 114 128 / var(--tw-text-opacity))}.dl-list[data-v-84a90e9a]{display:grid;grid-template-columns:repeat(1,minmax(0,1fr));gap:1rem}.dl-list .item[data-v-84a90e9a]{border-radius:.5rem;border-width:1px;--tw-border-opacity: 1;border-color:rgb(229 231 235 / var(--tw-border-opacity));--tw-shadow: 0 1px 2px 0 rgb(0 0 0 / .05);--tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.dl-list .item[data-v-84a90e9a]:hover{--tw-bg-opacity: 1;background-color:rgb(249 250 251 / var(--tw-bg-opacity))}.dl-list .item .inner[data-v-84a90e9a]{display:flex;align-items:center;justify-content:space-between}.dl-list .item .inner[data-v-84a90e9a]>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(.75rem * var(--tw-space-x-reverse));margin-left:calc(.75rem * calc(1 - var(--tw-space-x-reverse)))}.dl-list .item .inner[data-v-84a90e9a]{padding:.625rem 1rem}.dl-list .item .inner>.text[data-v-84a90e9a]{flex:1 1 0%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.dl-list .item .inner>.text h3[data-v-84a90e9a]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-size:1rem;line-height:1.5rem;font-weight:500;--tw-text-opacity: 1;color:rgb(17 24 39 / var(--tw-text-opacity))}.dl-list .item .inner>.icon[data-v-84a90e9a]{width:1.25rem;flex-shrink:0;--tw-text-opacity: 1;color:rgb(209 213 219 / var(--tw-text-opacity))}.verifying[data-v-41e07a4d]{display:flex;flex-direction:column;align-items:center;justify-content:center;padding:2rem 2.5rem}@media (min-width: 640px){.verifying[data-v-41e07a4d]{padding:3rem}}.avatar-outer[data-v-41e07a4d]{margin-top:.25rem;margin-bottom:.75rem;display:flex;align-items:center;justify-content:center}.avatar-outer[data-v-41e07a4d]>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(1.5rem * var(--tw-space-x-reverse));margin-left:calc(1.5rem * calc(1 - var(--tw-space-x-reverse)))}@media (min-width: 640px){.avatar-outer[data-v-41e07a4d]{margin-bottom:1.25rem}}.spinner[data-v-41e07a4d]{width:2rem;--tw-text-opacity: 1;color:rgb(234 88 12 / var(--tw-text-opacity))}.icon[data-v-41e07a4d]{position:relative;display:flex;height:4rem;width:4rem;align-items:center;justify-content:center;border-radius:9999px;--tw-bg-opacity: 1;background-color:rgb(255 247 237 / var(--tw-bg-opacity))}.icon svg[data-v-41e07a4d]{height:2rem;width:2rem;--tw-text-opacity: 1;color:rgb(234 88 12 / var(--tw-text-opacity))}.footer[data-v-15bda34c]{display:flex;align-items:center;justify-content:center;padding-left:1rem;padding-right:1rem;padding-bottom:.75rem;font-size:.75rem;line-height:1rem;--tw-text-opacity: 1;color:rgb(107 114 128 / var(--tw-text-opacity))}.footer.branded[data-v-15bda34c]{justify-content:space-between;border-top-width:1px;--tw-border-opacity: 1;border-color:rgb(243 244 246 / var(--tw-border-opacity));--tw-bg-opacity: 1;background-color:rgb(249 250 251 / var(--tw-bg-opacity));padding-top:.75rem}.logo[data-v-15bda34c]{display:flex;align-items:center}.logo a[data-v-15bda34c]{margin-left:.25rem}.logo a[data-v-15bda34c]:focus{outline:2px solid transparent;outline-offset:2px}.logo a img[data-v-15bda34c]{height:.875rem}.link[data-v-15bda34c]:hover{--tw-text-opacity: 1;color:rgb(55 65 81 / var(--tw-text-opacity))}.dialog-root[data-v-fb40a706]{display:flex;min-height:100vh;align-items:flex-end;justify-content:center;padding:1rem 1rem 5rem;text-align:center}@media (min-width: 640px){.dialog-root[data-v-fb40a706]{display:block}.dialog-root[data-v-fb40a706]{padding:0}}.dialog-root .center-hack[data-v-fb40a706]{display:none}@media (min-width: 640px){.dialog-root .center-hack[data-v-fb40a706]{display:inline-block}.dialog-root .center-hack[data-v-fb40a706]{height:100vh}.dialog-root .center-hack[data-v-fb40a706]{vertical-align:middle}}.dialog-root .overlay[data-v-fb40a706]{pointer-events:none;position:fixed;top:0px;right:0px;bottom:0px;left:0px;background-color:rgb(17 24 39 / var(--tw-bg-opacity));--tw-bg-opacity: .75;transition-property:opacity;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.modal-outer[data-v-fb40a706]{position:relative;display:inline-block;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));text-align:left;vertical-align:bottom;transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}@media (min-width: 640px){.modal-outer[data-v-fb40a706]{margin-top:2rem;margin-bottom:2rem}.modal-outer[data-v-fb40a706]{width:100%}.modal-outer[data-v-fb40a706]{max-width:24rem}.modal-outer[data-v-fb40a706]{vertical-align:middle}}.close[data-v-fb40a706]{position:absolute;left:0px;right:0px;top:-3rem;display:flex;justify-content:flex-end}.close button[data-v-fb40a706]{display:inline-flex;align-items:center;border-radius:9999px;border-width:1px;border-color:transparent;background-color:rgb(255 255 255 / var(--tw-bg-opacity));--tw-bg-opacity: .1;padding:.375rem;--tw-text-opacity: 1;color:rgb(229 231 235 / var(--tw-text-opacity));--tw-shadow: 0 1px 2px 0 rgb(0 0 0 / .05);--tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.close button[data-v-fb40a706]:hover{--tw-bg-opacity: .2;--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}.close button[data-v-fb40a706]:focus{outline:2px solid transparent;outline-offset:2px}.close button svg[data-v-fb40a706]{height:1.5rem;width:1.5rem}.modal-inner[data-v-fb40a706]{overflow:hidden;border-radius:.5rem;--tw-bg-opacity: 1;background-color:rgb(255 255 255 / var(--tw-bg-opacity));--tw-shadow: 0 20px 25px -5px rgb(0 0 0 / .1), 0 8px 10px -6px rgb(0 0 0 / .1);--tw-shadow-colored: 0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.overlay-enter[data-v-fb40a706]{transition-duration:.3s;transition-timing-function:cubic-bezier(0,0,.2,1)}.overlay-enter-from[data-v-fb40a706]{opacity:0}.overlay-enter-to[data-v-fb40a706]{opacity:1}.overlay-leave[data-v-fb40a706]{transition-duration:.2s;transition-timing-function:cubic-bezier(.4,0,1,1)}.overlay-leave-from[data-v-fb40a706]{opacity:1}.overlay-leave-to[data-v-fb40a706]{opacity:0}.modal-enter[data-v-fb40a706]{transition-duration:.3s;transition-timing-function:cubic-bezier(0,0,.2,1)}.modal-enter-from[data-v-fb40a706]{--tw-translate-y: 1rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));opacity:0}@media (min-width: 640px){.modal-enter-from[data-v-fb40a706]{--tw-translate-y: 0px;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.modal-enter-from[data-v-fb40a706]{--tw-scale-x: .95;--tw-scale-y: .95;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}}.modal-enter-to[data-v-fb40a706]{--tw-translate-y: 0px;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));opacity:1}@media (min-width: 640px){.modal-enter-to[data-v-fb40a706]{--tw-scale-x: 1;--tw-scale-y: 1;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}}.modal-leave[data-v-fb40a706]{transition-duration:.2s;transition-timing-function:cubic-bezier(.4,0,1,1)}.modal-leave-from[data-v-fb40a706]{--tw-translate-y: 0px;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));opacity:1}@media (min-width: 640px){.modal-leave-from[data-v-fb40a706]{--tw-scale-x: 1;--tw-scale-y: 1;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}}.modal-leave-to[data-v-fb40a706]{--tw-translate-y: 1rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));opacity:0}@media (min-width: 640px){.modal-leave-to[data-v-fb40a706]{--tw-translate-y: 0px;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.modal-leave-to[data-v-fb40a706]{--tw-scale-x: .95;--tw-scale-y: .95;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}}.resize-observer[data-v-b329ee4c]{position:absolute;top:0;left:0;z-index:-1;width:100%;height:100%;border:none;background-color:transparent;pointer-events:none;display:block;overflow:hidden;opacity:0}.resize-observer[data-v-b329ee4c] object{display:block;position:absolute;top:0;left:0;height:100%;width:100%;overflow:hidden;pointer-events:none;z-index:-1}.v-popper__popper{z-index:10000;top:0;left:0}.v-popper__popper.v-popper__popper--hidden{visibility:hidden;opacity:0;transition:opacity .15s,visibility .15s;pointer-events:none}.v-popper__popper.v-popper__popper--shown{visibility:visible;opacity:1;transition:opacity .15s}.v-popper__popper.v-popper__popper--skip-transition,.v-popper__popper.v-popper__popper--skip-transition>.v-popper__wrapper{transition:none!important}.v-popper__backdrop{position:absolute;top:0;left:0;width:100%;height:100%;display:none}.v-popper__inner{position:relative;box-sizing:border-box;overflow-y:auto}.v-popper__inner>div{position:relative;z-index:1;max-width:inherit;max-height:inherit}.v-popper__arrow-container{position:absolute;width:10px;height:10px}.v-popper__popper--arrow-overflow .v-popper__arrow-container,.v-popper__popper--no-positioning .v-popper__arrow-container{display:none}.v-popper__arrow-inner,.v-popper__arrow-outer{border-style:solid;position:absolute;top:0;left:0;width:0;height:0}.v-popper__arrow-inner{visibility:hidden;border-width:7px}.v-popper__arrow-outer{border-width:6px}.v-popper__popper[data-popper-placement^=top] .v-popper__arrow-inner,.v-popper__popper[data-popper-placement^=bottom] .v-popper__arrow-inner{left:-2px}.v-popper__popper[data-popper-placement^=top] .v-popper__arrow-outer,.v-popper__popper[data-popper-placement^=bottom] .v-popper__arrow-outer{left:-1px}.v-popper__popper[data-popper-placement^=top] .v-popper__arrow-inner,.v-popper__popper[data-popper-placement^=top] .v-popper__arrow-outer{border-bottom-width:0;border-left-color:transparent!important;border-right-color:transparent!important;border-bottom-color:transparent!important}.v-popper__popper[data-popper-placement^=top] .v-popper__arrow-inner{top:-2px}.v-popper__popper[data-popper-placement^=bottom] .v-popper__arrow-container{top:0}.v-popper__popper[data-popper-placement^=bottom] .v-popper__arrow-inner,.v-popper__popper[data-popper-placement^=bottom] .v-popper__arrow-outer{border-top-width:0;border-left-color:transparent!important;border-right-color:transparent!important;border-top-color:transparent!important}.v-popper__popper[data-popper-placement^=bottom] .v-popper__arrow-inner{top:-4px}.v-popper__popper[data-popper-placement^=bottom] .v-popper__arrow-outer{top:-6px}.v-popper__popper[data-popper-placement^=left] .v-popper__arrow-inner,.v-popper__popper[data-popper-placement^=right] .v-popper__arrow-inner{top:-2px}.v-popper__popper[data-popper-placement^=left] .v-popper__arrow-outer,.v-popper__popper[data-popper-placement^=right] .v-popper__arrow-outer{top:-1px}.v-popper__popper[data-popper-placement^=right] .v-popper__arrow-inner,.v-popper__popper[data-popper-placement^=right] .v-popper__arrow-outer{border-left-width:0;border-left-color:transparent!important;border-top-color:transparent!important;border-bottom-color:transparent!important}.v-popper__popper[data-popper-placement^=right] .v-popper__arrow-inner{left:-4px}.v-popper__popper[data-popper-placement^=right] .v-popper__arrow-outer{left:-6px}.v-popper__popper[data-popper-placement^=left] .v-popper__arrow-container{right:-10px}.v-popper__popper[data-popper-placement^=left] .v-popper__arrow-inner,.v-popper__popper[data-popper-placement^=left] .v-popper__arrow-outer{border-right-width:0;border-top-color:transparent!important;border-right-color:transparent!important;border-bottom-color:transparent!important}.v-popper__popper[data-popper-placement^=left] .v-popper__arrow-inner{left:-2px}.v-popper--theme-dropdown .v-popper__inner{background:#fff;color:#000;border-radius:6px;border:1px solid #ddd;box-shadow:0 6px 30px #0000001a}.v-popper--theme-dropdown .v-popper__arrow-inner{visibility:visible;border-color:#fff}.v-popper--theme-dropdown .v-popper__arrow-outer{border-color:#ddd}.v-popper--theme-tooltip .v-popper__inner{background:rgba(0,0,0,.8);color:#fff;border-radius:6px;padding:7px 12px 6px}.v-popper--theme-tooltip .v-popper__arrow-outer{border-color:#000c}.dhh-verify-root,.v-popper__popper{font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji"}.dhh-verify-root{position:fixed;top:0px;right:0px;bottom:0px;left:0px;overflow-y:auto;z-index:10000!important;line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4}.dhh-verify-root *{line-height:inherit;margin:0;font-size:inherit;font-weight:inherit}.dhh-verify-root a{color:inherit;text-decoration:inherit}.dhh-verify-root button,.dhh-verify-root input,.dhh-verify-root optgroup,.dhh-verify-root select,.dhh-verify-root textarea{font-family:inherit;font-size:100%;line-height:inherit;color:inherit;margin:0;padding:0}.dhh-verify-root button,.dhh-verify-root [role=button]{cursor:pointer}.dhh-verify-root ol,.dhh-verify-root ul,.dhh-verify-root menu{list-style:none;margin:0;padding:0}.dhh-verify-root code,.dhh-verify-root pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}`; document.head.appendChild(elementStyle);} catch(e) {console.error(e, 'vite-plugin-css-injected-by-js: error when trying to add the style.');} })();var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __objRest = (source2, exclude) => {
  var target = {};
  for (var prop in source2)
    if (__hasOwnProp.call(source2, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source2[prop];
  if (source2 != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source2)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source2, prop))
        target[prop] = source2[prop];
    }
  return target;
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var a2 = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var bn$1 = { exports: {} };
(function(module) {
  (function(module2, exports) {
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN2(number, base2, endian) {
      if (BN2.isBN(number)) {
        return number;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number !== null) {
        if (base2 === "le" || base2 === "be") {
          endian = base2;
          base2 = 10;
        }
        this._init(number || 0, base2 || 10, endian || "be");
      }
    }
    if (typeof module2 === "object") {
      module2.exports = BN2;
    } else {
      exports.BN = BN2;
    }
    BN2.BN = BN2;
    BN2.wordSize = 26;
    var Buffer3;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer3 = window.Buffer;
      } else {
        Buffer3 = require("buffer").Buffer;
      }
    } catch (e2) {
    }
    BN2.isBN = function isBN(num) {
      if (num instanceof BN2) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
    };
    BN2.max = function max2(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN2.min = function min2(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN2.prototype._init = function init4(number, base2, endian) {
      if (typeof number === "number") {
        return this._initNumber(number, base2, endian);
      }
      if (typeof number === "object") {
        return this._initArray(number, base2, endian);
      }
      if (base2 === "hex") {
        base2 = 16;
      }
      assert2(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
      number = number.toString().replace(/\s+/g, "");
      var start = 0;
      if (number[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number.length) {
        if (base2 === 16) {
          this._parseHex(number, start, endian);
        } else {
          this._parseBase(number, base2, start);
          if (endian === "le") {
            this._initArray(this.toArray(), base2, endian);
          }
        }
      }
    };
    BN2.prototype._initNumber = function _initNumber(number, base2, endian) {
      if (number < 0) {
        this.negative = 1;
        number = -number;
      }
      if (number < 67108864) {
        this.words = [number & 67108863];
        this.length = 1;
      } else if (number < 4503599627370496) {
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert2(number < 9007199254740992);
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base2, endian);
    };
    BN2.prototype._initArray = function _initArray(number, base2, endian) {
      assert2(typeof number.length === "number");
      if (number.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number.length / 3);
      this.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        this.words[i2] = 0;
      }
      var j2, w2;
      var off2 = 0;
      if (endian === "be") {
        for (i2 = number.length - 1, j2 = 0; i2 >= 0; i2 -= 3) {
          w2 = number[i2] | number[i2 - 1] << 8 | number[i2 - 2] << 16;
          this.words[j2] |= w2 << off2 & 67108863;
          this.words[j2 + 1] = w2 >>> 26 - off2 & 67108863;
          off2 += 24;
          if (off2 >= 26) {
            off2 -= 26;
            j2++;
          }
        }
      } else if (endian === "le") {
        for (i2 = 0, j2 = 0; i2 < number.length; i2 += 3) {
          w2 = number[i2] | number[i2 + 1] << 8 | number[i2 + 2] << 16;
          this.words[j2] |= w2 << off2 & 67108863;
          this.words[j2 + 1] = w2 >>> 26 - off2 & 67108863;
          off2 += 24;
          if (off2 >= 26) {
            off2 -= 26;
            j2++;
          }
        }
      }
      return this.strip();
    };
    function parseHex4Bits(string, index2) {
      var c2 = string.charCodeAt(index2);
      if (c2 >= 65 && c2 <= 70) {
        return c2 - 55;
      } else if (c2 >= 97 && c2 <= 102) {
        return c2 - 87;
      } else {
        return c2 - 48 & 15;
      }
    }
    function parseHexByte(string, lowerBound, index2) {
      var r2 = parseHex4Bits(string, index2);
      if (index2 - 1 >= lowerBound) {
        r2 |= parseHex4Bits(string, index2 - 1) << 4;
      }
      return r2;
    }
    BN2.prototype._parseHex = function _parseHex(number, start, endian) {
      this.length = Math.ceil((number.length - start) / 6);
      this.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        this.words[i2] = 0;
      }
      var off2 = 0;
      var j2 = 0;
      var w2;
      if (endian === "be") {
        for (i2 = number.length - 1; i2 >= start; i2 -= 2) {
          w2 = parseHexByte(number, start, i2) << off2;
          this.words[j2] |= w2 & 67108863;
          if (off2 >= 18) {
            off2 -= 18;
            j2 += 1;
            this.words[j2] |= w2 >>> 26;
          } else {
            off2 += 8;
          }
        }
      } else {
        var parseLength = number.length - start;
        for (i2 = parseLength % 2 === 0 ? start + 1 : start; i2 < number.length; i2 += 2) {
          w2 = parseHexByte(number, start, i2) << off2;
          this.words[j2] |= w2 & 67108863;
          if (off2 >= 18) {
            off2 -= 18;
            j2 += 1;
            this.words[j2] |= w2 >>> 26;
          } else {
            off2 += 8;
          }
        }
      }
      this.strip();
    };
    function parseBase(str, start, end, mul4) {
      var r2 = 0;
      var len = Math.min(str.length, end);
      for (var i2 = start; i2 < len; i2++) {
        var c2 = str.charCodeAt(i2) - 48;
        r2 *= mul4;
        if (c2 >= 49) {
          r2 += c2 - 49 + 10;
        } else if (c2 >= 17) {
          r2 += c2 - 17 + 10;
        } else {
          r2 += c2;
        }
      }
      return r2;
    }
    BN2.prototype._parseBase = function _parseBase(number, base2, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base2 | 0;
      var total = number.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word = 0;
      for (var i2 = start; i2 < end; i2 += limbLen) {
        word = parseBase(number, i2, i2 + limbLen, base2);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod !== 0) {
        var pow = 1;
        word = parseBase(number, i2, number.length, base2);
        for (i2 = 0; i2 < mod; i2++) {
          pow *= base2;
        }
        this.imuln(pow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this.strip();
    };
    BN2.prototype.copy = function copy4(dest) {
      dest.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        dest.words[i2] = this.words[i2];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    BN2.prototype.clone = function clone() {
      var r2 = new BN2(null);
      this.copy(r2);
      return r2;
    };
    BN2.prototype._expand = function _expand(size2) {
      while (this.length < size2) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN2.prototype.strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN2.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    BN2.prototype.inspect = function inspect5() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var zeros = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN2.prototype.toString = function toString4(base2, padding2) {
      base2 = base2 || 10;
      padding2 = padding2 | 0 || 1;
      var out;
      if (base2 === 16 || base2 === "hex") {
        out = "";
        var off2 = 0;
        var carry = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var w2 = this.words[i2];
          var word = ((w2 << off2 | carry) & 16777215).toString(16);
          carry = w2 >>> 24 - off2 & 16777215;
          if (carry !== 0 || i2 !== this.length - 1) {
            out = zeros[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
          off2 += 2;
          if (off2 >= 26) {
            off2 -= 26;
            i2--;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
        var groupSize = groupSizes[base2];
        var groupBase = groupBases[base2];
        out = "";
        var c2 = this.clone();
        c2.negative = 0;
        while (!c2.isZero()) {
          var r2 = c2.modn(groupBase).toString(base2);
          c2 = c2.idivn(groupBase);
          if (!c2.isZero()) {
            out = zeros[groupSize - r2.length] + r2 + out;
          } else {
            out = r2 + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert2(false, "Base should be between 2 and 36");
    };
    BN2.prototype.toNumber = function toNumber2() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN2.prototype.toJSON = function toJSON3() {
      return this.toString(16);
    };
    BN2.prototype.toBuffer = function toBuffer(endian, length) {
      assert2(typeof Buffer3 !== "undefined");
      return this.toArrayLike(Buffer3, endian, length);
    };
    BN2.prototype.toArray = function toArray2(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };
    BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      var byteLength2 = this.byteLength();
      var reqLength = length || Math.max(1, byteLength2);
      assert2(byteLength2 <= reqLength, "byte array longer than desired length");
      assert2(reqLength > 0, "Requested array length <= 0");
      this.strip();
      var littleEndian = endian === "le";
      var res = new ArrayType(reqLength);
      var b2, i2;
      var q2 = this.clone();
      if (!littleEndian) {
        for (i2 = 0; i2 < reqLength - byteLength2; i2++) {
          res[i2] = 0;
        }
        for (i2 = 0; !q2.isZero(); i2++) {
          b2 = q2.andln(255);
          q2.iushrn(8);
          res[reqLength - i2 - 1] = b2;
        }
      } else {
        for (i2 = 0; !q2.isZero(); i2++) {
          b2 = q2.andln(255);
          q2.iushrn(8);
          res[i2] = b2;
        }
        for (; i2 < reqLength; i2++) {
          res[i2] = 0;
        }
      }
      return res;
    };
    if (Math.clz32) {
      BN2.prototype._countBits = function _countBits(w2) {
        return 32 - Math.clz32(w2);
      };
    } else {
      BN2.prototype._countBits = function _countBits(w2) {
        var t2 = w2;
        var r2 = 0;
        if (t2 >= 4096) {
          r2 += 13;
          t2 >>>= 13;
        }
        if (t2 >= 64) {
          r2 += 7;
          t2 >>>= 7;
        }
        if (t2 >= 8) {
          r2 += 4;
          t2 >>>= 4;
        }
        if (t2 >= 2) {
          r2 += 2;
          t2 >>>= 2;
        }
        return r2 + t2;
      };
    }
    BN2.prototype._zeroBits = function _zeroBits(w2) {
      if (w2 === 0)
        return 26;
      var t2 = w2;
      var r2 = 0;
      if ((t2 & 8191) === 0) {
        r2 += 13;
        t2 >>>= 13;
      }
      if ((t2 & 127) === 0) {
        r2 += 7;
        t2 >>>= 7;
      }
      if ((t2 & 15) === 0) {
        r2 += 4;
        t2 >>>= 4;
      }
      if ((t2 & 3) === 0) {
        r2 += 2;
        t2 >>>= 2;
      }
      if ((t2 & 1) === 0) {
        r2++;
      }
      return r2;
    };
    BN2.prototype.bitLength = function bitLength() {
      var w2 = this.words[this.length - 1];
      var hi = this._countBits(w2);
      return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
      var w2 = new Array(num.bitLength());
      for (var bit = 0; bit < w2.length; bit++) {
        var off2 = bit / 26 | 0;
        var wbit = bit % 26;
        w2[bit] = (num.words[off2] & 1 << wbit) >>> wbit;
      }
      return w2;
    }
    BN2.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r2 = 0;
      for (var i2 = 0; i2 < this.length; i2++) {
        var b2 = this._zeroBits(this.words[i2]);
        r2 += b2;
        if (b2 !== 26)
          break;
      }
      return r2;
    };
    BN2.prototype.byteLength = function byteLength2() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN2.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN2.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN2.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN2.prototype.neg = function neg3() {
      return this.clone().ineg();
    };
    BN2.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN2.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i2 = 0; i2 < num.length; i2++) {
        this.words[i2] = this.words[i2] | num.words[i2];
      }
      return this.strip();
    };
    BN2.prototype.ior = function ior(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN2.prototype.or = function or(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN2.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN2.prototype.iuand = function iuand(num) {
      var b2;
      if (this.length > num.length) {
        b2 = num;
      } else {
        b2 = this;
      }
      for (var i2 = 0; i2 < b2.length; i2++) {
        this.words[i2] = this.words[i2] & num.words[i2];
      }
      this.length = b2.length;
      return this.strip();
    };
    BN2.prototype.iand = function iand(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN2.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN2.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN2.prototype.iuxor = function iuxor(num) {
      var a2;
      var b2;
      if (this.length > num.length) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      for (var i2 = 0; i2 < b2.length; i2++) {
        this.words[i2] = a2.words[i2] ^ b2.words[i2];
      }
      if (this !== a2) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      this.length = a2.length;
      return this.strip();
    };
    BN2.prototype.ixor = function ixor(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN2.prototype.xor = function xor(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN2.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN2.prototype.inotn = function inotn(width) {
      assert2(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i2 = 0; i2 < bytesNeeded; i2++) {
        this.words[i2] = ~this.words[i2] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
      }
      return this.strip();
    };
    BN2.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN2.prototype.setn = function setn(bit, val) {
      assert2(typeof bit === "number" && bit >= 0);
      var off2 = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off2 + 1);
      if (val) {
        this.words[off2] = this.words[off2] | 1 << wbit;
      } else {
        this.words[off2] = this.words[off2] & ~(1 << wbit);
      }
      return this.strip();
    };
    BN2.prototype.iadd = function iadd(num) {
      var r2;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r2 = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r2 = this.isub(num);
        num.negative = 1;
        return r2._normSign();
      }
      var a2, b2;
      if (this.length > num.length) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      var carry = 0;
      for (var i2 = 0; i2 < b2.length; i2++) {
        r2 = (a2.words[i2] | 0) + (b2.words[i2] | 0) + carry;
        this.words[i2] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      for (; carry !== 0 && i2 < a2.length; i2++) {
        r2 = (a2.words[i2] | 0) + carry;
        this.words[i2] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      this.length = a2.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a2 !== this) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      return this;
    };
    BN2.prototype.add = function add4(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN2.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r2 = this.iadd(num);
        num.negative = 1;
        return r2._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a2, b2;
      if (cmp > 0) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      var carry = 0;
      for (var i2 = 0; i2 < b2.length; i2++) {
        r2 = (a2.words[i2] | 0) - (b2.words[i2] | 0) + carry;
        carry = r2 >> 26;
        this.words[i2] = r2 & 67108863;
      }
      for (; carry !== 0 && i2 < a2.length; i2++) {
        r2 = (a2.words[i2] | 0) + carry;
        carry = r2 >> 26;
        this.words[i2] = r2 & 67108863;
      }
      if (carry === 0 && i2 < a2.length && a2 !== this) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      this.length = Math.max(this.length, i2);
      if (a2 !== this) {
        this.negative = 1;
      }
      return this.strip();
    };
    BN2.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len = self2.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0;
      var a2 = self2.words[0] | 0;
      var b2 = num.words[0] | 0;
      var r2 = a2 * b2;
      var lo = r2 & 67108863;
      var carry = r2 / 67108864 | 0;
      out.words[0] = lo;
      for (var k2 = 1; k2 < len; k2++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k2, num.length - 1);
        for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
          var i2 = k2 - j2 | 0;
          a2 = self2.words[i2] | 0;
          b2 = num.words[j2] | 0;
          r2 = a2 * b2 + rword;
          ncarry += r2 / 67108864 | 0;
          rword = r2 & 67108863;
        }
        out.words[k2] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k2] = carry | 0;
      } else {
        out.length--;
      }
      return out.strip();
    }
    var comb10MulTo = function comb10MulTo2(self2, num, out) {
      var a2 = self2.words;
      var b2 = num.words;
      var o2 = out.words;
      var c2 = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a2[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a2[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a22 = a2[2] | 0;
      var al2 = a22 & 8191;
      var ah2 = a22 >>> 13;
      var a3 = a2[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a2[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a2[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a2[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a2[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a2[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a2[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b2[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b2[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b22 = b2[2] | 0;
      var bl2 = b22 & 8191;
      var bh2 = b22 >>> 13;
      var b3 = b2[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b2[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b2[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b2[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b2[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b2[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b2[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o2[0] = w0;
      o2[1] = w1;
      o2[2] = w2;
      o2[3] = w3;
      o2[4] = w4;
      o2[5] = w5;
      o2[6] = w6;
      o2[7] = w7;
      o2[8] = w8;
      o2[9] = w9;
      o2[10] = w10;
      o2[11] = w11;
      o2[12] = w12;
      o2[13] = w13;
      o2[14] = w14;
      o2[15] = w15;
      o2[16] = w16;
      o2[17] = w17;
      o2[18] = w18;
      if (c2 !== 0) {
        o2[19] = c2;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k2 = 0; k2 < out.length - 1; k2++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k2, num.length - 1);
        for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
          var i2 = k2 - j2;
          var a2 = self2.words[i2] | 0;
          var b2 = num.words[j2] | 0;
          var r2 = a2 * b2;
          var lo = r2 & 67108863;
          ncarry = ncarry + (r2 / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k2] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k2] = carry;
      } else {
        out.length--;
      }
      return out.strip();
    }
    function jumboMulTo(self2, num, out) {
      var fftm = new FFTM();
      return fftm.mulp(self2, num, out);
    }
    BN2.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    function FFTM(x2, y2) {
      this.x = x2;
      this.y = y2;
    }
    FFTM.prototype.makeRBT = function makeRBT(N2) {
      var t2 = new Array(N2);
      var l2 = BN2.prototype._countBits(N2) - 1;
      for (var i2 = 0; i2 < N2; i2++) {
        t2[i2] = this.revBin(i2, l2, N2);
      }
      return t2;
    };
    FFTM.prototype.revBin = function revBin(x2, l2, N2) {
      if (x2 === 0 || x2 === N2 - 1)
        return x2;
      var rb = 0;
      for (var i2 = 0; i2 < l2; i2++) {
        rb |= (x2 & 1) << l2 - i2 - 1;
        x2 >>= 1;
      }
      return rb;
    };
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N2) {
      for (var i2 = 0; i2 < N2; i2++) {
        rtws[i2] = rws[rbt[i2]];
        itws[i2] = iws[rbt[i2]];
      }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N2, rbt) {
      this.permute(rbt, rws, iws, rtws, itws, N2);
      for (var s2 = 1; s2 < N2; s2 <<= 1) {
        var l2 = s2 << 1;
        var rtwdf = Math.cos(2 * Math.PI / l2);
        var itwdf = Math.sin(2 * Math.PI / l2);
        for (var p2 = 0; p2 < N2; p2 += l2) {
          var rtwdf_ = rtwdf;
          var itwdf_ = itwdf;
          for (var j2 = 0; j2 < s2; j2++) {
            var re = rtws[p2 + j2];
            var ie2 = itws[p2 + j2];
            var ro = rtws[p2 + j2 + s2];
            var io2 = itws[p2 + j2 + s2];
            var rx = rtwdf_ * ro - itwdf_ * io2;
            io2 = rtwdf_ * io2 + itwdf_ * ro;
            ro = rx;
            rtws[p2 + j2] = re + ro;
            itws[p2 + j2] = ie2 + io2;
            rtws[p2 + j2 + s2] = re - ro;
            itws[p2 + j2 + s2] = ie2 - io2;
            if (j2 !== l2) {
              rx = rtwdf * rtwdf_ - itwdf * itwdf_;
              itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
              rtwdf_ = rx;
            }
          }
        }
      }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n2, m2) {
      var N2 = Math.max(m2, n2) | 1;
      var odd = N2 & 1;
      var i2 = 0;
      for (N2 = N2 / 2 | 0; N2; N2 = N2 >>> 1) {
        i2++;
      }
      return 1 << i2 + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N2) {
      if (N2 <= 1)
        return;
      for (var i2 = 0; i2 < N2 / 2; i2++) {
        var t2 = rws[i2];
        rws[i2] = rws[N2 - i2 - 1];
        rws[N2 - i2 - 1] = t2;
        t2 = iws[i2];
        iws[i2] = -iws[N2 - i2 - 1];
        iws[N2 - i2 - 1] = -t2;
      }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N2) {
      var carry = 0;
      for (var i2 = 0; i2 < N2 / 2; i2++) {
        var w2 = Math.round(ws[2 * i2 + 1] / N2) * 8192 + Math.round(ws[2 * i2] / N2) + carry;
        ws[i2] = w2 & 67108863;
        if (w2 < 67108864) {
          carry = 0;
        } else {
          carry = w2 / 67108864 | 0;
        }
      }
      return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N2) {
      var carry = 0;
      for (var i2 = 0; i2 < len; i2++) {
        carry = carry + (ws[i2] | 0);
        rws[2 * i2] = carry & 8191;
        carry = carry >>> 13;
        rws[2 * i2 + 1] = carry & 8191;
        carry = carry >>> 13;
      }
      for (i2 = 2 * len; i2 < N2; ++i2) {
        rws[i2] = 0;
      }
      assert2(carry === 0);
      assert2((carry & ~8191) === 0);
    };
    FFTM.prototype.stub = function stub(N2) {
      var ph = new Array(N2);
      for (var i2 = 0; i2 < N2; i2++) {
        ph[i2] = 0;
      }
      return ph;
    };
    FFTM.prototype.mulp = function mulp(x2, y2, out) {
      var N2 = 2 * this.guessLen13b(x2.length, y2.length);
      var rbt = this.makeRBT(N2);
      var _2 = this.stub(N2);
      var rws = new Array(N2);
      var rwst = new Array(N2);
      var iwst = new Array(N2);
      var nrws = new Array(N2);
      var nrwst = new Array(N2);
      var niwst = new Array(N2);
      var rmws = out.words;
      rmws.length = N2;
      this.convert13b(x2.words, x2.length, rws, N2);
      this.convert13b(y2.words, y2.length, nrws, N2);
      this.transform(rws, _2, rwst, iwst, N2, rbt);
      this.transform(nrws, _2, nrwst, niwst, N2, rbt);
      for (var i2 = 0; i2 < N2; i2++) {
        var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
        iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2];
        rwst[i2] = rx;
      }
      this.conjugate(rwst, iwst, N2);
      this.transform(rwst, iwst, rmws, _2, N2, rbt);
      this.conjugate(rmws, _2, N2);
      this.normalize13b(rmws, N2);
      out.negative = x2.negative ^ y2.negative;
      out.length = x2.length + y2.length;
      return out.strip();
    };
    BN2.prototype.mul = function mul4(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN2.prototype.mulf = function mulf(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN2.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN2.prototype.imuln = function imuln(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      var carry = 0;
      for (var i2 = 0; i2 < this.length; i2++) {
        var w2 = (this.words[i2] | 0) * num;
        var lo = (w2 & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w2 / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i2] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i2] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN2.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN2.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN2.prototype.pow = function pow(num) {
      var w2 = toBitArray(num);
      if (w2.length === 0)
        return new BN2(1);
      var res = this;
      for (var i2 = 0; i2 < w2.length; i2++, res = res.sqr()) {
        if (w2[i2] !== 0)
          break;
      }
      if (++i2 < w2.length) {
        for (var q2 = res.sqr(); i2 < w2.length; i2++, q2 = q2.sqr()) {
          if (w2[i2] === 0)
            continue;
          res = res.mul(q2);
        }
      }
      return res;
    };
    BN2.prototype.iushln = function iushln(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
      var i2;
      if (r2 !== 0) {
        var carry = 0;
        for (i2 = 0; i2 < this.length; i2++) {
          var newCarry = this.words[i2] & carryMask;
          var c2 = (this.words[i2] | 0) - newCarry << r2;
          this.words[i2] = c2 | carry;
          carry = newCarry >>> 26 - r2;
        }
        if (carry) {
          this.words[i2] = carry;
          this.length++;
        }
      }
      if (s2 !== 0) {
        for (i2 = this.length - 1; i2 >= 0; i2--) {
          this.words[i2 + s2] = this.words[i2];
        }
        for (i2 = 0; i2 < s2; i2++) {
          this.words[i2] = 0;
        }
        this.length += s2;
      }
      return this.strip();
    };
    BN2.prototype.ishln = function ishln(bits) {
      assert2(this.negative === 0);
      return this.iushln(bits);
    };
    BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert2(typeof bits === "number" && bits >= 0);
      var h2;
      if (hint) {
        h2 = (hint - hint % 26) / 26;
      } else {
        h2 = 0;
      }
      var r2 = bits % 26;
      var s2 = Math.min((bits - r2) / 26, this.length);
      var mask = 67108863 ^ 67108863 >>> r2 << r2;
      var maskedWords = extended;
      h2 -= s2;
      h2 = Math.max(0, h2);
      if (maskedWords) {
        for (var i2 = 0; i2 < s2; i2++) {
          maskedWords.words[i2] = this.words[i2];
        }
        maskedWords.length = s2;
      }
      if (s2 === 0)
        ;
      else if (this.length > s2) {
        this.length -= s2;
        for (i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = this.words[i2 + s2];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h2); i2--) {
        var word = this.words[i2] | 0;
        this.words[i2] = carry << 26 - r2 | word >>> r2;
        carry = word & mask;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this.strip();
    };
    BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert2(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN2.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN2.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN2.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN2.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN2.prototype.testn = function testn(bit) {
      assert2(typeof bit === "number" && bit >= 0);
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q2 = 1 << r2;
      if (this.length <= s2)
        return false;
      var w2 = this.words[s2];
      return !!(w2 & q2);
    };
    BN2.prototype.imaskn = function imaskn(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      assert2(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s2) {
        return this;
      }
      if (r2 !== 0) {
        s2++;
      }
      this.length = Math.min(s2, this.length);
      if (r2 !== 0) {
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        this.words[this.length - 1] &= mask;
      }
      return this.strip();
    };
    BN2.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN2.prototype.iaddn = function iaddn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) < num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN2.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
        this.words[i2] -= 67108864;
        if (i2 === this.length - 1) {
          this.words[i2 + 1] = 1;
        } else {
          this.words[i2 + 1]++;
        }
      }
      this.length = Math.max(this.length, i2 + 1);
      return this;
    };
    BN2.prototype.isubn = function isubn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
          this.words[i2] += 67108864;
          this.words[i2 + 1] -= 1;
        }
      }
      return this.strip();
    };
    BN2.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN2.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN2.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN2.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul4, shift2) {
      var len = num.length + shift2;
      var i2;
      this._expand(len);
      var w2;
      var carry = 0;
      for (i2 = 0; i2 < num.length; i2++) {
        w2 = (this.words[i2 + shift2] | 0) + carry;
        var right = (num.words[i2] | 0) * mul4;
        w2 -= right & 67108863;
        carry = (w2 >> 26) - (right / 67108864 | 0);
        this.words[i2 + shift2] = w2 & 67108863;
      }
      for (; i2 < this.length - shift2; i2++) {
        w2 = (this.words[i2 + shift2] | 0) + carry;
        carry = w2 >> 26;
        this.words[i2 + shift2] = w2 & 67108863;
      }
      if (carry === 0)
        return this.strip();
      assert2(carry === -1);
      carry = 0;
      for (i2 = 0; i2 < this.length; i2++) {
        w2 = -(this.words[i2] | 0) + carry;
        carry = w2 >> 26;
        this.words[i2] = w2 & 67108863;
      }
      this.negative = 1;
      return this.strip();
    };
    BN2.prototype._wordDiv = function _wordDiv(num, mode2) {
      var shift2 = this.length - num.length;
      var a2 = this.clone();
      var b2 = num;
      var bhi = b2.words[b2.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift2 = 26 - bhiBits;
      if (shift2 !== 0) {
        b2 = b2.ushln(shift2);
        a2.iushln(shift2);
        bhi = b2.words[b2.length - 1] | 0;
      }
      var m2 = a2.length - b2.length;
      var q2;
      if (mode2 !== "mod") {
        q2 = new BN2(null);
        q2.length = m2 + 1;
        q2.words = new Array(q2.length);
        for (var i2 = 0; i2 < q2.length; i2++) {
          q2.words[i2] = 0;
        }
      }
      var diff = a2.clone()._ishlnsubmul(b2, 1, m2);
      if (diff.negative === 0) {
        a2 = diff;
        if (q2) {
          q2.words[m2] = 1;
        }
      }
      for (var j2 = m2 - 1; j2 >= 0; j2--) {
        var qj = (a2.words[b2.length + j2] | 0) * 67108864 + (a2.words[b2.length + j2 - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a2._ishlnsubmul(b2, qj, j2);
        while (a2.negative !== 0) {
          qj--;
          a2.negative = 0;
          a2._ishlnsubmul(b2, 1, j2);
          if (!a2.isZero()) {
            a2.negative ^= 1;
          }
        }
        if (q2) {
          q2.words[j2] = qj;
        }
      }
      if (q2) {
        q2.strip();
      }
      a2.strip();
      if (mode2 !== "div" && shift2 !== 0) {
        a2.iushrn(shift2);
      }
      return {
        div: q2 || null,
        mod: a2
      };
    };
    BN2.prototype.divmod = function divmod(num, mode2, positive) {
      assert2(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN2(0),
          mod: new BN2(0)
        };
      }
      var div, mod, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode2);
        if (mode2 !== "mod") {
          div = res.div.neg();
        }
        if (mode2 !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }
        return {
          div,
          mod
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode2);
        if (mode2 !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode2);
        if (mode2 !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }
        return {
          div: res.div,
          mod
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN2(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode2 === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode2 === "mod") {
          return {
            div: null,
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN2(this.modn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode2);
    };
    BN2.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN2.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN2.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN2.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN2.prototype.modn = function modn(num) {
      assert2(num <= 67108863);
      var p2 = (1 << 26) % num;
      var acc = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        acc = (p2 * acc + (this.words[i2] | 0)) % num;
      }
      return acc;
    };
    BN2.prototype.idivn = function idivn(num) {
      assert2(num <= 67108863);
      var carry = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        var w2 = (this.words[i2] | 0) + carry * 67108864;
        this.words[i2] = w2 / num | 0;
        carry = w2 % num;
      }
      return this.strip();
    };
    BN2.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN2.prototype.egcd = function egcd(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var x2 = this;
      var y2 = p2.clone();
      if (x2.negative !== 0) {
        x2 = x2.umod(p2);
      } else {
        x2 = x2.clone();
      }
      var A2 = new BN2(1);
      var B2 = new BN2(0);
      var C2 = new BN2(0);
      var D2 = new BN2(1);
      var g2 = 0;
      while (x2.isEven() && y2.isEven()) {
        x2.iushrn(1);
        y2.iushrn(1);
        ++g2;
      }
      var yp = y2.clone();
      var xp = x2.clone();
      while (!x2.isZero()) {
        for (var i2 = 0, im = 1; (x2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
          ;
        if (i2 > 0) {
          x2.iushrn(i2);
          while (i2-- > 0) {
            if (A2.isOdd() || B2.isOdd()) {
              A2.iadd(yp);
              B2.isub(xp);
            }
            A2.iushrn(1);
            B2.iushrn(1);
          }
        }
        for (var j2 = 0, jm = 1; (y2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
          ;
        if (j2 > 0) {
          y2.iushrn(j2);
          while (j2-- > 0) {
            if (C2.isOdd() || D2.isOdd()) {
              C2.iadd(yp);
              D2.isub(xp);
            }
            C2.iushrn(1);
            D2.iushrn(1);
          }
        }
        if (x2.cmp(y2) >= 0) {
          x2.isub(y2);
          A2.isub(C2);
          B2.isub(D2);
        } else {
          y2.isub(x2);
          C2.isub(A2);
          D2.isub(B2);
        }
      }
      return {
        a: C2,
        b: D2,
        gcd: y2.iushln(g2)
      };
    };
    BN2.prototype._invmp = function _invmp(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var a2 = this;
      var b2 = p2.clone();
      if (a2.negative !== 0) {
        a2 = a2.umod(p2);
      } else {
        a2 = a2.clone();
      }
      var x1 = new BN2(1);
      var x2 = new BN2(0);
      var delta = b2.clone();
      while (a2.cmpn(1) > 0 && b2.cmpn(1) > 0) {
        for (var i2 = 0, im = 1; (a2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
          ;
        if (i2 > 0) {
          a2.iushrn(i2);
          while (i2-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j2 = 0, jm = 1; (b2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
          ;
        if (j2 > 0) {
          b2.iushrn(j2);
          while (j2-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a2.cmp(b2) >= 0) {
          a2.isub(b2);
          x1.isub(x2);
        } else {
          b2.isub(a2);
          x2.isub(x1);
        }
      }
      var res;
      if (a2.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p2);
      }
      return res;
    };
    BN2.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a2 = this.clone();
      var b2 = num.clone();
      a2.negative = 0;
      b2.negative = 0;
      for (var shift2 = 0; a2.isEven() && b2.isEven(); shift2++) {
        a2.iushrn(1);
        b2.iushrn(1);
      }
      do {
        while (a2.isEven()) {
          a2.iushrn(1);
        }
        while (b2.isEven()) {
          b2.iushrn(1);
        }
        var r2 = a2.cmp(b2);
        if (r2 < 0) {
          var t2 = a2;
          a2 = b2;
          b2 = t2;
        } else if (r2 === 0 || b2.cmpn(1) === 0) {
          break;
        }
        a2.isub(b2);
      } while (true);
      return b2.iushln(shift2);
    };
    BN2.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN2.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN2.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN2.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN2.prototype.bincn = function bincn(bit) {
      assert2(typeof bit === "number");
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q2 = 1 << r2;
      if (this.length <= s2) {
        this._expand(s2 + 1);
        this.words[s2] |= q2;
        return this;
      }
      var carry = q2;
      for (var i2 = s2; carry !== 0 && i2 < this.length; i2++) {
        var w2 = this.words[i2] | 0;
        w2 += carry;
        carry = w2 >>> 26;
        w2 &= 67108863;
        this.words[i2] = w2;
      }
      if (carry !== 0) {
        this.words[i2] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN2.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this.strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert2(num <= 67108863, "Number is too big");
        var w2 = this.words[0] | 0;
        res = w2 === num ? 0 : w2 < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        var a2 = this.words[i2] | 0;
        var b2 = num.words[i2] | 0;
        if (a2 === b2)
          continue;
        if (a2 < b2) {
          res = -1;
        } else if (a2 > b2) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN2.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN2.prototype.gt = function gt2(num) {
      return this.cmp(num) === 1;
    };
    BN2.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN2.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN2.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN2.prototype.lt = function lt2(num) {
      return this.cmp(num) === -1;
    };
    BN2.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN2.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN2.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN2.prototype.eq = function eq4(num) {
      return this.cmp(num) === 0;
    };
    BN2.red = function red(num) {
      return new Red(num);
    };
    BN2.prototype.toRed = function toRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      assert2(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN2.prototype.fromRed = function fromRed() {
      assert2(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN2.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN2.prototype.forceRed = function forceRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN2.prototype.redAdd = function redAdd(num) {
      assert2(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN2.prototype.redIAdd = function redIAdd(num) {
      assert2(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN2.prototype.redSub = function redSub(num) {
      assert2(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN2.prototype.redISub = function redISub(num) {
      assert2(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN2.prototype.redShl = function redShl(num) {
      assert2(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN2.prototype.redMul = function redMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN2.prototype.redIMul = function redIMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN2.prototype.redSqr = function redSqr() {
      assert2(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN2.prototype.redISqr = function redISqr() {
      assert2(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN2.prototype.redSqrt = function redSqrt() {
      assert2(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN2.prototype.redInvm = function redInvm() {
      assert2(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN2.prototype.redNeg = function redNeg() {
      assert2(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN2.prototype.redPow = function redPow(num) {
      assert2(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name, p2) {
      this.name = name;
      this.p = new BN2(p2, 16);
      this.n = this.p.bitLength();
      this.k = new BN2(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN2(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r2 = num;
      var rlen;
      do {
        this.split(r2, this.tmp);
        r2 = this.imulK(r2);
        r2 = r2.iadd(this.tmp);
        rlen = r2.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
      if (cmp === 0) {
        r2.words[0] = 0;
        r2.length = 1;
      } else if (cmp > 0) {
        r2.isub(this.p);
      } else {
        if (r2.strip !== void 0) {
          r2.strip();
        } else {
          r2._strip();
        }
      }
      return r2;
    };
    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits2(K256, MPrime);
    K256.prototype.split = function split(input, output) {
      var mask = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i2 = 0; i2 < outLen; i2++) {
        output.words[i2] = input.words[i2];
      }
      output.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output.words[output.length++] = prev & mask;
      for (i2 = 10; i2 < input.length; i2++) {
        var next = input.words[i2] | 0;
        input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i2 - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i2 = 0; i2 < num.length; i2++) {
        var w2 = num.words[i2] | 0;
        lo += w2 * 977;
        num.words[i2] = lo & 67108863;
        lo = w2 * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits2(P224, MPrime);
    function P192() {
      MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits2(P192, MPrime);
    function P25519() {
      MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits2(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i2 = 0; i2 < num.length; i2++) {
        var hi = (num.words[i2] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i2] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN2._prime = function prime(name) {
      if (primes[name])
        return primes[name];
      var prime2;
      if (name === "k256") {
        prime2 = new K256();
      } else if (name === "p224") {
        prime2 = new P224();
      } else if (name === "p192") {
        prime2 = new P192();
      } else if (name === "p25519") {
        prime2 = new P25519();
      } else {
        throw new Error("Unknown prime " + name);
      }
      primes[name] = prime2;
      return prime2;
    };
    function Red(m2) {
      if (typeof m2 === "string") {
        var prime = BN2._prime(m2);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert2(m2.gtn(1), "modulus must be greater than 1");
        this.m = m2;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a2) {
      assert2(a2.negative === 0, "red works only with positives");
      assert2(a2.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a2, b2) {
      assert2((a2.negative | b2.negative) === 0, "red works only with positives");
      assert2(a2.red && a2.red === b2.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a2) {
      if (this.prime)
        return this.prime.ireduce(a2)._forceRed(this);
      return a2.umod(this.m)._forceRed(this);
    };
    Red.prototype.neg = function neg3(a2) {
      if (a2.isZero()) {
        return a2.clone();
      }
      return this.m.sub(a2)._forceRed(this);
    };
    Red.prototype.add = function add4(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.add(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.iadd(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.sub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.isub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a2, num) {
      this._verify1(a2);
      return this.imod(a2.ushln(num));
    };
    Red.prototype.imul = function imul(a2, b2) {
      this._verify2(a2, b2);
      return this.imod(a2.imul(b2));
    };
    Red.prototype.mul = function mul4(a2, b2) {
      this._verify2(a2, b2);
      return this.imod(a2.mul(b2));
    };
    Red.prototype.isqr = function isqr(a2) {
      return this.imul(a2, a2.clone());
    };
    Red.prototype.sqr = function sqr(a2) {
      return this.mul(a2, a2);
    };
    Red.prototype.sqrt = function sqrt(a2) {
      if (a2.isZero())
        return a2.clone();
      var mod3 = this.m.andln(3);
      assert2(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN2(1)).iushrn(2);
        return this.pow(a2, pow);
      }
      var q2 = this.m.subn(1);
      var s2 = 0;
      while (!q2.isZero() && q2.andln(1) === 0) {
        s2++;
        q2.iushrn(1);
      }
      assert2(!q2.isZero());
      var one = new BN2(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z2 = this.m.bitLength();
      z2 = new BN2(2 * z2 * z2).toRed(this);
      while (this.pow(z2, lpow).cmp(nOne) !== 0) {
        z2.redIAdd(nOne);
      }
      var c2 = this.pow(z2, q2);
      var r2 = this.pow(a2, q2.addn(1).iushrn(1));
      var t2 = this.pow(a2, q2);
      var m2 = s2;
      while (t2.cmp(one) !== 0) {
        var tmp = t2;
        for (var i2 = 0; tmp.cmp(one) !== 0; i2++) {
          tmp = tmp.redSqr();
        }
        assert2(i2 < m2);
        var b2 = this.pow(c2, new BN2(1).iushln(m2 - i2 - 1));
        r2 = r2.redMul(b2);
        c2 = b2.redSqr();
        t2 = t2.redMul(c2);
        m2 = i2;
      }
      return r2;
    };
    Red.prototype.invm = function invm(a2) {
      var inv = a2._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a2, num) {
      if (num.isZero())
        return new BN2(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a2.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN2(1).toRed(this);
      wnd[1] = a2;
      for (var i2 = 2; i2 < wnd.length; i2++) {
        wnd[i2] = this.mul(wnd[i2 - 1], a2);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i2 = num.length - 1; i2 >= 0; i2--) {
        var word = num.words[i2];
        for (var j2 = start - 1; j2 >= 0; j2--) {
          var bit = word >> j2 & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i2 !== 0 || j2 !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r2 = num.umod(this.m);
      return r2 === num ? r2.clone() : r2;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN2.mont = function mont(num) {
      return new Mont(num);
    };
    function Mont(m2) {
      Red.call(this, m2);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN2(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits2(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r2 = this.imod(num.mul(this.rinv));
      r2.red = null;
      return r2;
    };
    Mont.prototype.imul = function imul(a2, b2) {
      if (a2.isZero() || b2.isZero()) {
        a2.words[0] = 0;
        a2.length = 1;
        return a2;
      }
      var t2 = a2.imul(b2);
      var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c2).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul4(a2, b2) {
      if (a2.isZero() || b2.isZero())
        return new BN2(0)._forceRed(this);
      var t2 = a2.mul(b2);
      var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c2).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a2) {
      var res = this.imod(a2._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module, commonjsGlobal);
})(bn$1);
var BN$2 = bn$1.exports;
const version$i = "logger/5.5.0";
let _permanentCensorErrors = false;
let _censorErrors = false;
const LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels["default"];
let _globalLogger = null;
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function(LogLevel2) {
  LogLevel2["DEBUG"] = "DEBUG";
  LogLevel2["INFO"] = "INFO";
  LogLevel2["WARNING"] = "WARNING";
  LogLevel2["ERROR"] = "ERROR";
  LogLevel2["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode2["TIMEOUT"] = "TIMEOUT";
  ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
class Logger {
  constructor(version2) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version2,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger.levels.WARNING, args);
  }
  makeError(message, code2, params) {
    if (_censorErrors) {
      return this.makeError("censored error", code2, {});
    }
    if (!code2) {
      code2 = Logger.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key2) => {
      const value = params[key2];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value.length; i2++) {
            hex += HEX[value[i2] >> 4];
            hex += HEX[value[i2] & 15];
          }
          messageDetails.push(key2 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key2 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key2 + "=" + JSON.stringify(params[key2].toString()));
      }
    });
    messageDetails.push(`code=${code2}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code2;
    Object.keys(params).forEach(function(key2) {
      error[key2] = params[key2];
    });
    return error;
  }
  throwError(message, code2, params) {
    throw this.makeError(message, code2, params);
  }
  throwArgumentError(message, name, value) {
    return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
      argument: name,
      value
    });
  }
  assert(condition, message, code2, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code2, params);
  }
  assertArgument(condition, message, name, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name, value);
  }
  checkNormalize(message) {
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new Logger(version$i);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      Logger.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel = level;
  }
  static from(version2) {
    return new Logger(version2);
  }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;
const version$h = "bytes/5.5.0";
const logger$h = new Logger(version$h);
function isHexable(value) {
  return !!value.toHexString;
}
function addSlice(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike(value) {
  return isHexString$2(value) && !(value.length % 2) || isBytes(value);
}
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    const v2 = value[i2];
    if (!isInteger(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger$h.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString$2(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0x0" + hex.substring(2);
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger$h.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex.length; i2 += 2) {
      result.push(parseInt(hex.substring(i2, i2 + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger$h.throwArgumentError("invalid arrayify value", "value", value);
}
function concat(items) {
  const objects = items.map((item) => arrayify(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset2, object) => {
    result.set(object, offset2);
    return offset2 + object.length;
  }, 0);
  return addSlice(result);
}
function stripZeros(value) {
  let result = arrayify(value);
  if (result.length === 0) {
    return result;
  }
  let start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  if (start) {
    result = result.slice(start);
  }
  return result;
}
function zeroPad(value, length) {
  value = arrayify(value);
  if (value.length > length) {
    logger$h.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length);
  result.set(value, length - value.length);
  return addSlice(result);
}
function isHexString$2(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
const HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger$h.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString$2(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger$h.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes(value)) {
    let result = "0x";
    for (let i2 = 0; i2 < value.length; i2++) {
      let v2 = value[i2];
      result += HexCharacters[(v2 & 240) >> 4] + HexCharacters[v2 & 15];
    }
    return result;
  }
  return logger$h.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength(data2) {
  if (typeof data2 !== "string") {
    data2 = hexlify(data2);
  } else if (!isHexString$2(data2) || data2.length % 2) {
    return null;
  }
  return (data2.length - 2) / 2;
}
function hexDataSlice(data2, offset2, endOffset) {
  if (typeof data2 !== "string") {
    data2 = hexlify(data2);
  } else if (!isHexString$2(data2) || data2.length % 2) {
    logger$h.throwArgumentError("invalid hexData", "value", data2);
  }
  offset2 = 2 + 2 * offset2;
  if (endOffset != null) {
    return "0x" + data2.substring(offset2, 2 + 2 * endOffset);
  }
  return "0x" + data2.substring(offset2);
}
function hexConcat(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify(item).substring(2);
  });
  return result;
}
function hexValue(value) {
  const trimmed = hexStripZeros(hexlify(value, { hexPad: "left" }));
  if (trimmed === "0x") {
    return "0x0";
  }
  return trimmed;
}
function hexStripZeros(value) {
  if (typeof value !== "string") {
    value = hexlify(value);
  }
  if (!isHexString$2(value)) {
    logger$h.throwArgumentError("invalid hex string", "value", value);
  }
  value = value.substring(2);
  let offset2 = 0;
  while (offset2 < value.length && value[offset2] === "0") {
    offset2++;
  }
  return "0x" + value.substring(offset2);
}
function hexZeroPad(value, length) {
  if (typeof value !== "string") {
    value = hexlify(value);
  } else if (!isHexString$2(value)) {
    logger$h.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger$h.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature(signature2) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0
  };
  if (isBytesLike(signature2)) {
    const bytes = arrayify(signature2);
    if (bytes.length !== 65) {
      logger$h.throwArgumentError("invalid signature string; must be 65 bytes", "signature", signature2);
    }
    result.r = hexlify(bytes.slice(0, 32));
    result.s = hexlify(bytes.slice(32, 64));
    result.v = bytes[64];
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger$h.throwArgumentError("signature invalid v byte", "signature", signature2);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes[32] |= 128;
    }
    result._vs = hexlify(bytes.slice(32, 64));
  } else {
    result.r = signature2.r;
    result.s = signature2.s;
    result.v = signature2.v;
    result.recoveryParam = signature2.recoveryParam;
    result._vs = signature2._vs;
    if (result._vs != null) {
      const vs2 = zeroPad(arrayify(result._vs), 32);
      result._vs = hexlify(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger$h.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature2);
      }
      vs2[0] &= 127;
      const s2 = hexlify(vs2);
      if (result.s == null) {
        result.s = s2;
      } else if (result.s !== s2) {
        logger$h.throwArgumentError("signature v mismatch _vs", "signature", signature2);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger$h.throwArgumentError("signature missing v and recoveryParam", "signature", signature2);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger$h.throwArgumentError("signature recoveryParam mismatch v", "signature", signature2);
        }
      }
    }
    if (result.r == null || !isHexString$2(result.r)) {
      logger$h.throwArgumentError("signature missing or invalid r", "signature", signature2);
    } else {
      result.r = hexZeroPad(result.r, 32);
    }
    if (result.s == null || !isHexString$2(result.s)) {
      logger$h.throwArgumentError("signature missing or invalid s", "signature", signature2);
    } else {
      result.s = hexZeroPad(result.s, 32);
    }
    const vs = arrayify(result.s);
    if (vs[0] >= 128) {
      logger$h.throwArgumentError("signature s out of range", "signature", signature2);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify(vs);
    if (result._vs) {
      if (!isHexString$2(result._vs)) {
        logger$h.throwArgumentError("signature invalid _vs", "signature", signature2);
      }
      result._vs = hexZeroPad(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger$h.throwArgumentError("signature _vs mismatch v and s", "signature", signature2);
    }
  }
  return result;
}
const version$g = "bignumber/5.5.0";
var BN$1 = BN$2.BN;
const logger$g = new Logger(version$g);
const _constructorGuard$1 = {};
const MAX_SAFE = 9007199254740991;
let _warnedToStringRadix = false;
class BigNumber {
  constructor(constructorGuard, hex) {
    logger$g.checkNew(new.target, BigNumber);
    if (constructorGuard !== _constructorGuard$1) {
      logger$g.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber(toBN(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber(toBN(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber(toBN(this).add(toBN(other)));
  }
  sub(other) {
    return toBigNumber(toBN(this).sub(toBN(other)));
  }
  div(other) {
    const o2 = BigNumber.from(other);
    if (o2.isZero()) {
      throwFault("division by zero", "div");
    }
    return toBigNumber(toBN(this).div(toBN(other)));
  }
  mul(other) {
    return toBigNumber(toBN(this).mul(toBN(other)));
  }
  mod(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault("cannot modulo negative values", "mod");
    }
    return toBigNumber(toBN(this).umod(value));
  }
  pow(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault("cannot raise to negative values", "pow");
    }
    return toBigNumber(toBN(this).pow(value));
  }
  and(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("cannot 'and' negative values", "and");
    }
    return toBigNumber(toBN(this).and(value));
  }
  or(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("cannot 'or' negative values", "or");
    }
    return toBigNumber(toBN(this).or(value));
  }
  xor(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("cannot 'xor' negative values", "xor");
    }
    return toBigNumber(toBN(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault("cannot mask negative values", "mask");
    }
    return toBigNumber(toBN(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault("cannot shift negative values", "shl");
    }
    return toBigNumber(toBN(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault("cannot shift negative values", "shr");
    }
    return toBigNumber(toBN(this).shrn(value));
  }
  eq(other) {
    return toBN(this).eq(toBN(other));
  }
  lt(other) {
    return toBN(this).lt(toBN(other));
  }
  lte(other) {
    return toBN(this).lte(toBN(other));
  }
  gt(other) {
    return toBN(this).gt(toBN(other));
  }
  gte(other) {
    return toBN(this).gte(toBN(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN(this).isZero();
  }
  toNumber() {
    try {
      return toBN(this).toNumber();
    } catch (error) {
      throwFault("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e2) {
    }
    return logger$g.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix) {
          _warnedToStringRadix = true;
          logger$g.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger$g.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger$g.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key2) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber(_constructorGuard$1, toHex$2(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber(_constructorGuard$1, toHex$2(new BN$1(value)));
      }
      return logger$g.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE || value <= -MAX_SAFE) {
        throwFault("overflow", "BigNumber.from", value);
      }
      return BigNumber.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber.from(anyValue.toString());
    }
    if (isBytes(anyValue)) {
      return BigNumber.from(hexlify(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString$2(hex) || hex[0] === "-" && isHexString$2(hex.substring(1))) {
            return BigNumber.from(hex);
          }
        }
      }
    }
    return logger$g.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
}
function toHex$2(value) {
  if (typeof value !== "string") {
    return toHex$2(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger$g.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex$2(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber(value) {
  return BigNumber.from(toHex$2(value));
}
function toBN(value) {
  const hex = BigNumber.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN$1("-" + hex.substring(3), 16);
  }
  return new BN$1(hex.substring(2), 16);
}
function throwFault(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger$g.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}
function _base36To16(value) {
  return new BN$1(value, 36).toString(16);
}
const version$f = "properties/5.5.0";
var __awaiter$7 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$f = new Logger(version$f);
function defineReadOnly(object, name, value) {
  Object.defineProperty(object, name, {
    enumerable: true,
    value,
    writable: false
  });
}
function getStatic(ctor, key2) {
  for (let i2 = 0; i2 < 32; i2++) {
    if (ctor[key2]) {
      return ctor[key2];
    }
    if (!ctor.prototype || typeof ctor.prototype !== "object") {
      break;
    }
    ctor = Object.getPrototypeOf(ctor.prototype).constructor;
  }
  return null;
}
function resolveProperties(object) {
  return __awaiter$7(this, void 0, void 0, function* () {
    const promises = Object.keys(object).map((key2) => {
      const value = object[key2];
      return Promise.resolve(value).then((v2) => ({ key: key2, value: v2 }));
    });
    const results = yield Promise.all(promises);
    return results.reduce((accum, result) => {
      accum[result.key] = result.value;
      return accum;
    }, {});
  });
}
function checkProperties(object, properties) {
  if (!object || typeof object !== "object") {
    logger$f.throwArgumentError("invalid object", "object", object);
  }
  Object.keys(object).forEach((key2) => {
    if (!properties[key2]) {
      logger$f.throwArgumentError("invalid object key - " + key2, "transaction:" + key2, object);
    }
  });
}
function shallowCopy(object) {
  const result = {};
  for (const key2 in object) {
    result[key2] = object[key2];
  }
  return result;
}
const opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen(object) {
  if (object === void 0 || object === null || opaque[typeof object]) {
    return true;
  }
  if (Array.isArray(object) || typeof object === "object") {
    if (!Object.isFrozen(object)) {
      return false;
    }
    const keys = Object.keys(object);
    for (let i2 = 0; i2 < keys.length; i2++) {
      let value = null;
      try {
        value = object[keys[i2]];
      } catch (error) {
        continue;
      }
      if (!_isFrozen(value)) {
        return false;
      }
    }
    return true;
  }
  return logger$f.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function _deepCopy(object) {
  if (_isFrozen(object)) {
    return object;
  }
  if (Array.isArray(object)) {
    return Object.freeze(object.map((item) => deepCopy(item)));
  }
  if (typeof object === "object") {
    const result = {};
    for (const key2 in object) {
      const value = object[key2];
      if (value === void 0) {
        continue;
      }
      defineReadOnly(result, key2, deepCopy(value));
    }
    return result;
  }
  return logger$f.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function deepCopy(object) {
  return _deepCopy(object);
}
class Description {
  constructor(info) {
    for (const key2 in info) {
      this[key2] = deepCopy(info[key2]);
    }
  }
}
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof globalThis.setTimeout === "function") {
  cachedSetTimeout = setTimeout;
}
if (typeof globalThis.clearTimeout === "function") {
  cachedClearTimeout = clearTimeout;
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e2) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e3) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e2) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e3) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue$1 = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue$1 = currentQueue.concat(queue$1);
  } else {
    queueIndex = -1;
  }
  if (queue$1.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue$1.length;
  while (len) {
    currentQueue = queue$1;
    queue$1 = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue$1.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function nextTick$1(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      args[i2 - 1] = arguments[i2];
    }
  }
  queue$1.push(new Item(fun, args));
  if (queue$1.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var title = "browser";
var platform$1 = "browser";
var browser$2 = true;
var env$1 = {};
var argv = [];
var version$e = "";
var versions = {};
var release = {};
var config$1 = {};
function noop() {
}
var on = noop;
var addListener = noop;
var once$1 = noop;
var off = noop;
var removeListener = noop;
var removeAllListeners = noop;
var emit = noop;
function binding(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
var performance$1 = globalThis.performance || {};
var performanceNow = performance$1.now || performance$1.mozNow || performance$1.msNow || performance$1.oNow || performance$1.webkitNow || function() {
  return new Date().getTime();
};
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance$1) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
var startTime = new Date();
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var browser$1$1 = {
  nextTick: nextTick$1,
  title,
  browser: browser$2,
  env: env$1,
  argv,
  version: version$e,
  versions,
  on,
  addListener,
  once: once$1,
  off,
  removeListener,
  removeAllListeners,
  emit,
  binding,
  cwd,
  chdir,
  umask,
  hrtime,
  platform: platform$1,
  release,
  config: config$1,
  uptime
};
var sha3$1 = { exports: {} };
(function(module) {
  (function() {
    var INPUT_ERROR = "input is invalid type";
    var FINALIZE_ERROR = "finalize already called";
    var WINDOW = typeof window === "object";
    var root = WINDOW ? window : {};
    if (root.JS_SHA3_NO_WINDOW) {
      WINDOW = false;
    }
    var WEB_WORKER = !WINDOW && typeof self === "object";
    var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof browser$1$1 === "object" && browser$1$1.versions && browser$1$1.versions.node;
    if (NODE_JS) {
      root = globalThis;
    } else if (WEB_WORKER) {
      root = self;
    }
    var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && true && module.exports;
    var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
    var HEX_CHARS = "0123456789abcdef".split("");
    var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
    var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
    var KECCAK_PADDING = [1, 256, 65536, 16777216];
    var PADDING = [6, 1536, 393216, 100663296];
    var SHIFT = [0, 8, 16, 24];
    var RC = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ];
    var BITS = [224, 256, 384, 512];
    var SHAKE_BITS = [128, 256];
    var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
    var CSHAKE_BYTEPAD = {
      "128": 168,
      "256": 136
    };
    if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
      Array.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
    }
    if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
      ArrayBuffer.isView = function(obj) {
        return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      };
    }
    var createOutputMethod = function(bits2, padding2, outputType) {
      return function(message) {
        return new Keccak(bits2, padding2, bits2).update(message)[outputType]();
      };
    };
    var createShakeOutputMethod = function(bits2, padding2, outputType) {
      return function(message, outputBits) {
        return new Keccak(bits2, padding2, outputBits).update(message)[outputType]();
      };
    };
    var createCshakeOutputMethod = function(bits2, padding2, outputType) {
      return function(message, outputBits, n2, s2) {
        return methods["cshake" + bits2].update(message, outputBits, n2, s2)[outputType]();
      };
    };
    var createKmacOutputMethod = function(bits2, padding2, outputType) {
      return function(key2, message, outputBits, s2) {
        return methods["kmac" + bits2].update(key2, message, outputBits, s2)[outputType]();
      };
    };
    var createOutputMethods = function(method, createMethod2, bits2, padding2) {
      for (var i3 = 0; i3 < OUTPUT_TYPES.length; ++i3) {
        var type = OUTPUT_TYPES[i3];
        method[type] = createMethod2(bits2, padding2, type);
      }
      return method;
    };
    var createMethod = function(bits2, padding2) {
      var method = createOutputMethod(bits2, padding2, "hex");
      method.create = function() {
        return new Keccak(bits2, padding2, bits2);
      };
      method.update = function(message) {
        return method.create().update(message);
      };
      return createOutputMethods(method, createOutputMethod, bits2, padding2);
    };
    var createShakeMethod = function(bits2, padding2) {
      var method = createShakeOutputMethod(bits2, padding2, "hex");
      method.create = function(outputBits) {
        return new Keccak(bits2, padding2, outputBits);
      };
      method.update = function(message, outputBits) {
        return method.create(outputBits).update(message);
      };
      return createOutputMethods(method, createShakeOutputMethod, bits2, padding2);
    };
    var createCshakeMethod = function(bits2, padding2) {
      var w2 = CSHAKE_BYTEPAD[bits2];
      var method = createCshakeOutputMethod(bits2, padding2, "hex");
      method.create = function(outputBits, n2, s2) {
        if (!n2 && !s2) {
          return methods["shake" + bits2].create(outputBits);
        } else {
          return new Keccak(bits2, padding2, outputBits).bytepad([n2, s2], w2);
        }
      };
      method.update = function(message, outputBits, n2, s2) {
        return method.create(outputBits, n2, s2).update(message);
      };
      return createOutputMethods(method, createCshakeOutputMethod, bits2, padding2);
    };
    var createKmacMethod = function(bits2, padding2) {
      var w2 = CSHAKE_BYTEPAD[bits2];
      var method = createKmacOutputMethod(bits2, padding2, "hex");
      method.create = function(key2, outputBits, s2) {
        return new Kmac(bits2, padding2, outputBits).bytepad(["KMAC", s2], w2).bytepad([key2], w2);
      };
      method.update = function(key2, message, outputBits, s2) {
        return method.create(key2, outputBits, s2).update(message);
      };
      return createOutputMethods(method, createKmacOutputMethod, bits2, padding2);
    };
    var algorithms = [
      { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
      { name: "sha3", padding: PADDING, bits: BITS, createMethod },
      { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
      { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
      { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
    ];
    var methods = {}, methodNames = [];
    for (var i2 = 0; i2 < algorithms.length; ++i2) {
      var algorithm = algorithms[i2];
      var bits = algorithm.bits;
      for (var j2 = 0; j2 < bits.length; ++j2) {
        var methodName = algorithm.name + "_" + bits[j2];
        methodNames.push(methodName);
        methods[methodName] = algorithm.createMethod(bits[j2], algorithm.padding);
        if (algorithm.name !== "sha3") {
          var newMethodName = algorithm.name + bits[j2];
          methodNames.push(newMethodName);
          methods[newMethodName] = methods[methodName];
        }
      }
    }
    function Keccak(bits2, padding2, outputBits) {
      this.blocks = [];
      this.s = [];
      this.padding = padding2;
      this.outputBits = outputBits;
      this.reset = true;
      this.finalized = false;
      this.block = 0;
      this.start = 0;
      this.blockCount = 1600 - (bits2 << 1) >> 5;
      this.byteCount = this.blockCount << 2;
      this.outputBlocks = outputBits >> 5;
      this.extraBytes = (outputBits & 31) >> 3;
      for (var i3 = 0; i3 < 50; ++i3) {
        this.s[i3] = 0;
      }
    }
    Keccak.prototype.update = function(message) {
      if (this.finalized) {
        throw new Error(FINALIZE_ERROR);
      }
      var notString, type = typeof message;
      if (type !== "string") {
        if (type === "object") {
          if (message === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index2 = 0, s2 = this.s, i3, code2;
      while (index2 < length) {
        if (this.reset) {
          this.reset = false;
          blocks[0] = this.block;
          for (i3 = 1; i3 < blockCount + 1; ++i3) {
            blocks[i3] = 0;
          }
        }
        if (notString) {
          for (i3 = this.start; index2 < length && i3 < byteCount; ++index2) {
            blocks[i3 >> 2] |= message[index2] << SHIFT[i3++ & 3];
          }
        } else {
          for (i3 = this.start; index2 < length && i3 < byteCount; ++index2) {
            code2 = message.charCodeAt(index2);
            if (code2 < 128) {
              blocks[i3 >> 2] |= code2 << SHIFT[i3++ & 3];
            } else if (code2 < 2048) {
              blocks[i3 >> 2] |= (192 | code2 >> 6) << SHIFT[i3++ & 3];
              blocks[i3 >> 2] |= (128 | code2 & 63) << SHIFT[i3++ & 3];
            } else if (code2 < 55296 || code2 >= 57344) {
              blocks[i3 >> 2] |= (224 | code2 >> 12) << SHIFT[i3++ & 3];
              blocks[i3 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i3++ & 3];
              blocks[i3 >> 2] |= (128 | code2 & 63) << SHIFT[i3++ & 3];
            } else {
              code2 = 65536 + ((code2 & 1023) << 10 | message.charCodeAt(++index2) & 1023);
              blocks[i3 >> 2] |= (240 | code2 >> 18) << SHIFT[i3++ & 3];
              blocks[i3 >> 2] |= (128 | code2 >> 12 & 63) << SHIFT[i3++ & 3];
              blocks[i3 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i3++ & 3];
              blocks[i3 >> 2] |= (128 | code2 & 63) << SHIFT[i3++ & 3];
            }
          }
        }
        this.lastByteIndex = i3;
        if (i3 >= byteCount) {
          this.start = i3 - byteCount;
          this.block = blocks[blockCount];
          for (i3 = 0; i3 < blockCount; ++i3) {
            s2[i3] ^= blocks[i3];
          }
          f2(s2);
          this.reset = true;
        } else {
          this.start = i3;
        }
      }
      return this;
    };
    Keccak.prototype.encode = function(x2, right) {
      var o2 = x2 & 255, n2 = 1;
      var bytes = [o2];
      x2 = x2 >> 8;
      o2 = x2 & 255;
      while (o2 > 0) {
        bytes.unshift(o2);
        x2 = x2 >> 8;
        o2 = x2 & 255;
        ++n2;
      }
      if (right) {
        bytes.push(n2);
      } else {
        bytes.unshift(n2);
      }
      this.update(bytes);
      return bytes.length;
    };
    Keccak.prototype.encodeString = function(str) {
      var notString, type = typeof str;
      if (type !== "string") {
        if (type === "object") {
          if (str === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
            str = new Uint8Array(str);
          } else if (!Array.isArray(str)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var bytes = 0, length = str.length;
      if (notString) {
        bytes = length;
      } else {
        for (var i3 = 0; i3 < str.length; ++i3) {
          var code2 = str.charCodeAt(i3);
          if (code2 < 128) {
            bytes += 1;
          } else if (code2 < 2048) {
            bytes += 2;
          } else if (code2 < 55296 || code2 >= 57344) {
            bytes += 3;
          } else {
            code2 = 65536 + ((code2 & 1023) << 10 | str.charCodeAt(++i3) & 1023);
            bytes += 4;
          }
        }
      }
      bytes += this.encode(bytes * 8);
      this.update(str);
      return bytes;
    };
    Keccak.prototype.bytepad = function(strs, w2) {
      var bytes = this.encode(w2);
      for (var i3 = 0; i3 < strs.length; ++i3) {
        bytes += this.encodeString(strs[i3]);
      }
      var paddingBytes = w2 - bytes % w2;
      var zeros = [];
      zeros.length = paddingBytes;
      this.update(zeros);
      return this;
    };
    Keccak.prototype.finalize = function() {
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      var blocks = this.blocks, i3 = this.lastByteIndex, blockCount = this.blockCount, s2 = this.s;
      blocks[i3 >> 2] |= this.padding[i3 & 3];
      if (this.lastByteIndex === this.byteCount) {
        blocks[0] = blocks[blockCount];
        for (i3 = 1; i3 < blockCount + 1; ++i3) {
          blocks[i3] = 0;
        }
      }
      blocks[blockCount - 1] |= 2147483648;
      for (i3 = 0; i3 < blockCount; ++i3) {
        s2[i3] ^= blocks[i3];
      }
      f2(s2);
    };
    Keccak.prototype.toString = Keccak.prototype.hex = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j3 = 0;
      var hex = "", block;
      while (j3 < outputBlocks) {
        for (i3 = 0; i3 < blockCount && j3 < outputBlocks; ++i3, ++j3) {
          block = s2[i3];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
        }
        if (j3 % blockCount === 0) {
          f2(s2);
          i3 = 0;
        }
      }
      if (extraBytes) {
        block = s2[i3];
        hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
        if (extraBytes > 1) {
          hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
        }
        if (extraBytes > 2) {
          hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
        }
      }
      return hex;
    };
    Keccak.prototype.arrayBuffer = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j3 = 0;
      var bytes = this.outputBits >> 3;
      var buffer2;
      if (extraBytes) {
        buffer2 = new ArrayBuffer(outputBlocks + 1 << 2);
      } else {
        buffer2 = new ArrayBuffer(bytes);
      }
      var array = new Uint32Array(buffer2);
      while (j3 < outputBlocks) {
        for (i3 = 0; i3 < blockCount && j3 < outputBlocks; ++i3, ++j3) {
          array[j3] = s2[i3];
        }
        if (j3 % blockCount === 0) {
          f2(s2);
        }
      }
      if (extraBytes) {
        array[i3] = s2[i3];
        buffer2 = buffer2.slice(0, bytes);
      }
      return buffer2;
    };
    Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
    Keccak.prototype.digest = Keccak.prototype.array = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j3 = 0;
      var array = [], offset2, block;
      while (j3 < outputBlocks) {
        for (i3 = 0; i3 < blockCount && j3 < outputBlocks; ++i3, ++j3) {
          offset2 = j3 << 2;
          block = s2[i3];
          array[offset2] = block & 255;
          array[offset2 + 1] = block >> 8 & 255;
          array[offset2 + 2] = block >> 16 & 255;
          array[offset2 + 3] = block >> 24 & 255;
        }
        if (j3 % blockCount === 0) {
          f2(s2);
        }
      }
      if (extraBytes) {
        offset2 = j3 << 2;
        block = s2[i3];
        array[offset2] = block & 255;
        if (extraBytes > 1) {
          array[offset2 + 1] = block >> 8 & 255;
        }
        if (extraBytes > 2) {
          array[offset2 + 2] = block >> 16 & 255;
        }
      }
      return array;
    };
    function Kmac(bits2, padding2, outputBits) {
      Keccak.call(this, bits2, padding2, outputBits);
    }
    Kmac.prototype = new Keccak();
    Kmac.prototype.finalize = function() {
      this.encode(this.outputBits, true);
      return Keccak.prototype.finalize.call(this);
    };
    var f2 = function(s2) {
      var h2, l2, n2, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
      for (n2 = 0; n2 < 48; n2 += 2) {
        c0 = s2[0] ^ s2[10] ^ s2[20] ^ s2[30] ^ s2[40];
        c1 = s2[1] ^ s2[11] ^ s2[21] ^ s2[31] ^ s2[41];
        c2 = s2[2] ^ s2[12] ^ s2[22] ^ s2[32] ^ s2[42];
        c3 = s2[3] ^ s2[13] ^ s2[23] ^ s2[33] ^ s2[43];
        c4 = s2[4] ^ s2[14] ^ s2[24] ^ s2[34] ^ s2[44];
        c5 = s2[5] ^ s2[15] ^ s2[25] ^ s2[35] ^ s2[45];
        c6 = s2[6] ^ s2[16] ^ s2[26] ^ s2[36] ^ s2[46];
        c7 = s2[7] ^ s2[17] ^ s2[27] ^ s2[37] ^ s2[47];
        c8 = s2[8] ^ s2[18] ^ s2[28] ^ s2[38] ^ s2[48];
        c9 = s2[9] ^ s2[19] ^ s2[29] ^ s2[39] ^ s2[49];
        h2 = c8 ^ (c2 << 1 | c3 >>> 31);
        l2 = c9 ^ (c3 << 1 | c2 >>> 31);
        s2[0] ^= h2;
        s2[1] ^= l2;
        s2[10] ^= h2;
        s2[11] ^= l2;
        s2[20] ^= h2;
        s2[21] ^= l2;
        s2[30] ^= h2;
        s2[31] ^= l2;
        s2[40] ^= h2;
        s2[41] ^= l2;
        h2 = c0 ^ (c4 << 1 | c5 >>> 31);
        l2 = c1 ^ (c5 << 1 | c4 >>> 31);
        s2[2] ^= h2;
        s2[3] ^= l2;
        s2[12] ^= h2;
        s2[13] ^= l2;
        s2[22] ^= h2;
        s2[23] ^= l2;
        s2[32] ^= h2;
        s2[33] ^= l2;
        s2[42] ^= h2;
        s2[43] ^= l2;
        h2 = c2 ^ (c6 << 1 | c7 >>> 31);
        l2 = c3 ^ (c7 << 1 | c6 >>> 31);
        s2[4] ^= h2;
        s2[5] ^= l2;
        s2[14] ^= h2;
        s2[15] ^= l2;
        s2[24] ^= h2;
        s2[25] ^= l2;
        s2[34] ^= h2;
        s2[35] ^= l2;
        s2[44] ^= h2;
        s2[45] ^= l2;
        h2 = c4 ^ (c8 << 1 | c9 >>> 31);
        l2 = c5 ^ (c9 << 1 | c8 >>> 31);
        s2[6] ^= h2;
        s2[7] ^= l2;
        s2[16] ^= h2;
        s2[17] ^= l2;
        s2[26] ^= h2;
        s2[27] ^= l2;
        s2[36] ^= h2;
        s2[37] ^= l2;
        s2[46] ^= h2;
        s2[47] ^= l2;
        h2 = c6 ^ (c0 << 1 | c1 >>> 31);
        l2 = c7 ^ (c1 << 1 | c0 >>> 31);
        s2[8] ^= h2;
        s2[9] ^= l2;
        s2[18] ^= h2;
        s2[19] ^= l2;
        s2[28] ^= h2;
        s2[29] ^= l2;
        s2[38] ^= h2;
        s2[39] ^= l2;
        s2[48] ^= h2;
        s2[49] ^= l2;
        b0 = s2[0];
        b1 = s2[1];
        b32 = s2[11] << 4 | s2[10] >>> 28;
        b33 = s2[10] << 4 | s2[11] >>> 28;
        b14 = s2[20] << 3 | s2[21] >>> 29;
        b15 = s2[21] << 3 | s2[20] >>> 29;
        b46 = s2[31] << 9 | s2[30] >>> 23;
        b47 = s2[30] << 9 | s2[31] >>> 23;
        b28 = s2[40] << 18 | s2[41] >>> 14;
        b29 = s2[41] << 18 | s2[40] >>> 14;
        b20 = s2[2] << 1 | s2[3] >>> 31;
        b21 = s2[3] << 1 | s2[2] >>> 31;
        b2 = s2[13] << 12 | s2[12] >>> 20;
        b3 = s2[12] << 12 | s2[13] >>> 20;
        b34 = s2[22] << 10 | s2[23] >>> 22;
        b35 = s2[23] << 10 | s2[22] >>> 22;
        b16 = s2[33] << 13 | s2[32] >>> 19;
        b17 = s2[32] << 13 | s2[33] >>> 19;
        b48 = s2[42] << 2 | s2[43] >>> 30;
        b49 = s2[43] << 2 | s2[42] >>> 30;
        b40 = s2[5] << 30 | s2[4] >>> 2;
        b41 = s2[4] << 30 | s2[5] >>> 2;
        b22 = s2[14] << 6 | s2[15] >>> 26;
        b23 = s2[15] << 6 | s2[14] >>> 26;
        b4 = s2[25] << 11 | s2[24] >>> 21;
        b5 = s2[24] << 11 | s2[25] >>> 21;
        b36 = s2[34] << 15 | s2[35] >>> 17;
        b37 = s2[35] << 15 | s2[34] >>> 17;
        b18 = s2[45] << 29 | s2[44] >>> 3;
        b19 = s2[44] << 29 | s2[45] >>> 3;
        b10 = s2[6] << 28 | s2[7] >>> 4;
        b11 = s2[7] << 28 | s2[6] >>> 4;
        b42 = s2[17] << 23 | s2[16] >>> 9;
        b43 = s2[16] << 23 | s2[17] >>> 9;
        b24 = s2[26] << 25 | s2[27] >>> 7;
        b25 = s2[27] << 25 | s2[26] >>> 7;
        b6 = s2[36] << 21 | s2[37] >>> 11;
        b7 = s2[37] << 21 | s2[36] >>> 11;
        b38 = s2[47] << 24 | s2[46] >>> 8;
        b39 = s2[46] << 24 | s2[47] >>> 8;
        b30 = s2[8] << 27 | s2[9] >>> 5;
        b31 = s2[9] << 27 | s2[8] >>> 5;
        b12 = s2[18] << 20 | s2[19] >>> 12;
        b13 = s2[19] << 20 | s2[18] >>> 12;
        b44 = s2[29] << 7 | s2[28] >>> 25;
        b45 = s2[28] << 7 | s2[29] >>> 25;
        b26 = s2[38] << 8 | s2[39] >>> 24;
        b27 = s2[39] << 8 | s2[38] >>> 24;
        b8 = s2[48] << 14 | s2[49] >>> 18;
        b9 = s2[49] << 14 | s2[48] >>> 18;
        s2[0] = b0 ^ ~b2 & b4;
        s2[1] = b1 ^ ~b3 & b5;
        s2[10] = b10 ^ ~b12 & b14;
        s2[11] = b11 ^ ~b13 & b15;
        s2[20] = b20 ^ ~b22 & b24;
        s2[21] = b21 ^ ~b23 & b25;
        s2[30] = b30 ^ ~b32 & b34;
        s2[31] = b31 ^ ~b33 & b35;
        s2[40] = b40 ^ ~b42 & b44;
        s2[41] = b41 ^ ~b43 & b45;
        s2[2] = b2 ^ ~b4 & b6;
        s2[3] = b3 ^ ~b5 & b7;
        s2[12] = b12 ^ ~b14 & b16;
        s2[13] = b13 ^ ~b15 & b17;
        s2[22] = b22 ^ ~b24 & b26;
        s2[23] = b23 ^ ~b25 & b27;
        s2[32] = b32 ^ ~b34 & b36;
        s2[33] = b33 ^ ~b35 & b37;
        s2[42] = b42 ^ ~b44 & b46;
        s2[43] = b43 ^ ~b45 & b47;
        s2[4] = b4 ^ ~b6 & b8;
        s2[5] = b5 ^ ~b7 & b9;
        s2[14] = b14 ^ ~b16 & b18;
        s2[15] = b15 ^ ~b17 & b19;
        s2[24] = b24 ^ ~b26 & b28;
        s2[25] = b25 ^ ~b27 & b29;
        s2[34] = b34 ^ ~b36 & b38;
        s2[35] = b35 ^ ~b37 & b39;
        s2[44] = b44 ^ ~b46 & b48;
        s2[45] = b45 ^ ~b47 & b49;
        s2[6] = b6 ^ ~b8 & b0;
        s2[7] = b7 ^ ~b9 & b1;
        s2[16] = b16 ^ ~b18 & b10;
        s2[17] = b17 ^ ~b19 & b11;
        s2[26] = b26 ^ ~b28 & b20;
        s2[27] = b27 ^ ~b29 & b21;
        s2[36] = b36 ^ ~b38 & b30;
        s2[37] = b37 ^ ~b39 & b31;
        s2[46] = b46 ^ ~b48 & b40;
        s2[47] = b47 ^ ~b49 & b41;
        s2[8] = b8 ^ ~b0 & b2;
        s2[9] = b9 ^ ~b1 & b3;
        s2[18] = b18 ^ ~b10 & b12;
        s2[19] = b19 ^ ~b11 & b13;
        s2[28] = b28 ^ ~b20 & b22;
        s2[29] = b29 ^ ~b21 & b23;
        s2[38] = b38 ^ ~b30 & b32;
        s2[39] = b39 ^ ~b31 & b33;
        s2[48] = b48 ^ ~b40 & b42;
        s2[49] = b49 ^ ~b41 & b43;
        s2[0] ^= RC[n2];
        s2[1] ^= RC[n2 + 1];
      }
    };
    if (COMMON_JS) {
      module.exports = methods;
    } else {
      for (i2 = 0; i2 < methodNames.length; ++i2) {
        root[methodNames[i2]] = methods[methodNames[i2]];
      }
    }
  })();
})(sha3$1);
var sha3 = sha3$1.exports;
function keccak256(data2) {
  return "0x" + sha3.keccak_256(arrayify(data2));
}
const version$d = "rlp/5.5.0";
const logger$e = new Logger(version$d);
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function unarrayifyInteger(data2, offset2, length) {
  let result = 0;
  for (let i2 = 0; i2 < length; i2++) {
    result = result * 256 + data2[offset2 + i2];
  }
  return result;
}
function _encode(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  if (!isBytesLike(object)) {
    logger$e.throwArgumentError("RLP object must be BytesLike", "object", object);
  }
  const data2 = Array.prototype.slice.call(arrayify(object));
  if (data2.length === 1 && data2[0] <= 127) {
    return data2;
  } else if (data2.length <= 55) {
    data2.unshift(128 + data2.length);
    return data2;
  }
  const length = arrayifyInteger(data2.length);
  length.unshift(183 + length.length);
  return length.concat(data2);
}
function encode$3(object) {
  return hexlify(_encode(object));
}
function _decodeChildren(data2, offset2, childOffset, length) {
  const result = [];
  while (childOffset < offset2 + 1 + length) {
    const decoded = _decode(data2, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset2 + 1 + length) {
      logger$e.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
  }
  return { consumed: 1 + length, result };
}
function _decode(data2, offset2) {
  if (data2.length === 0) {
    logger$e.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
  }
  if (data2[offset2] >= 248) {
    const lengthLength = data2[offset2] - 247;
    if (offset2 + 1 + lengthLength > data2.length) {
      logger$e.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data2, offset2 + 1, lengthLength);
    if (offset2 + 1 + lengthLength + length > data2.length) {
      logger$e.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data2, offset2, offset2 + 1 + lengthLength, lengthLength + length);
  } else if (data2[offset2] >= 192) {
    const length = data2[offset2] - 192;
    if (offset2 + 1 + length > data2.length) {
      logger$e.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data2, offset2, offset2 + 1, length);
  } else if (data2[offset2] >= 184) {
    const lengthLength = data2[offset2] - 183;
    if (offset2 + 1 + lengthLength > data2.length) {
      logger$e.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data2, offset2 + 1, lengthLength);
    if (offset2 + 1 + lengthLength + length > data2.length) {
      logger$e.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data2.slice(offset2 + 1 + lengthLength, offset2 + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data2[offset2] >= 128) {
    const length = data2[offset2] - 128;
    if (offset2 + 1 + length > data2.length) {
      logger$e.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data2.slice(offset2 + 1, offset2 + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlify(data2[offset2]) };
}
function decode$3(data2) {
  const bytes = arrayify(data2);
  const decoded = _decode(bytes, 0);
  if (decoded.consumed !== bytes.length) {
    logger$e.throwArgumentError("invalid rlp data", "data", data2);
  }
  return decoded.result;
}
const version$c = "address/5.5.0";
const logger$d = new Logger(version$c);
function getChecksumAddress(address) {
  if (!isHexString$2(address, 20)) {
    logger$d.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i2 = 0; i2 < 40; i2++) {
    expanded[i2] = chars[i2].charCodeAt(0);
  }
  const hashed = arrayify(keccak256(expanded));
  for (let i2 = 0; i2 < 40; i2 += 2) {
    if (hashed[i2 >> 1] >> 4 >= 8) {
      chars[i2] = chars[i2].toUpperCase();
    }
    if ((hashed[i2 >> 1] & 15) >= 8) {
      chars[i2 + 1] = chars[i2 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
const MAX_SAFE_INTEGER = 9007199254740991;
function log10(x2) {
  if (Math.log10) {
    return Math.log10(x2);
  }
  return Math.log(x2) / Math.LN10;
}
const ibanLookup = {};
for (let i2 = 0; i2 < 10; i2++) {
  ibanLookup[String(i2)] = String(i2);
}
for (let i2 = 0; i2 < 26; i2++) {
  ibanLookup[String.fromCharCode(65 + i2)] = String(10 + i2);
}
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c2) => {
    return ibanLookup[c2];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress(address) {
  let result = null;
  if (typeof address !== "string") {
    logger$d.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger$d.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger$d.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To16(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress("0x" + result);
  } else {
    logger$d.throwArgumentError("invalid address", "address", address);
  }
  return result;
}
function getContractAddress(transaction) {
  let from2 = null;
  try {
    from2 = getAddress(transaction.from);
  } catch (error) {
    logger$d.throwArgumentError("missing from address", "transaction", transaction);
  }
  const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));
  return getAddress(hexDataSlice(keccak256(encode$3([from2, nonce])), 12));
}
const AddressZero = "0x0000000000000000000000000000000000000000";
const Zero$1 = /* @__PURE__ */ BigNumber.from(0);
const HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
const version$b = "strings/5.5.0";
const logger$c = new Logger(version$b);
var UnicodeNormalizationForm;
(function(UnicodeNormalizationForm2) {
  UnicodeNormalizationForm2["current"] = "";
  UnicodeNormalizationForm2["NFC"] = "NFC";
  UnicodeNormalizationForm2["NFD"] = "NFD";
  UnicodeNormalizationForm2["NFKC"] = "NFKC";
  UnicodeNormalizationForm2["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(Utf8ErrorReason2) {
  Utf8ErrorReason2["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason2["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason2["OVERRUN"] = "string overrun";
  Utf8ErrorReason2["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason2["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason2["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason2["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset2, bytes, output, badCodepoint) {
  return logger$c.throwArgumentError(`invalid codepoint at offset ${offset2}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset2, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let i2 = 0;
    for (let o2 = offset2 + 1; o2 < bytes.length; o2++) {
      if (bytes[o2] >> 6 !== 2) {
        break;
      }
      i2++;
    }
    return i2;
  }
  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes.length - offset2 - 1;
  }
  return 0;
}
function replaceFunc(reason, offset2, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc(reason, offset2, bytes);
}
const Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  bytes = arrayify(bytes);
  const result = [];
  let i2 = 0;
  while (i2 < bytes.length) {
    const c2 = bytes[i2++];
    if (c2 >> 7 === 0) {
      result.push(c2);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c2 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c2 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c2 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c2 & 192) === 128) {
        i2 += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i2 - 1, bytes, result);
      } else {
        i2 += onError(Utf8ErrorReason.BAD_PREFIX, i2 - 1, bytes, result);
      }
      continue;
    }
    if (i2 - 1 + extraLength >= bytes.length) {
      i2 += onError(Utf8ErrorReason.OVERRUN, i2 - 1, bytes, result);
      continue;
    }
    let res = c2 & (1 << 8 - extraLength - 1) - 1;
    for (let j2 = 0; j2 < extraLength; j2++) {
      let nextChar = bytes[i2];
      if ((nextChar & 192) != 128) {
        i2 += onError(Utf8ErrorReason.MISSING_CONTINUE, i2, bytes, result);
        res = null;
        break;
      }
      res = res << 6 | nextChar & 63;
      i2++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i2 += onError(Utf8ErrorReason.OUT_OF_RANGE, i2 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i2 += onError(Utf8ErrorReason.UTF16_SURROGATE, i2 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i2 += onError(Utf8ErrorReason.OVERLONG, i2 - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
  if (form != UnicodeNormalizationForm.current) {
    logger$c.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i2 = 0; i2 < str.length; i2++) {
    const c2 = str.charCodeAt(i2);
    if (c2 < 128) {
      result.push(c2);
    } else if (c2 < 2048) {
      result.push(c2 >> 6 | 192);
      result.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i2++;
      const c22 = str.charCodeAt(i2);
      if (i2 >= str.length || (c22 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c2 >> 12 | 224);
      result.push(c2 >> 6 & 63 | 128);
      result.push(c2 & 63 | 128);
    }
  }
  return arrayify(result);
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}
function bytes2(data2) {
  if (data2.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i2 = 0; i2 < data2.length; i2 += 4) {
    result.push(parseInt(data2.substring(i2, i2 + 4), 16));
  }
  return result;
}
function createTable(data2, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data2.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable(data2) {
  let hi = 0;
  return data2.split(",").map((v2) => {
    let comps = v2.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
function matchMap(value, ranges) {
  let lo = 0;
  for (let i2 = 0; i2 < ranges.length; i2++) {
    let range = ranges[i2];
    lo += range.l;
    if (value >= lo && value <= lo + range.h && (value - lo) % (range.d || 1) === 0) {
      if (range.e && range.e.indexOf(value - lo) !== -1) {
        continue;
      }
      return range;
    }
  }
  return null;
}
const Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
const Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v2) => parseInt(v2, 16));
const Table_B_2_ranges = [
  { h: 25, s: 32, l: 65 },
  { h: 30, s: 32, e: [23], l: 127 },
  { h: 54, s: 1, e: [48], l: 64, d: 2 },
  { h: 14, s: 1, l: 57, d: 2 },
  { h: 44, s: 1, l: 17, d: 2 },
  { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
  { h: 16, s: 1, l: 68, d: 2 },
  { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
  { h: 26, s: 32, e: [17], l: 435 },
  { h: 22, s: 1, l: 71, d: 2 },
  { h: 15, s: 80, l: 40 },
  { h: 31, s: 32, l: 16 },
  { h: 32, s: 1, l: 80, d: 2 },
  { h: 52, s: 1, l: 42, d: 2 },
  { h: 12, s: 1, l: 55, d: 2 },
  { h: 40, s: 1, e: [38], l: 15, d: 2 },
  { h: 14, s: 1, l: 48, d: 2 },
  { h: 37, s: 48, l: 49 },
  { h: 148, s: 1, l: 6351, d: 2 },
  { h: 88, s: 1, l: 160, d: 2 },
  { h: 15, s: 16, l: 704 },
  { h: 25, s: 26, l: 854 },
  { h: 25, s: 32, l: 55915 },
  { h: 37, s: 40, l: 1247 },
  { h: 25, s: -119711, l: 53248 },
  { h: 25, s: -119763, l: 52 },
  { h: 25, s: -119815, l: 52 },
  { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
  { h: 25, s: -119919, l: 52 },
  { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
  { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
  { h: 25, s: -120075, l: 52 },
  { h: 25, s: -120127, l: 52 },
  { h: 25, s: -120179, l: 52 },
  { h: 25, s: -120231, l: 52 },
  { h: 25, s: -120283, l: 52 },
  { h: 25, s: -120335, l: 52 },
  { h: 24, s: -119543, e: [17], l: 56 },
  { h: 24, s: -119601, e: [17], l: 58 },
  { h: 24, s: -119659, e: [17], l: 58 },
  { h: 24, s: -119717, e: [17], l: 58 },
  { h: 24, s: -119775, e: [17], l: 58 }
];
const Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
const Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
const Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
const Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
function flatten(values) {
  return values.reduce((accum, value) => {
    value.forEach((value2) => {
      accum.push(value2);
    });
    return accum;
  }, []);
}
function _nameprepTableA1(codepoint) {
  return !!matchMap(codepoint, Table_A_1_ranges);
}
function _nameprepTableB2(codepoint) {
  let range = matchMap(codepoint, Table_B_2_ranges);
  if (range) {
    return [codepoint + range.s];
  }
  let codes = Table_B_2_lut_abs[codepoint];
  if (codes) {
    return codes;
  }
  let shift2 = Table_B_2_lut_rel[codepoint];
  if (shift2) {
    return [codepoint + shift2[0]];
  }
  let complex = Table_B_2_complex[codepoint];
  if (complex) {
    return complex;
  }
  return null;
}
function _nameprepTableC(codepoint) {
  return !!matchMap(codepoint, Table_C_ranges);
}
function nameprep(value) {
  if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
    return value.toLowerCase();
  }
  let codes = toUtf8CodePoints(value);
  codes = flatten(codes.map((code2) => {
    if (Table_B_1_flags.indexOf(code2) >= 0) {
      return [];
    }
    if (code2 >= 65024 && code2 <= 65039) {
      return [];
    }
    let codesTableB2 = _nameprepTableB2(code2);
    if (codesTableB2) {
      return codesTableB2;
    }
    return [code2];
  }));
  codes = toUtf8CodePoints(_toUtf8String(codes), UnicodeNormalizationForm.NFKC);
  codes.forEach((code2) => {
    if (_nameprepTableC(code2)) {
      throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
    }
  });
  codes.forEach((code2) => {
    if (_nameprepTableA1(code2)) {
      throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
    }
  });
  let name = _toUtf8String(codes);
  if (name.substring(0, 1) === "-" || name.substring(2, 4) === "--" || name.substring(name.length - 1) === "-") {
    throw new Error("invalid hyphen");
  }
  if (name.length > 63) {
    throw new Error("too long");
  }
  return name;
}
function id(text) {
  return keccak256(toUtf8Bytes(text));
}
const version$a = "hash/5.5.0";
const logger$b = new Logger(version$a);
const Zeros = new Uint8Array(32);
Zeros.fill(0);
const Partition = new RegExp("^((.*)\\.)?([^.]+)$");
function namehash(name) {
  if (typeof name !== "string") {
    logger$b.throwArgumentError("invalid ENS name; not a string", "name", name);
  }
  let current = name;
  let result = Zeros;
  while (current.length) {
    const partition = current.match(Partition);
    if (partition == null || partition[2] === "") {
      logger$b.throwArgumentError("invalid ENS address; missing component", "name", name);
    }
    const label = toUtf8Bytes(nameprep(partition[3]));
    result = keccak256(concat([result, keccak256(label)]));
    current = partition[2] || "";
  }
  return hexlify(result);
}
var __awaiter$6 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$a = new Logger(version$a);
const padding = new Uint8Array(32);
padding.fill(0);
const NegativeOne = BigNumber.from(-1);
const Zero = BigNumber.from(0);
const One = BigNumber.from(1);
const MaxUint256 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes = arrayify(value);
  const padOffset = bytes.length % 32;
  if (padOffset) {
    return hexConcat([bytes, padding.slice(padOffset)]);
  }
  return hexlify(bytes);
}
const hexTrue = hexZeroPad(One.toHexString(), 32);
const hexFalse = hexZeroPad(Zero.toHexString(), 32);
const domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
const domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(key2) {
  return function(value) {
    if (typeof value !== "string") {
      logger$a.throwArgumentError(`invalid domain value for ${JSON.stringify(key2)}`, `domain.${key2}`, value);
    }
    return value;
  };
}
const domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(value) {
    try {
      return BigNumber.from(value).toString();
    } catch (error) {
    }
    return logger$a.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error) {
    }
    return logger$a.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    try {
      const bytes = arrayify(value);
      if (bytes.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify(bytes);
    } catch (error) {
    }
    return logger$a.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};
function getBaseEncoder(type) {
  {
    const match = type.match(/^(u?)int(\d*)$/);
    if (match) {
      const signed = match[1] === "";
      const width = parseInt(match[2] || "256");
      if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
        logger$a.throwArgumentError("invalid numeric width", "type", type);
      }
      const boundsUpper = MaxUint256.mask(signed ? width - 1 : width);
      const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;
      return function(value) {
        const v2 = BigNumber.from(value);
        if (v2.lt(boundsLower) || v2.gt(boundsUpper)) {
          logger$a.throwArgumentError(`value out-of-bounds for ${type}`, "value", value);
        }
        return hexZeroPad(v2.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      if (width === 0 || width > 32 || match[1] !== String(width)) {
        logger$a.throwArgumentError("invalid bytes width", "type", type);
      }
      return function(value) {
        const bytes = arrayify(value);
        if (bytes.length !== width) {
          logger$a.throwArgumentError(`invalid length for ${type}`, "value", value);
        }
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return hexZeroPad(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
function encodeType(name, fields) {
  return `${name}(${fields.map(({ name: name2, type }) => type + " " + name2).join(",")})`;
}
class TypedDataEncoder {
  constructor(types) {
    defineReadOnly(this, "types", Object.freeze(deepCopy(types)));
    defineReadOnly(this, "_encoderCache", {});
    defineReadOnly(this, "_types", {});
    const links = {};
    const parents = {};
    const subtypes = {};
    Object.keys(types).forEach((type) => {
      links[type] = {};
      parents[type] = [];
      subtypes[type] = {};
    });
    for (const name in types) {
      const uniqueNames = {};
      types[name].forEach((field) => {
        if (uniqueNames[field.name]) {
          logger$a.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", types);
        }
        uniqueNames[field.name] = true;
        const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        if (baseType === name) {
          logger$a.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types);
        }
        const encoder = getBaseEncoder(baseType);
        if (encoder) {
          return;
        }
        if (!parents[baseType]) {
          logger$a.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types);
        }
        parents[baseType].push(name);
        links[name][baseType] = true;
      });
    }
    const primaryTypes = Object.keys(parents).filter((n2) => parents[n2].length === 0);
    if (primaryTypes.length === 0) {
      logger$a.throwArgumentError("missing primary type", "types", types);
    } else if (primaryTypes.length > 1) {
      logger$a.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t2) => JSON.stringify(t2)).join(", ")}`, "types", types);
    }
    defineReadOnly(this, "primaryType", primaryTypes[0]);
    function checkCircular(type, found) {
      if (found[type]) {
        logger$a.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, "types", types);
      }
      found[type] = true;
      Object.keys(links[type]).forEach((child) => {
        if (!parents[child]) {
          return;
        }
        checkCircular(child, found);
        Object.keys(found).forEach((subtype) => {
          subtypes[subtype][child] = true;
        });
      });
      delete found[type];
    }
    checkCircular(this.primaryType, {});
    for (const name in subtypes) {
      const st = Object.keys(subtypes[name]);
      st.sort();
      this._types[name] = encodeType(name, types[name]) + st.map((t2) => encodeType(t2, types[t2])).join("");
    }
  }
  getEncoder(type) {
    let encoder = this._encoderCache[type];
    if (!encoder) {
      encoder = this._encoderCache[type] = this._getEncoder(type);
    }
    return encoder;
  }
  _getEncoder(type) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return encoder;
      }
    }
    const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const subEncoder = this.getEncoder(subtype);
      const length = parseInt(match[3]);
      return (value) => {
        if (length >= 0 && value.length !== length) {
          logger$a.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
        }
        let result = value.map(subEncoder);
        if (this._types[subtype]) {
          result = result.map(keccak256);
        }
        return keccak256(hexConcat(result));
      };
    }
    const fields = this.types[type];
    if (fields) {
      const encodedType = id(this._types[type]);
      return (value) => {
        const values = fields.map(({ name, type: type2 }) => {
          const result = this.getEncoder(type2)(value[name]);
          if (this._types[type2]) {
            return keccak256(result);
          }
          return result;
        });
        values.unshift(encodedType);
        return hexConcat(values);
      };
    }
    return logger$a.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  encodeType(name) {
    const result = this._types[name];
    if (!result) {
      logger$a.throwArgumentError(`unknown type: ${JSON.stringify(name)}`, "name", name);
    }
    return result;
  }
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  hashStruct(name, value) {
    return keccak256(this.encodeData(name, value));
  }
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  _visit(type, value, callback) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return callback(type, value);
      }
    }
    const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const length = parseInt(match[3]);
      if (length >= 0 && value.length !== length) {
        logger$a.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
      }
      return value.map((v2) => this._visit(subtype, v2, callback));
    }
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, { name, type: type2 }) => {
        accum[name] = this._visit(type2, value[name], callback);
        return accum;
      }, {});
    }
    return logger$a.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  static from(types) {
    return new TypedDataEncoder(types);
  }
  static getPrimaryType(types) {
    return TypedDataEncoder.from(types).primaryType;
  }
  static hashStruct(name, types, value) {
    return TypedDataEncoder.from(types).hashStruct(name, value);
  }
  static hashDomain(domain2) {
    const domainFields = [];
    for (const name in domain2) {
      const type = domainFieldTypes[name];
      if (!type) {
        logger$a.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain2);
      }
      domainFields.push({ name, type });
    }
    domainFields.sort((a2, b2) => {
      return domainFieldNames.indexOf(a2.name) - domainFieldNames.indexOf(b2.name);
    });
    return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain2);
  }
  static encode(domain2, types, value) {
    return hexConcat([
      "0x1901",
      TypedDataEncoder.hashDomain(domain2),
      TypedDataEncoder.from(types).hash(value)
    ]);
  }
  static hash(domain2, types, value) {
    return keccak256(TypedDataEncoder.encode(domain2, types, value));
  }
  static resolveNames(domain2, types, value, resolveName) {
    return __awaiter$6(this, void 0, void 0, function* () {
      domain2 = shallowCopy(domain2);
      const ensCache = {};
      if (domain2.verifyingContract && !isHexString$2(domain2.verifyingContract, 20)) {
        ensCache[domain2.verifyingContract] = "0x";
      }
      const encoder = TypedDataEncoder.from(types);
      encoder.visit(value, (type, value2) => {
        if (type === "address" && !isHexString$2(value2, 20)) {
          ensCache[value2] = "0x";
        }
        return value2;
      });
      for (const name in ensCache) {
        ensCache[name] = yield resolveName(name);
      }
      if (domain2.verifyingContract && ensCache[domain2.verifyingContract]) {
        domain2.verifyingContract = ensCache[domain2.verifyingContract];
      }
      value = encoder.visit(value, (type, value2) => {
        if (type === "address" && ensCache[value2]) {
          return ensCache[value2];
        }
        return value2;
      });
      return { domain: domain2, value };
    });
  }
  static getPayload(domain2, types, value) {
    TypedDataEncoder.hashDomain(domain2);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name) => {
      const value2 = domain2[name];
      if (value2 == null) {
        return;
      }
      domainValues[name] = domainChecks[name](value2);
      domainTypes.push({ name, type: domainFieldTypes[name] });
    });
    const encoder = TypedDataEncoder.from(types);
    const typesWithDomain = shallowCopy(types);
    if (typesWithDomain.EIP712Domain) {
      logger$a.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
    } else {
      typesWithDomain.EIP712Domain = domainTypes;
    }
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type, value2) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify(arrayify(value2));
        }
        if (type.match(/^u?int/)) {
          return BigNumber.from(value2).toString();
        }
        switch (type) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            if (typeof value2 !== "string") {
              logger$a.throwArgumentError(`invalid string`, "value", value2);
            }
            return value2;
        }
        return logger$a.throwArgumentError("unsupported type", "type", type);
      })
    };
  }
}
const version$9 = "abstract-provider/5.5.1";
var __awaiter$5 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$9 = new Logger(version$9);
class ForkEvent extends Description {
  static isForkEvent(value) {
    return !!(value && value._isForkEvent);
  }
}
class Provider {
  constructor() {
    logger$9.checkAbstract(new.target, Provider);
    defineReadOnly(this, "_isProvider", true);
  }
  getFeeData() {
    return __awaiter$5(this, void 0, void 0, function* () {
      const { block, gasPrice } = yield resolveProperties({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((error) => {
          return null;
        })
      });
      let maxFeePerGas = null, maxPriorityFeePerGas = null;
      if (block && block.baseFeePerGas) {
        maxPriorityFeePerGas = BigNumber.from("2500000000");
        maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
      }
      return { maxFeePerGas, maxPriorityFeePerGas, gasPrice };
    });
  }
  addListener(eventName, listener) {
    return this.on(eventName, listener);
  }
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
  static isProvider(value) {
    return !!(value && value._isProvider);
  }
}
const version$8 = "abstract-signer/5.5.0";
var __awaiter$4 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$8 = new Logger(version$8);
const allowedTransactionKeys$1 = [
  "accessList",
  "chainId",
  "customData",
  "data",
  "from",
  "gasLimit",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "nonce",
  "to",
  "type",
  "value"
];
const forwardErrors = [
  Logger.errors.INSUFFICIENT_FUNDS,
  Logger.errors.NONCE_EXPIRED,
  Logger.errors.REPLACEMENT_UNDERPRICED
];
class Signer {
  constructor() {
    logger$8.checkAbstract(new.target, Signer);
    defineReadOnly(this, "_isSigner", true);
  }
  getBalance(blockTag) {
    return __awaiter$4(this, void 0, void 0, function* () {
      this._checkProvider("getBalance");
      return yield this.provider.getBalance(this.getAddress(), blockTag);
    });
  }
  getTransactionCount(blockTag) {
    return __awaiter$4(this, void 0, void 0, function* () {
      this._checkProvider("getTransactionCount");
      return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
    });
  }
  estimateGas(transaction) {
    return __awaiter$4(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.estimateGas(tx);
    });
  }
  call(transaction, blockTag) {
    return __awaiter$4(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.call(tx, blockTag);
    });
  }
  sendTransaction(transaction) {
    return __awaiter$4(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const tx = yield this.populateTransaction(transaction);
      const signedTx = yield this.signTransaction(tx);
      return yield this.provider.sendTransaction(signedTx);
    });
  }
  getChainId() {
    return __awaiter$4(this, void 0, void 0, function* () {
      this._checkProvider("getChainId");
      const network = yield this.provider.getNetwork();
      return network.chainId;
    });
  }
  getGasPrice() {
    return __awaiter$4(this, void 0, void 0, function* () {
      this._checkProvider("getGasPrice");
      return yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return __awaiter$4(this, void 0, void 0, function* () {
      this._checkProvider("getFeeData");
      return yield this.provider.getFeeData();
    });
  }
  resolveName(name) {
    return __awaiter$4(this, void 0, void 0, function* () {
      this._checkProvider("resolveName");
      return yield this.provider.resolveName(name);
    });
  }
  checkTransaction(transaction) {
    for (const key2 in transaction) {
      if (allowedTransactionKeys$1.indexOf(key2) === -1) {
        logger$8.throwArgumentError("invalid transaction key: " + key2, "transaction", transaction);
      }
    }
    const tx = shallowCopy(transaction);
    if (tx.from == null) {
      tx.from = this.getAddress();
    } else {
      tx.from = Promise.all([
        Promise.resolve(tx.from),
        this.getAddress()
      ]).then((result) => {
        if (result[0].toLowerCase() !== result[1].toLowerCase()) {
          logger$8.throwArgumentError("from address mismatch", "transaction", transaction);
        }
        return result[0];
      });
    }
    return tx;
  }
  populateTransaction(transaction) {
    return __awaiter$4(this, void 0, void 0, function* () {
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      if (tx.to != null) {
        tx.to = Promise.resolve(tx.to).then((to) => __awaiter$4(this, void 0, void 0, function* () {
          if (to == null) {
            return null;
          }
          const address = yield this.resolveName(to);
          if (address == null) {
            logger$8.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
          }
          return address;
        }));
        tx.to.catch((error) => {
        });
      }
      const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
      if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
        logger$8.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
      } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
        logger$8.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
      }
      if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
        tx.type = 2;
      } else if (tx.type === 0 || tx.type === 1) {
        if (tx.gasPrice == null) {
          tx.gasPrice = this.getGasPrice();
        }
      } else {
        const feeData = yield this.getFeeData();
        if (tx.type == null) {
          if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
            tx.type = 2;
            if (tx.gasPrice != null) {
              const gasPrice = tx.gasPrice;
              delete tx.gasPrice;
              tx.maxFeePerGas = gasPrice;
              tx.maxPriorityFeePerGas = gasPrice;
            } else {
              if (tx.maxFeePerGas == null) {
                tx.maxFeePerGas = feeData.maxFeePerGas;
              }
              if (tx.maxPriorityFeePerGas == null) {
                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
              }
            }
          } else if (feeData.gasPrice != null) {
            if (hasEip1559) {
              logger$8.throwError("network does not support EIP-1559", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "populateTransaction"
              });
            }
            if (tx.gasPrice == null) {
              tx.gasPrice = feeData.gasPrice;
            }
            tx.type = 0;
          } else {
            logger$8.throwError("failed to get consistent fee data", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
          }
        } else if (tx.type === 2) {
          if (tx.maxFeePerGas == null) {
            tx.maxFeePerGas = feeData.maxFeePerGas;
          }
          if (tx.maxPriorityFeePerGas == null) {
            tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
          }
        }
      }
      if (tx.nonce == null) {
        tx.nonce = this.getTransactionCount("pending");
      }
      if (tx.gasLimit == null) {
        tx.gasLimit = this.estimateGas(tx).catch((error) => {
          if (forwardErrors.indexOf(error.code) >= 0) {
            throw error;
          }
          return logger$8.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
            error,
            tx
          });
        });
      }
      if (tx.chainId == null) {
        tx.chainId = this.getChainId();
      } else {
        tx.chainId = Promise.all([
          Promise.resolve(tx.chainId),
          this.getChainId()
        ]).then((results) => {
          if (results[1] !== 0 && results[0] !== results[1]) {
            logger$8.throwArgumentError("chainId address mismatch", "transaction", transaction);
          }
          return results[0];
        });
      }
      return yield resolveProperties(tx);
    });
  }
  _checkProvider(operation) {
    if (!this.provider) {
      logger$8.throwError("missing provider", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: operation || "_checkProvider"
      });
    }
  }
  static isSigner(value) {
    return !!(value && value._isSigner);
  }
}
var hash$3 = {};
var utils$q = {};
var minimalisticAssert$1 = assert$b;
function assert$b(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert$b.equal = function assertEqual(l2, r2, msg) {
  if (l2 != r2)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
};
var inherits_browser$1 = { exports: {} };
if (typeof Object.create === "function") {
  inherits_browser$1.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  inherits_browser$1.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
var assert$a = minimalisticAssert$1;
var inherits = inherits_browser$1.exports;
utils$q.inherits = inherits;
function isSurrogatePair(msg, i2) {
  if ((msg.charCodeAt(i2) & 64512) !== 55296) {
    return false;
  }
  if (i2 < 0 || i2 + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i2 + 1) & 64512) === 56320;
}
function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === "string") {
    if (!enc) {
      var p2 = 0;
      for (var i2 = 0; i2 < msg.length; i2++) {
        var c2 = msg.charCodeAt(i2);
        if (c2 < 128) {
          res[p2++] = c2;
        } else if (c2 < 2048) {
          res[p2++] = c2 >> 6 | 192;
          res[p2++] = c2 & 63 | 128;
        } else if (isSurrogatePair(msg, i2)) {
          c2 = 65536 + ((c2 & 1023) << 10) + (msg.charCodeAt(++i2) & 1023);
          res[p2++] = c2 >> 18 | 240;
          res[p2++] = c2 >> 12 & 63 | 128;
          res[p2++] = c2 >> 6 & 63 | 128;
          res[p2++] = c2 & 63 | 128;
        } else {
          res[p2++] = c2 >> 12 | 224;
          res[p2++] = c2 >> 6 & 63 | 128;
          res[p2++] = c2 & 63 | 128;
        }
      }
    } else if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (i2 = 0; i2 < msg.length; i2 += 2)
        res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
    }
  } else {
    for (i2 = 0; i2 < msg.length; i2++)
      res[i2] = msg[i2] | 0;
  }
  return res;
}
utils$q.toArray = toArray;
function toHex$1(msg) {
  var res = "";
  for (var i2 = 0; i2 < msg.length; i2++)
    res += zero2(msg[i2].toString(16));
  return res;
}
utils$q.toHex = toHex$1;
function htonl(w2) {
  var res = w2 >>> 24 | w2 >>> 8 & 65280 | w2 << 8 & 16711680 | (w2 & 255) << 24;
  return res >>> 0;
}
utils$q.htonl = htonl;
function toHex32(msg, endian) {
  var res = "";
  for (var i2 = 0; i2 < msg.length; i2++) {
    var w2 = msg[i2];
    if (endian === "little")
      w2 = htonl(w2);
    res += zero8(w2.toString(16));
  }
  return res;
}
utils$q.toHex32 = toHex32;
function zero2(word) {
  if (word.length === 1)
    return "0" + word;
  else
    return word;
}
utils$q.zero2 = zero2;
function zero8(word) {
  if (word.length === 7)
    return "0" + word;
  else if (word.length === 6)
    return "00" + word;
  else if (word.length === 5)
    return "000" + word;
  else if (word.length === 4)
    return "0000" + word;
  else if (word.length === 3)
    return "00000" + word;
  else if (word.length === 2)
    return "000000" + word;
  else if (word.length === 1)
    return "0000000" + word;
  else
    return word;
}
utils$q.zero8 = zero8;
function join32(msg, start, end, endian) {
  var len = end - start;
  assert$a(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i2 = 0, k2 = start; i2 < res.length; i2++, k2 += 4) {
    var w2;
    if (endian === "big")
      w2 = msg[k2] << 24 | msg[k2 + 1] << 16 | msg[k2 + 2] << 8 | msg[k2 + 3];
    else
      w2 = msg[k2 + 3] << 24 | msg[k2 + 2] << 16 | msg[k2 + 1] << 8 | msg[k2];
    res[i2] = w2 >>> 0;
  }
  return res;
}
utils$q.join32 = join32;
function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i2 = 0, k2 = 0; i2 < msg.length; i2++, k2 += 4) {
    var m2 = msg[i2];
    if (endian === "big") {
      res[k2] = m2 >>> 24;
      res[k2 + 1] = m2 >>> 16 & 255;
      res[k2 + 2] = m2 >>> 8 & 255;
      res[k2 + 3] = m2 & 255;
    } else {
      res[k2 + 3] = m2 >>> 24;
      res[k2 + 2] = m2 >>> 16 & 255;
      res[k2 + 1] = m2 >>> 8 & 255;
      res[k2] = m2 & 255;
    }
  }
  return res;
}
utils$q.split32 = split32;
function rotr32$1(w2, b2) {
  return w2 >>> b2 | w2 << 32 - b2;
}
utils$q.rotr32 = rotr32$1;
function rotl32$2(w2, b2) {
  return w2 << b2 | w2 >>> 32 - b2;
}
utils$q.rotl32 = rotl32$2;
function sum32$3(a2, b2) {
  return a2 + b2 >>> 0;
}
utils$q.sum32 = sum32$3;
function sum32_3$1(a2, b2, c2) {
  return a2 + b2 + c2 >>> 0;
}
utils$q.sum32_3 = sum32_3$1;
function sum32_4$2(a2, b2, c2, d2) {
  return a2 + b2 + c2 + d2 >>> 0;
}
utils$q.sum32_4 = sum32_4$2;
function sum32_5$2(a2, b2, c2, d2, e2) {
  return a2 + b2 + c2 + d2 + e2 >>> 0;
}
utils$q.sum32_5 = sum32_5$2;
function sum64$1(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
utils$q.sum64 = sum64$1;
function sum64_hi$1(ah, al, bh, bl) {
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
utils$q.sum64_hi = sum64_hi$1;
function sum64_lo$1(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
utils$q.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
utils$q.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
utils$q.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = lo + el >>> 0;
  carry += lo < el ? 1 : 0;
  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
utils$q.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;
  return lo >>> 0;
}
utils$q.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(ah, al, num) {
  var r2 = al << 32 - num | ah >>> num;
  return r2 >>> 0;
}
utils$q.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(ah, al, num) {
  var r2 = ah << 32 - num | al >>> num;
  return r2 >>> 0;
}
utils$q.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(ah, al, num) {
  return ah >>> num;
}
utils$q.shr64_hi = shr64_hi$1;
function shr64_lo$1(ah, al, num) {
  var r2 = ah << 32 - num | al >>> num;
  return r2 >>> 0;
}
utils$q.shr64_lo = shr64_lo$1;
var common$5 = {};
var utils$p = utils$q;
var assert$9 = minimalisticAssert$1;
function BlockHash$4() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = "big";
  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function update(msg, enc) {
  msg = utils$p.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;
  if (this.pending.length >= this._delta8) {
    msg = this.pending;
    var r2 = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r2, msg.length);
    if (this.pending.length === 0)
      this.pending = null;
    msg = utils$p.join32(msg, 0, msg.length - r2, this.endian);
    for (var i2 = 0; i2 < msg.length; i2 += this._delta32)
      this._update(msg, i2, i2 + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert$9(this.pending === null);
  return this._digest(enc);
};
BlockHash$4.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k2 = bytes - (len + this.padLength) % bytes;
  var res = new Array(k2 + this.padLength);
  res[0] = 128;
  for (var i2 = 1; i2 < k2; i2++)
    res[i2] = 0;
  len <<= 3;
  if (this.endian === "big") {
    for (var t2 = 8; t2 < this.padLength; t2++)
      res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = len >>> 24 & 255;
    res[i2++] = len >>> 16 & 255;
    res[i2++] = len >>> 8 & 255;
    res[i2++] = len & 255;
  } else {
    res[i2++] = len & 255;
    res[i2++] = len >>> 8 & 255;
    res[i2++] = len >>> 16 & 255;
    res[i2++] = len >>> 24 & 255;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    for (t2 = 8; t2 < this.padLength; t2++)
      res[i2++] = 0;
  }
  return res;
};
var sha = {};
var common$4 = {};
var utils$o = utils$q;
var rotr32 = utils$o.rotr32;
function ft_1$1(s2, x2, y2, z2) {
  if (s2 === 0)
    return ch32$1(x2, y2, z2);
  if (s2 === 1 || s2 === 3)
    return p32(x2, y2, z2);
  if (s2 === 2)
    return maj32$1(x2, y2, z2);
}
common$4.ft_1 = ft_1$1;
function ch32$1(x2, y2, z2) {
  return x2 & y2 ^ ~x2 & z2;
}
common$4.ch32 = ch32$1;
function maj32$1(x2, y2, z2) {
  return x2 & y2 ^ x2 & z2 ^ y2 & z2;
}
common$4.maj32 = maj32$1;
function p32(x2, y2, z2) {
  return x2 ^ y2 ^ z2;
}
common$4.p32 = p32;
function s0_256$1(x2) {
  return rotr32(x2, 2) ^ rotr32(x2, 13) ^ rotr32(x2, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(x2) {
  return rotr32(x2, 6) ^ rotr32(x2, 11) ^ rotr32(x2, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(x2) {
  return rotr32(x2, 7) ^ rotr32(x2, 18) ^ x2 >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(x2) {
  return rotr32(x2, 17) ^ rotr32(x2, 19) ^ x2 >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$n = utils$q;
var common$3 = common$5;
var shaCommon$1 = common$4;
var rotl32$1 = utils$n.rotl32;
var sum32$2 = utils$n.sum32;
var sum32_5$1 = utils$n.sum32_5;
var ft_1 = shaCommon$1.ft_1;
var BlockHash$3 = common$3.BlockHash;
var sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this);
  this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ];
  this.W = new Array(80);
}
utils$n.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function _update(msg, start) {
  var W2 = this.W;
  for (var i2 = 0; i2 < 16; i2++)
    W2[i2] = msg[start + i2];
  for (; i2 < W2.length; i2++)
    W2[i2] = rotl32$1(W2[i2 - 3] ^ W2[i2 - 8] ^ W2[i2 - 14] ^ W2[i2 - 16], 1);
  var a2 = this.h[0];
  var b2 = this.h[1];
  var c2 = this.h[2];
  var d2 = this.h[3];
  var e2 = this.h[4];
  for (i2 = 0; i2 < W2.length; i2++) {
    var s2 = ~~(i2 / 20);
    var t2 = sum32_5$1(rotl32$1(a2, 5), ft_1(s2, b2, c2, d2), e2, W2[i2], sha1_K[s2]);
    e2 = d2;
    d2 = c2;
    c2 = rotl32$1(b2, 30);
    b2 = a2;
    a2 = t2;
  }
  this.h[0] = sum32$2(this.h[0], a2);
  this.h[1] = sum32$2(this.h[1], b2);
  this.h[2] = sum32$2(this.h[2], c2);
  this.h[3] = sum32$2(this.h[3], d2);
  this.h[4] = sum32$2(this.h[4], e2);
};
SHA1.prototype._digest = function digest2(enc) {
  if (enc === "hex")
    return utils$n.toHex32(this.h, "big");
  else
    return utils$n.split32(this.h, "big");
};
var utils$m = utils$q;
var common$2 = common$5;
var shaCommon = common$4;
var assert$8 = minimalisticAssert$1;
var sum32$1 = utils$m.sum32;
var sum32_4$1 = utils$m.sum32_4;
var sum32_5 = utils$m.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;
var BlockHash$2 = common$2.BlockHash;
var sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this);
  this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils$m.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function _update2(msg, start) {
  var W2 = this.W;
  for (var i2 = 0; i2 < 16; i2++)
    W2[i2] = msg[start + i2];
  for (; i2 < W2.length; i2++)
    W2[i2] = sum32_4$1(g1_256(W2[i2 - 2]), W2[i2 - 7], g0_256(W2[i2 - 15]), W2[i2 - 16]);
  var a2 = this.h[0];
  var b2 = this.h[1];
  var c2 = this.h[2];
  var d2 = this.h[3];
  var e2 = this.h[4];
  var f2 = this.h[5];
  var g2 = this.h[6];
  var h2 = this.h[7];
  assert$8(this.k.length === W2.length);
  for (i2 = 0; i2 < W2.length; i2++) {
    var T1 = sum32_5(h2, s1_256(e2), ch32(e2, f2, g2), this.k[i2], W2[i2]);
    var T2 = sum32$1(s0_256(a2), maj32(a2, b2, c2));
    h2 = g2;
    g2 = f2;
    f2 = e2;
    e2 = sum32$1(d2, T1);
    d2 = c2;
    c2 = b2;
    b2 = a2;
    a2 = sum32$1(T1, T2);
  }
  this.h[0] = sum32$1(this.h[0], a2);
  this.h[1] = sum32$1(this.h[1], b2);
  this.h[2] = sum32$1(this.h[2], c2);
  this.h[3] = sum32$1(this.h[3], d2);
  this.h[4] = sum32$1(this.h[4], e2);
  this.h[5] = sum32$1(this.h[5], f2);
  this.h[6] = sum32$1(this.h[6], g2);
  this.h[7] = sum32$1(this.h[7], h2);
};
SHA256$1.prototype._digest = function digest3(enc) {
  if (enc === "hex")
    return utils$m.toHex32(this.h, "big");
  else
    return utils$m.split32(this.h, "big");
};
var utils$l = utils$q;
var SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this);
  this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$l.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function digest4(enc) {
  if (enc === "hex")
    return utils$l.toHex32(this.h.slice(0, 7), "big");
  else
    return utils$l.split32(this.h.slice(0, 7), "big");
};
var utils$k = utils$q;
var common$1 = common$5;
var assert$7 = minimalisticAssert$1;
var rotr64_hi = utils$k.rotr64_hi;
var rotr64_lo = utils$k.rotr64_lo;
var shr64_hi = utils$k.shr64_hi;
var shr64_lo = utils$k.shr64_lo;
var sum64 = utils$k.sum64;
var sum64_hi = utils$k.sum64_hi;
var sum64_lo = utils$k.sum64_lo;
var sum64_4_hi = utils$k.sum64_4_hi;
var sum64_4_lo = utils$k.sum64_4_lo;
var sum64_5_hi = utils$k.sum64_5_hi;
var sum64_5_lo = utils$k.sum64_5_lo;
var BlockHash$1 = common$1.BlockHash;
var sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this);
  this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils$k.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;
SHA512$1.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W2 = this.W;
  for (var i2 = 0; i2 < 32; i2++)
    W2[i2] = msg[start + i2];
  for (; i2 < W2.length; i2 += 2) {
    var c0_hi = g1_512_hi(W2[i2 - 4], W2[i2 - 3]);
    var c0_lo = g1_512_lo(W2[i2 - 4], W2[i2 - 3]);
    var c1_hi = W2[i2 - 14];
    var c1_lo = W2[i2 - 13];
    var c2_hi = g0_512_hi(W2[i2 - 30], W2[i2 - 29]);
    var c2_lo = g0_512_lo(W2[i2 - 30], W2[i2 - 29]);
    var c3_hi = W2[i2 - 32];
    var c3_lo = W2[i2 - 31];
    W2[i2] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
    W2[i2 + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
  }
};
SHA512$1.prototype._update = function _update3(msg, start) {
  this._prepareBlock(msg, start);
  var W2 = this.W;
  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];
  assert$7(this.k.length === W2.length);
  for (var i2 = 0; i2 < W2.length; i2 += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i2];
    var c3_lo = this.k[i2 + 1];
    var c4_hi = W2[i2];
    var c4_lo = W2[i2 + 1];
    var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
    hh = gh;
    hl = gl;
    gh = fh;
    gl = fl;
    fh = eh;
    fl = el;
    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);
    dh = ch;
    dl = cl;
    ch = bh;
    cl = bl;
    bh = ah;
    bl = al;
    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }
  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};
SHA512$1.prototype._digest = function digest5(enc) {
  if (enc === "hex")
    return utils$k.toHex32(this.h, "big");
  else
    return utils$k.split32(this.h, "big");
};
function ch64_hi(xh, xl, yh, yl, zh2) {
  var r2 = xh & yh ^ ~xh & zh2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function ch64_lo(xh, xl, yh, yl, zh2, zl) {
  var r2 = xl & yl ^ ~xl & zl;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_hi(xh, xl, yh, yl, zh2) {
  var r2 = xh & yh ^ xh & zh2 ^ yh & zh2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_lo(xh, xl, yh, yl, zh2, zl) {
  var r2 = xl & yl ^ xl & zl ^ yl & zl;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);
  var c2_hi = rotr64_hi(xl, xh, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);
  var c2_lo = rotr64_lo(xl, xh, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);
  var c2_hi = shr64_hi(xh, xl, 6);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);
  var c2_lo = shr64_lo(xh, xl, 6);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
var utils$j = utils$q;
var SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this);
  this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$j.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function digest6(enc) {
  if (enc === "hex")
    return utils$j.toHex32(this.h.slice(0, 12), "big");
  else
    return utils$j.split32(this.h.slice(0, 12), "big");
};
sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;
var ripemd = {};
var utils$i = utils$q;
var common = common$5;
var rotl32 = utils$i.rotl32;
var sum32 = utils$i.sum32;
var sum32_3 = utils$i.sum32_3;
var sum32_4 = utils$i.sum32_4;
var BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this);
  this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  this.endian = "little";
}
utils$i.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function update2(msg, start) {
  var A2 = this.h[0];
  var B2 = this.h[1];
  var C2 = this.h[2];
  var D2 = this.h[3];
  var E2 = this.h[4];
  var Ah = A2;
  var Bh = B2;
  var Ch = C2;
  var Dh = D2;
  var Eh = E2;
  for (var j2 = 0; j2 < 80; j2++) {
    var T2 = sum32(rotl32(sum32_4(A2, f$2(j2, B2, C2, D2), msg[r$2[j2] + start], K$2(j2)), s$2[j2]), E2);
    A2 = E2;
    E2 = D2;
    D2 = rotl32(C2, 10);
    C2 = B2;
    B2 = T2;
    T2 = sum32(rotl32(sum32_4(Ah, f$2(79 - j2, Bh, Ch, Dh), msg[rh[j2] + start], Kh(j2)), sh[j2]), Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T2;
  }
  T2 = sum32_3(this.h[1], C2, Dh);
  this.h[1] = sum32_3(this.h[2], D2, Eh);
  this.h[2] = sum32_3(this.h[3], E2, Ah);
  this.h[3] = sum32_3(this.h[4], A2, Bh);
  this.h[4] = sum32_3(this.h[0], B2, Ch);
  this.h[0] = T2;
};
RIPEMD160.prototype._digest = function digest7(enc) {
  if (enc === "hex")
    return utils$i.toHex32(this.h, "little");
  else
    return utils$i.split32(this.h, "little");
};
function f$2(j2, x2, y2, z2) {
  if (j2 <= 15)
    return x2 ^ y2 ^ z2;
  else if (j2 <= 31)
    return x2 & y2 | ~x2 & z2;
  else if (j2 <= 47)
    return (x2 | ~y2) ^ z2;
  else if (j2 <= 63)
    return x2 & z2 | y2 & ~z2;
  else
    return x2 ^ (y2 | ~z2);
}
function K$2(j2) {
  if (j2 <= 15)
    return 0;
  else if (j2 <= 31)
    return 1518500249;
  else if (j2 <= 47)
    return 1859775393;
  else if (j2 <= 63)
    return 2400959708;
  else
    return 2840853838;
}
function Kh(j2) {
  if (j2 <= 15)
    return 1352829926;
  else if (j2 <= 31)
    return 1548603684;
  else if (j2 <= 47)
    return 1836072691;
  else if (j2 <= 63)
    return 2053994217;
  else
    return 0;
}
var r$2 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
];
var rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
];
var s$2 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
];
var sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
];
var utils$h = utils$q;
var assert$6 = minimalisticAssert$1;
function Hmac(hash2, key2, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash2, key2, enc);
  this.Hash = hash2;
  this.blockSize = hash2.blockSize / 8;
  this.outSize = hash2.outSize / 8;
  this.inner = null;
  this.outer = null;
  this._init(utils$h.toArray(key2, enc));
}
var hmac = Hmac;
Hmac.prototype._init = function init(key2) {
  if (key2.length > this.blockSize)
    key2 = new this.Hash().update(key2).digest();
  assert$6(key2.length <= this.blockSize);
  for (var i2 = key2.length; i2 < this.blockSize; i2++)
    key2.push(0);
  for (i2 = 0; i2 < key2.length; i2++)
    key2[i2] ^= 54;
  this.inner = new this.Hash().update(key2);
  for (i2 = 0; i2 < key2.length; i2++)
    key2[i2] ^= 106;
  this.outer = new this.Hash().update(key2);
};
Hmac.prototype.update = function update3(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};
Hmac.prototype.digest = function digest8(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};
(function(exports) {
  var hash2 = exports;
  hash2.utils = utils$q;
  hash2.common = common$5;
  hash2.sha = sha;
  hash2.ripemd = ripemd;
  hash2.hmac = hmac;
  hash2.sha1 = hash2.sha.sha1;
  hash2.sha256 = hash2.sha.sha256;
  hash2.sha224 = hash2.sha.sha224;
  hash2.sha384 = hash2.sha.sha384;
  hash2.sha512 = hash2.sha.sha512;
  hash2.ripemd160 = hash2.ripemd.ripemd160;
})(hash$3);
var hash$2 = hash$3;
function createCommonjsModule(fn, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path, base2) {
      return commonjsRequire(path, base2 === void 0 || base2 === null ? module.path : base2);
    }
  }, fn(module, module.exports), module.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert = assert;
function assert(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert.equal = function assertEqual2(l2, r2, msg) {
  if (l2 != r2)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
};
var utils_1 = createCommonjsModule(function(module, exports) {
  var utils2 = exports;
  function toArray2(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i2 = 0; i2 < msg.length; i2++)
        res[i2] = msg[i2] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i2 = 0; i2 < msg.length; i2 += 2)
        res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
    } else {
      for (var i2 = 0; i2 < msg.length; i2++) {
        var c2 = msg.charCodeAt(i2);
        var hi = c2 >> 8;
        var lo = c2 & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils2.toArray = toArray2;
  function zero22(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils2.zero2 = zero22;
  function toHex2(msg) {
    var res = "";
    for (var i2 = 0; i2 < msg.length; i2++)
      res += zero22(msg[i2].toString(16));
    return res;
  }
  utils2.toHex = toHex2;
  utils2.encode = function encode4(arr, enc) {
    if (enc === "hex")
      return toHex2(arr);
    else
      return arr;
  };
});
var utils_1$1 = createCommonjsModule(function(module, exports) {
  var utils2 = exports;
  utils2.assert = minimalisticAssert;
  utils2.toArray = utils_1.toArray;
  utils2.zero2 = utils_1.zero2;
  utils2.toHex = utils_1.toHex;
  utils2.encode = utils_1.encode;
  function getNAF2(num, w2, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w2 + 1;
    var k2 = num.clone();
    for (var i2 = 0; i2 < naf.length; i2++) {
      var z2;
      var mod = k2.andln(ws - 1);
      if (k2.isOdd()) {
        if (mod > (ws >> 1) - 1)
          z2 = (ws >> 1) - mod;
        else
          z2 = mod;
        k2.isubn(z2);
      } else {
        z2 = 0;
      }
      naf[i2] = z2;
      k2.iushrn(1);
    }
    return naf;
  }
  utils2.getNAF = getNAF2;
  function getJSF2(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  utils2.getJSF = getJSF2;
  function cachedProperty(obj, name, computer) {
    var key2 = "_" + name;
    obj.prototype[name] = function cachedProperty2() {
      return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
    };
  }
  utils2.cachedProperty = cachedProperty;
  function parseBytes(bytes) {
    return typeof bytes === "string" ? utils2.toArray(bytes, "hex") : bytes;
  }
  utils2.parseBytes = parseBytes;
  function intFromLE(bytes) {
    return new BN$2(bytes, "hex", "le");
  }
  utils2.intFromLE = intFromLE;
});
var getNAF = utils_1$1.getNAF;
var getJSF = utils_1$1.getJSF;
var assert$1 = utils_1$1.assert;
function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN$2(conf.p, 16);
  this.red = conf.prime ? BN$2.red(conf.prime) : BN$2.mont(this.p);
  this.zero = new BN$2(0).toRed(this.red);
  this.one = new BN$2(1).toRed(this.red);
  this.two = new BN$2(2).toRed(this.red);
  this.n = conf.n && new BN$2(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base = BaseCurve;
BaseCurve.prototype.point = function point() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function validate() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p2, k2) {
  assert$1(p2.precomputed);
  var doubles = p2._getDoubles();
  var naf = getNAF(k2, 1, this._bitLength);
  var I2 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I2 /= 3;
  var repr = [];
  var j2;
  var nafW;
  for (j2 = 0; j2 < naf.length; j2 += doubles.step) {
    nafW = 0;
    for (var l2 = j2 + doubles.step - 1; l2 >= j2; l2--)
      nafW = (nafW << 1) + naf[l2];
    repr.push(nafW);
  }
  var a2 = this.jpoint(null, null, null);
  var b2 = this.jpoint(null, null, null);
  for (var i2 = I2; i2 > 0; i2--) {
    for (j2 = 0; j2 < repr.length; j2++) {
      nafW = repr[j2];
      if (nafW === i2)
        b2 = b2.mixedAdd(doubles.points[j2]);
      else if (nafW === -i2)
        b2 = b2.mixedAdd(doubles.points[j2].neg());
    }
    a2 = a2.add(b2);
  }
  return a2.toP();
};
BaseCurve.prototype._wnafMul = function _wnafMul(p2, k2) {
  var w2 = 4;
  var nafPoints = p2._getNAFPoints(w2);
  w2 = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF(k2, w2, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i2 = naf.length - 1; i2 >= 0; i2--) {
    for (var l2 = 0; i2 >= 0 && naf[i2] === 0; i2--)
      l2++;
    if (i2 >= 0)
      l2++;
    acc = acc.dblp(l2);
    if (i2 < 0)
      break;
    var z2 = naf[i2];
    assert$1(z2 !== 0);
    if (p2.type === "affine") {
      if (z2 > 0)
        acc = acc.mixedAdd(wnd[z2 - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z2 - 1 >> 1].neg());
    } else {
      if (z2 > 0)
        acc = acc.add(wnd[z2 - 1 >> 1]);
      else
        acc = acc.add(wnd[-z2 - 1 >> 1].neg());
    }
  }
  return p2.type === "affine" ? acc.toP() : acc;
};
BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max2 = 0;
  var i2;
  var j2;
  var p2;
  for (i2 = 0; i2 < len; i2++) {
    p2 = points[i2];
    var nafPoints = p2._getNAFPoints(defW);
    wndWidth[i2] = nafPoints.wnd;
    wnd[i2] = nafPoints.points;
  }
  for (i2 = len - 1; i2 >= 1; i2 -= 2) {
    var a2 = i2 - 1;
    var b2 = i2;
    if (wndWidth[a2] !== 1 || wndWidth[b2] !== 1) {
      naf[a2] = getNAF(coeffs[a2], wndWidth[a2], this._bitLength);
      naf[b2] = getNAF(coeffs[b2], wndWidth[b2], this._bitLength);
      max2 = Math.max(naf[a2].length, max2);
      max2 = Math.max(naf[b2].length, max2);
      continue;
    }
    var comb = [
      points[a2],
      null,
      null,
      points[b2]
    ];
    if (points[a2].y.cmp(points[b2].y) === 0) {
      comb[1] = points[a2].add(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    } else if (points[a2].y.cmp(points[b2].y.redNeg()) === 0) {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].add(points[b2].neg());
    } else {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    }
    var index2 = [
      -3,
      -1,
      -5,
      -7,
      0,
      7,
      5,
      1,
      3
    ];
    var jsf = getJSF(coeffs[a2], coeffs[b2]);
    max2 = Math.max(jsf[0].length, max2);
    naf[a2] = new Array(max2);
    naf[b2] = new Array(max2);
    for (j2 = 0; j2 < max2; j2++) {
      var ja = jsf[0][j2] | 0;
      var jb = jsf[1][j2] | 0;
      naf[a2][j2] = index2[(ja + 1) * 3 + (jb + 1)];
      naf[b2][j2] = 0;
      wnd[a2] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i2 = max2; i2 >= 0; i2--) {
    var k2 = 0;
    while (i2 >= 0) {
      var zero = true;
      for (j2 = 0; j2 < len; j2++) {
        tmp[j2] = naf[j2][i2] | 0;
        if (tmp[j2] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k2++;
      i2--;
    }
    if (i2 >= 0)
      k2++;
    acc = acc.dblp(k2);
    if (i2 < 0)
      break;
    for (j2 = 0; j2 < len; j2++) {
      var z2 = tmp[j2];
      if (z2 === 0)
        continue;
      else if (z2 > 0)
        p2 = wnd[j2][z2 - 1 >> 1];
      else if (z2 < 0)
        p2 = wnd[j2][-z2 - 1 >> 1].neg();
      if (p2.type === "affine")
        acc = acc.mixedAdd(p2);
      else
        acc = acc.add(p2);
    }
  }
  for (i2 = 0; i2 < len; i2++)
    wnd[i2] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function eq() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function validate2() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils_1$1.toArray(bytes, enc);
  var len = this.p.byteLength();
  if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
    if (bytes[0] === 6)
      assert$1(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 7)
      assert$1(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
    return res;
  } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};
BasePoint.prototype._encode = function _encode2(compact) {
  var len = this.curve.p.byteLength();
  var x2 = this.getX().toArray("be", len);
  if (compact)
    return [this.getY().isEven() ? 2 : 3].concat(x2);
  return [4].concat(x2, this.getY().toArray("be", len));
};
BasePoint.prototype.encode = function encode(enc, compact) {
  return utils_1$1.encode(this._encode(compact), enc);
};
BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint.prototype._hasDoubles = function _hasDoubles(k2) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k2.bitLength() + 1) / doubles.step);
};
BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i2 = 0; i2 < power; i2 += step) {
    for (var j2 = 0; j2 < step; j2++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max2 = (1 << wnd) - 1;
  var dbl3 = max2 === 1 ? null : this.dbl();
  for (var i2 = 1; i2 < max2; i2++)
    res[i2] = res[i2 - 1].add(dbl3);
  return {
    wnd,
    points: res
  };
};
BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};
BasePoint.prototype.dblp = function dblp(k2) {
  var r2 = this;
  for (var i2 = 0; i2 < k2; i2++)
    r2 = r2.dbl();
  return r2;
};
var inherits_browser = createCommonjsModule(function(module) {
  if (typeof Object.create === "function") {
    module.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
var assert$2 = utils_1$1.assert;
function ShortCurve(conf) {
  base.call(this, "short", conf);
  this.a = new BN$2(conf.a, 16).toRed(this.red);
  this.b = new BN$2(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits_browser(ShortCurve, base);
var short_1 = ShortCurve;
ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN$2(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN$2(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN$2(vec.a, 16),
        b: new BN$2(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  var red = num === this.p ? this.red : BN$2.mont(num);
  var tinv = new BN$2(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s2 = new BN$2(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s2).fromRed();
  var l2 = ntinv.redSub(s2).fromRed();
  return [l1, l2];
};
ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u2 = lambda;
  var v2 = this.n.clone();
  var x1 = new BN$2(1);
  var y1 = new BN$2(0);
  var x2 = new BN$2(0);
  var y2 = new BN$2(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a2;
  var b2;
  var prevR;
  var i2 = 0;
  var r2;
  var x3;
  while (u2.cmpn(0) !== 0) {
    var q2 = v2.div(u2);
    r2 = v2.sub(q2.mul(u2));
    x3 = x2.sub(q2.mul(x1));
    var y3 = y2.sub(q2.mul(y1));
    if (!a1 && r2.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r2.neg();
      b1 = x3;
    } else if (a1 && ++i2 === 2) {
      break;
    }
    prevR = r2;
    v2 = u2;
    u2 = r2;
    x2 = x1;
    x1 = x3;
    y2 = y1;
    y1 = y3;
  }
  a2 = r2.neg();
  b2 = x3;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};
ShortCurve.prototype._endoSplit = function _endoSplit(k2) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k2).divRound(this.n);
  var c2 = v1.b.neg().mul(k2).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);
  var k1 = k2.sub(p1).sub(p2);
  var k22 = q1.add(q2).neg();
  return { k1, k2: k22 };
};
ShortCurve.prototype.pointFromX = function pointFromX(x2, odd) {
  x2 = new BN$2(x2, 16);
  if (!x2.red)
    x2 = x2.toRed(this.red);
  var y2 = x2.redSqr().redMul(x2).redIAdd(x2.redMul(this.a)).redIAdd(this.b);
  var y3 = y2.redSqrt();
  if (y3.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y3.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y3 = y3.redNeg();
  return this.point(x2, y3);
};
ShortCurve.prototype.validate = function validate3(point3) {
  if (point3.inf)
    return true;
  var x2 = point3.x;
  var y2 = point3.y;
  var ax = this.a.redMul(x2);
  var rhs = x2.redSqr().redMul(x2).redIAdd(ax).redIAdd(this.b);
  return y2.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i2 = 0; i2 < points.length; i2++) {
    var split = this._endoSplit(coeffs[i2]);
    var p2 = points[i2];
    var beta = p2._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p2 = p2.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i2 * 2] = p2;
    npoints[i2 * 2 + 1] = beta;
    ncoeffs[i2 * 2] = split.k1;
    ncoeffs[i2 * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i2 * 2, jacobianResult);
  for (var j2 = 0; j2 < i2 * 2; j2++) {
    npoints[j2] = null;
    ncoeffs[j2] = null;
  }
  return res;
};
function Point(curve, x2, y2, isRed) {
  base.BasePoint.call(this, curve, "affine");
  if (x2 === null && y2 === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN$2(x2, 16);
    this.y = new BN$2(y2, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits_browser(Point, base.BasePoint);
ShortCurve.prototype.point = function point2(x2, y2, isRed) {
  return new Point(this, x2, y2, isRed);
};
ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};
Point.prototype._getBeta = function _getBeta2() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p2) {
      return curve.point(p2.x.redMul(curve.endo.beta), p2.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve.point(obj2[0], obj2[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};
Point.prototype.add = function add(p2) {
  if (this.inf)
    return p2;
  if (p2.inf)
    return this;
  if (this.eq(p2))
    return this.dbl();
  if (this.neg().eq(p2))
    return this.curve.point(null, null);
  if (this.x.cmp(p2.x) === 0)
    return this.curve.point(null, null);
  var c2 = this.y.redSub(p2.y);
  if (c2.cmpn(0) !== 0)
    c2 = c2.redMul(this.x.redSub(p2.x).redInvm());
  var nx = c2.redSqr().redISub(this.x).redISub(p2.x);
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a2 = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c2 = x2.redAdd(x2).redIAdd(x2).redIAdd(a2).redMul(dyinv);
  var nx = c2.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.getX = function getX() {
  return this.x.fromRed();
};
Point.prototype.getY = function getY() {
  return this.y.fromRed();
};
Point.prototype.mul = function mul(k2) {
  k2 = new BN$2(k2, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k2))
    return this.curve._fixedNafMul(this, k2);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k2]);
  else
    return this.curve._wnafMul(this, k2);
};
Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point.prototype.eq = function eq2(p2) {
  return this === p2 || this.inf === p2.inf && (this.inf || this.x.cmp(p2.x) === 0 && this.y.cmp(p2.y) === 0);
};
Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p2) {
      return p2.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint(curve, x2, y2, z2) {
  base.BasePoint.call(this, curve, "jacobian");
  if (x2 === null && y2 === null && z2 === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN$2(0);
  } else {
    this.x = new BN$2(x2, 16);
    this.y = new BN$2(y2, 16);
    this.z = new BN$2(z2, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits_browser(JPoint, base.BasePoint);
ShortCurve.prototype.jpoint = function jpoint(x2, y2, z2) {
  return new JPoint(this, x2, y2, z2);
};
JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint.prototype.neg = function neg2() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function add2(p2) {
  if (this.isInfinity())
    return p2;
  if (p2.isInfinity())
    return this;
  var pz2 = p2.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p2.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p2.z));
  var s2 = p2.y.redMul(z2.redMul(this.z));
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p2.z).redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mixedAdd = function mixedAdd(p2) {
  if (this.isInfinity())
    return p2.toJ();
  if (p2.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p2.x.redMul(z2);
  var s1 = this.y;
  var s2 = p2.y.redMul(z2).redMul(this.z);
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.dblp = function dblp2(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i2;
  if (this.curve.zeroA || this.curve.threeA) {
    var r2 = this;
    for (i2 = 0; i2 < pow; i2++)
      r2 = r2.dbl();
    return r2;
  }
  var a2 = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i2 = 0; i2 < pow; i2++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c2.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c2.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i2 + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint.prototype.dbl = function dbl2() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx);
    var t2 = m2.redSqr().redISub(s2).redISub(s2);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t2;
    ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a2 = this.x.redSqr();
    var b2 = this.y.redSqr();
    var c2 = b2.redSqr();
    var d2 = this.x.redAdd(b2).redSqr().redISub(a2).redISub(c2);
    d2 = d2.redIAdd(d2);
    var e2 = a2.redAdd(a2).redIAdd(a2);
    var f2 = e2.redSqr();
    var c8 = c2.redIAdd(c2);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f2.redISub(d2).redISub(d2);
    ny = e2.redMul(d2.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t2 = m2.redSqr().redISub(s2).redISub(s2);
    nx = t2;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._dbl = function _dbl() {
  var a2 = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c2.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c2.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m2 = xx.redAdd(xx).redIAdd(xx);
  var mm = m2.redSqr();
  var e2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e2 = e2.redIAdd(e2);
  e2 = e2.redAdd(e2).redIAdd(e2);
  e2 = e2.redISub(mm);
  var ee2 = e2.redSqr();
  var t2 = yyyy.redIAdd(yyyy);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  var u2 = m2.redIAdd(e2).redSqr().redISub(mm).redISub(ee2).redISub(t2);
  var yyu4 = yy.redMul(u2);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee2).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u2.redMul(t2.redISub(u2)).redISub(e2.redMul(ee2)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e2).redSqr().redISub(zz).redISub(ee2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mul = function mul2(k2, kbase) {
  k2 = new BN$2(k2, kbase);
  return this.curve._wnafMul(this, k2);
};
JPoint.prototype.eq = function eq3(p2) {
  if (p2.type === "affine")
    return this.eq(p2.toJ());
  if (this === p2)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p2.z.redSqr();
  if (this.x.redMul(pz2).redISub(p2.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p2.z);
  return this.y.redMul(pz3).redISub(p2.y.redMul(z3)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function eqXToP(x2) {
  var zs = this.z.redSqr();
  var rx = x2.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x2.clone();
  var t2 = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t2);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint.prototype.inspect = function inspect2() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function isInfinity2() {
  return this.z.cmpn(0) === 0;
};
var curve_1 = createCommonjsModule(function(module, exports) {
  var curve = exports;
  curve.base = base;
  curve.short = short_1;
  curve.mont = null;
  curve.edwards = null;
});
var curves_1 = createCommonjsModule(function(module, exports) {
  var curves = exports;
  var assert2 = utils_1$1.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve_1.short(options);
    else if (options.type === "edwards")
      this.curve = new curve_1.edwards(options);
    else
      this.curve = new curve_1.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert2(this.g.validate(), "Invalid curve");
    assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves.PresetCurve = PresetCurve;
  function defineCurve(name, options) {
    Object.defineProperty(curves, name, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash$2.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash$2.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash$2.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash$2.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash$2.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$2.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$2.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = null.crash();
  } catch (e2) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash$2.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
});
function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_1.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._init(entropy, nonce, pers);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function init2(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i2 = 0; i2 < this.V.length; i2++) {
    this.K[i2] = 0;
    this.V[i2] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function hmac2() {
  return new hash$2.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function update4(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add4, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add4;
    add4 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils_1.toArray(entropy, entropyEnc);
  add4 = utils_1.toArray(add4, addEnc);
  minimalisticAssert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._update(entropy.concat(add4 || []));
  this._reseed = 1;
};
HmacDRBG.prototype.generate = function generate(len, enc, add4, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add4;
    add4 = enc;
    enc = null;
  }
  if (add4) {
    add4 = utils_1.toArray(add4, addEnc || "hex");
    this._update(add4);
  }
  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len);
  this._update(add4);
  this._reseed++;
  return utils_1.encode(res, enc);
};
var assert$3 = utils_1$1.assert;
function KeyPair(ec2, options) {
  this.ec = ec2;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key = KeyPair;
KeyPair.fromPublic = function fromPublic(ec2, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(ec2, {
    pub,
    pubEnc: enc
  });
};
KeyPair.fromPrivate = function fromPrivate(ec2, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;
  return new KeyPair(ec2, {
    priv,
    privEnc: enc
  });
};
KeyPair.prototype.validate = function validate4() {
  var pub = this.getPublic();
  if (pub.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  if (typeof compact === "string") {
    enc = compact;
    compact = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact);
};
KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair.prototype._importPrivate = function _importPrivate(key2, enc) {
  this.priv = new BN$2(key2, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair.prototype._importPublic = function _importPublic(key2, enc) {
  if (key2.x || key2.y) {
    if (this.ec.curve.type === "mont") {
      assert$3(key2.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$3(key2.x && key2.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key2.x, key2.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key2, enc);
};
KeyPair.prototype.derive = function derive(pub) {
  if (!pub.validate()) {
    assert$3(pub.validate(), "public point not validated");
  }
  return pub.mul(this.priv).getX();
};
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair.prototype.verify = function verify(msg, signature2) {
  return this.ec.verify(msg, signature2, this);
};
KeyPair.prototype.inspect = function inspect3() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$4 = utils_1$1.assert;
function Signature(options, enc) {
  if (options instanceof Signature)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$4(options.r && options.s, "Signature without r or s");
  this.r = new BN$2(options.r, 16);
  this.s = new BN$2(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature = Signature;
function Position() {
  this.place = 0;
}
function getLength(buf, p2) {
  var initial = buf[p2.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i2 = 0, off2 = p2.place; i2 < octetLen; i2++, off2++) {
    val <<= 8;
    val |= buf[off2];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p2.place = off2;
  return val;
}
function rmPadding(buf) {
  var i2 = 0;
  var len = buf.length - 1;
  while (!buf[i2] && !(buf[i2 + 1] & 128) && i2 < len) {
    i2++;
  }
  if (i2 === 0) {
    return buf;
  }
  return buf.slice(i2);
}
Signature.prototype._importDER = function _importDER(data2, enc) {
  data2 = utils_1$1.toArray(data2, enc);
  var p2 = new Position();
  if (data2[p2.place++] !== 48) {
    return false;
  }
  var len = getLength(data2, p2);
  if (len === false) {
    return false;
  }
  if (len + p2.place !== data2.length) {
    return false;
  }
  if (data2[p2.place++] !== 2) {
    return false;
  }
  var rlen = getLength(data2, p2);
  if (rlen === false) {
    return false;
  }
  var r2 = data2.slice(p2.place, rlen + p2.place);
  p2.place += rlen;
  if (data2[p2.place++] !== 2) {
    return false;
  }
  var slen = getLength(data2, p2);
  if (slen === false) {
    return false;
  }
  if (data2.length !== slen + p2.place) {
    return false;
  }
  var s2 = data2.slice(p2.place, slen + p2.place);
  if (r2[0] === 0) {
    if (r2[1] & 128) {
      r2 = r2.slice(1);
    } else {
      return false;
    }
  }
  if (s2[0] === 0) {
    if (s2[1] & 128) {
      s2 = s2.slice(1);
    } else {
      return false;
    }
  }
  this.r = new BN$2(r2);
  this.s = new BN$2(s2);
  this.recoveryParam = null;
  return true;
};
function constructLength(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
Signature.prototype.toDER = function toDER(enc) {
  var r2 = this.r.toArray();
  var s2 = this.s.toArray();
  if (r2[0] & 128)
    r2 = [0].concat(r2);
  if (s2[0] & 128)
    s2 = [0].concat(s2);
  r2 = rmPadding(r2);
  s2 = rmPadding(s2);
  while (!s2[0] && !(s2[1] & 128)) {
    s2 = s2.slice(1);
  }
  var arr = [2];
  constructLength(arr, r2.length);
  arr = arr.concat(r2);
  arr.push(2);
  constructLength(arr, s2.length);
  var backHalf = arr.concat(s2);
  var res = [48];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$1.encode(res, enc);
};
var rand = function() {
  throw new Error("unsupported");
};
var assert$5 = utils_1$1.assert;
function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);
  if (typeof options === "string") {
    assert$5(Object.prototype.hasOwnProperty.call(curves_1, options), "Unknown curve " + options);
    options = curves_1[options];
  }
  if (options instanceof curves_1.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var ec = EC;
EC.prototype.keyPair = function keyPair(options) {
  return new key(this, options);
};
EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return key.fromPrivate(this, priv, enc);
};
EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return key.fromPublic(this, pub, enc);
};
EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};
  var drbg = new hmacDrbg({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN$2(2));
  for (; ; ) {
    var priv = new BN$2(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};
EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};
EC.prototype.sign = function sign2(msg, key2, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key2 = this.keyFromPrivate(key2, enc);
  msg = this._truncateToN(new BN$2(msg, 16));
  var bytes = this.n.byteLength();
  var bkey = key2.getPrivate().toArray("be", bytes);
  var nonce = msg.toArray("be", bytes);
  var drbg = new hmacDrbg({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new BN$2(1));
  for (var iter = 0; ; iter++) {
    var k2 = options.k ? options.k(iter) : new BN$2(drbg.generate(this.n.byteLength()));
    k2 = this._truncateToN(k2, true);
    if (k2.cmpn(1) <= 0 || k2.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k2);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r2 = kpX.umod(this.n);
    if (r2.cmpn(0) === 0)
      continue;
    var s2 = k2.invm(this.n).mul(r2.mul(key2.getPrivate()).iadd(msg));
    s2 = s2.umod(this.n);
    if (s2.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
    if (options.canonical && s2.cmp(this.nh) > 0) {
      s2 = this.n.sub(s2);
      recoveryParam ^= 1;
    }
    return new signature({ r: r2, s: s2, recoveryParam });
  }
};
EC.prototype.verify = function verify2(msg, signature$1, key2, enc) {
  msg = this._truncateToN(new BN$2(msg, 16));
  key2 = this.keyFromPublic(key2, enc);
  signature$1 = new signature(signature$1, "hex");
  var r2 = signature$1.r;
  var s2 = signature$1.s;
  if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
    return false;
  if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
    return false;
  var sinv = s2.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r2).umod(this.n);
  var p2;
  if (!this.curve._maxwellTrick) {
    p2 = this.g.mulAdd(u1, key2.getPublic(), u2);
    if (p2.isInfinity())
      return false;
    return p2.getX().umod(this.n).cmp(r2) === 0;
  }
  p2 = this.g.jmulAdd(u1, key2.getPublic(), u2);
  if (p2.isInfinity())
    return false;
  return p2.eqXToP(r2);
};
EC.prototype.recoverPubKey = function(msg, signature$1, j2, enc) {
  assert$5((3 & j2) === j2, "The recovery param is more than two bits");
  signature$1 = new signature(signature$1, enc);
  var n2 = this.n;
  var e2 = new BN$2(msg);
  var r2 = signature$1.r;
  var s2 = signature$1.s;
  var isYOdd = j2 & 1;
  var isSecondKey = j2 >> 1;
  if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
  else
    r2 = this.curve.pointFromX(r2, isYOdd);
  var rInv = signature$1.r.invm(n2);
  var s1 = n2.sub(e2).mul(rInv).umod(n2);
  var s22 = s2.mul(rInv).umod(n2);
  return this.g.mulAdd(s1, r2, s22);
};
EC.prototype.getKeyRecoveryParam = function(e2, signature$1, Q2, enc) {
  signature$1 = new signature(signature$1, enc);
  if (signature$1.recoveryParam !== null)
    return signature$1.recoveryParam;
  for (var i2 = 0; i2 < 4; i2++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e2, signature$1, i2);
    } catch (e3) {
      continue;
    }
    if (Qprime.eq(Q2))
      return i2;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_1 = createCommonjsModule(function(module, exports) {
  var elliptic = exports;
  elliptic.version = { version: "6.5.4" }.version;
  elliptic.utils = utils_1$1;
  elliptic.rand = function() {
    throw new Error("unsupported");
  };
  elliptic.curve = curve_1;
  elliptic.curves = curves_1;
  elliptic.ec = ec;
  elliptic.eddsa = null;
});
var EC$1 = elliptic_1.ec;
const version$7 = "signing-key/5.5.0";
const logger$7 = new Logger(version$7);
let _curve = null;
function getCurve() {
  if (!_curve) {
    _curve = new EC$1("secp256k1");
  }
  return _curve;
}
class SigningKey {
  constructor(privateKey) {
    defineReadOnly(this, "curve", "secp256k1");
    defineReadOnly(this, "privateKey", hexlify(privateKey));
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    defineReadOnly(this, "publicKey", "0x" + keyPair2.getPublic(false, "hex"));
    defineReadOnly(this, "compressedPublicKey", "0x" + keyPair2.getPublic(true, "hex"));
    defineReadOnly(this, "_isSigningKey", true);
  }
  _addPoint(other) {
    const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));
    const p1 = getCurve().keyFromPublic(arrayify(other));
    return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
  }
  signDigest(digest9) {
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const digestBytes = arrayify(digest9);
    if (digestBytes.length !== 32) {
      logger$7.throwArgumentError("bad digest length", "digest", digest9);
    }
    const signature2 = keyPair2.sign(digestBytes, { canonical: true });
    return splitSignature({
      recoveryParam: signature2.recoveryParam,
      r: hexZeroPad("0x" + signature2.r.toString(16), 32),
      s: hexZeroPad("0x" + signature2.s.toString(16), 32)
    });
  }
  computeSharedSecret(otherKey) {
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));
    return hexZeroPad("0x" + keyPair2.derive(otherKeyPair.getPublic()).toString(16), 32);
  }
  static isSigningKey(value) {
    return !!(value && value._isSigningKey);
  }
}
function recoverPublicKey(digest9, signature2) {
  const sig = splitSignature(signature2);
  const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };
  return "0x" + getCurve().recoverPubKey(arrayify(digest9), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey(key2, compressed) {
  const bytes = arrayify(key2);
  if (bytes.length === 32) {
    const signingKey = new SigningKey(bytes);
    if (compressed) {
      return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes.length === 33) {
    if (compressed) {
      return hexlify(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");
  } else if (bytes.length === 65) {
    if (!compressed) {
      return hexlify(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");
  }
  return logger$7.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
const version$6 = "transactions/5.5.0";
const logger$6 = new Logger(version$6);
var TransactionTypes;
(function(TransactionTypes2) {
  TransactionTypes2[TransactionTypes2["legacy"] = 0] = "legacy";
  TransactionTypes2[TransactionTypes2["eip2930"] = 1] = "eip2930";
  TransactionTypes2[TransactionTypes2["eip1559"] = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
function handleNumber(value) {
  if (value === "0x") {
    return Zero$1;
  }
  return BigNumber.from(value);
}
function computeAddress(key2) {
  const publicKey = computePublicKey(key2);
  return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));
}
function recoverAddress(digest9, signature2) {
  return computeAddress(recoverPublicKey(arrayify(digest9), signature2));
}
function formatNumber(value, name) {
  const result = stripZeros(BigNumber.from(value).toHexString());
  if (result.length > 32) {
    logger$6.throwArgumentError("invalid length for " + name, "transaction:" + name, value);
  }
  return result;
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: (storageKeys || []).map((storageKey, index2) => {
      if (hexDataLength(storageKey) !== 32) {
        logger$6.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index2}]`, storageKey);
      }
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set2, index2) => {
      if (Array.isArray(set2)) {
        if (set2.length > 2) {
          logger$6.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index2}]`, set2);
        }
        return accessSetify(set2[0], set2[1]);
      }
      return accessSetify(set2.address, set2.storageKeys);
    });
  }
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a2, b2) => a2.address.localeCompare(b2.address));
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map((set2) => [set2.address, set2.storageKeys]);
}
function _serializeEip1559(transaction, signature2) {
  if (transaction.gasPrice != null) {
    const gasPrice = BigNumber.from(transaction.gasPrice);
    const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);
    if (!gasPrice.eq(maxFeePerGas)) {
      logger$6.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
        gasPrice,
        maxFeePerGas
      });
    }
  }
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x02", encode$3(fields)]);
}
function _serializeEip2930(transaction, signature2) {
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.gasPrice || 0, "gasPrice"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x01", encode$3(fields)]);
}
function _parseEipSignature(tx, fields, serialize) {
  try {
    const recid = handleNumber(fields[0]).toNumber();
    if (recid !== 0 && recid !== 1) {
      throw new Error("bad recid");
    }
    tx.v = recid;
  } catch (error) {
    logger$6.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
  }
  tx.r = hexZeroPad(fields[1], 32);
  tx.s = hexZeroPad(fields[2], 32);
  try {
    const digest9 = keccak256(serialize(tx));
    tx.from = recoverAddress(digest9, { r: tx.r, s: tx.s, recoveryParam: tx.v });
  } catch (error) {
    console.log(error);
  }
}
function _parseEip1559(payload) {
  const transaction = decode$3(payload.slice(1));
  if (transaction.length !== 9 && transaction.length !== 12) {
    logger$6.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify(payload));
  }
  const maxPriorityFeePerGas = handleNumber(transaction[2]);
  const maxFeePerGas = handleNumber(transaction[3]);
  const tx = {
    type: 2,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    maxPriorityFeePerGas,
    maxFeePerGas,
    gasPrice: null,
    gasLimit: handleNumber(transaction[4]),
    to: handleAddress(transaction[5]),
    value: handleNumber(transaction[6]),
    data: transaction[7],
    accessList: accessListify(transaction[8])
  };
  if (transaction.length === 9) {
    return tx;
  }
  tx.hash = keccak256(payload);
  _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
  return tx;
}
function _parseEip2930(payload) {
  const transaction = decode$3(payload.slice(1));
  if (transaction.length !== 8 && transaction.length !== 11) {
    logger$6.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify(payload));
  }
  const tx = {
    type: 1,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    gasPrice: handleNumber(transaction[2]),
    gasLimit: handleNumber(transaction[3]),
    to: handleAddress(transaction[4]),
    value: handleNumber(transaction[5]),
    data: transaction[6],
    accessList: accessListify(transaction[7])
  };
  if (transaction.length === 8) {
    return tx;
  }
  tx.hash = keccak256(payload);
  _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
  return tx;
}
function _parse(rawTransaction) {
  const transaction = decode$3(rawTransaction);
  if (transaction.length !== 9 && transaction.length !== 6) {
    logger$6.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
  }
  const tx = {
    nonce: handleNumber(transaction[0]).toNumber(),
    gasPrice: handleNumber(transaction[1]),
    gasLimit: handleNumber(transaction[2]),
    to: handleAddress(transaction[3]),
    value: handleNumber(transaction[4]),
    data: transaction[5],
    chainId: 0
  };
  if (transaction.length === 6) {
    return tx;
  }
  try {
    tx.v = BigNumber.from(transaction[6]).toNumber();
  } catch (error) {
    console.log(error);
    return tx;
  }
  tx.r = hexZeroPad(transaction[7], 32);
  tx.s = hexZeroPad(transaction[8], 32);
  if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {
    tx.chainId = tx.v;
    tx.v = 0;
  } else {
    tx.chainId = Math.floor((tx.v - 35) / 2);
    if (tx.chainId < 0) {
      tx.chainId = 0;
    }
    let recoveryParam = tx.v - 27;
    const raw = transaction.slice(0, 6);
    if (tx.chainId !== 0) {
      raw.push(hexlify(tx.chainId));
      raw.push("0x");
      raw.push("0x");
      recoveryParam -= tx.chainId * 2 + 8;
    }
    const digest9 = keccak256(encode$3(raw));
    try {
      tx.from = recoverAddress(digest9, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam });
    } catch (error) {
      console.log(error);
    }
    tx.hash = keccak256(rawTransaction);
  }
  tx.type = null;
  return tx;
}
function parse(rawTransaction) {
  const payload = arrayify(rawTransaction);
  if (payload[0] > 127) {
    return _parse(payload);
  }
  switch (payload[0]) {
    case 1:
      return _parseEip2930(payload);
    case 2:
      return _parseEip1559(payload);
  }
  return logger$6.throwError(`unsupported transaction type: ${payload[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: payload[0]
  });
}
class BaseX {
  constructor(alphabet) {
    defineReadOnly(this, "alphabet", alphabet);
    defineReadOnly(this, "base", alphabet.length);
    defineReadOnly(this, "_alphabetMap", {});
    defineReadOnly(this, "_leader", alphabet.charAt(0));
    for (let i2 = 0; i2 < alphabet.length; i2++) {
      this._alphabetMap[alphabet.charAt(i2)] = i2;
    }
  }
  encode(value) {
    let source2 = arrayify(value);
    if (source2.length === 0) {
      return "";
    }
    let digits = [0];
    for (let i2 = 0; i2 < source2.length; ++i2) {
      let carry = source2[i2];
      for (let j2 = 0; j2 < digits.length; ++j2) {
        carry += digits[j2] << 8;
        digits[j2] = carry % this.base;
        carry = carry / this.base | 0;
      }
      while (carry > 0) {
        digits.push(carry % this.base);
        carry = carry / this.base | 0;
      }
    }
    let string = "";
    for (let k2 = 0; source2[k2] === 0 && k2 < source2.length - 1; ++k2) {
      string += this._leader;
    }
    for (let q2 = digits.length - 1; q2 >= 0; --q2) {
      string += this.alphabet[digits[q2]];
    }
    return string;
  }
  decode(value) {
    if (typeof value !== "string") {
      throw new TypeError("Expected String");
    }
    let bytes = [];
    if (value.length === 0) {
      return new Uint8Array(bytes);
    }
    bytes.push(0);
    for (let i2 = 0; i2 < value.length; i2++) {
      let byte2 = this._alphabetMap[value[i2]];
      if (byte2 === void 0) {
        throw new Error("Non-base" + this.base + " character");
      }
      let carry = byte2;
      for (let j2 = 0; j2 < bytes.length; ++j2) {
        carry += bytes[j2] * this.base;
        bytes[j2] = carry & 255;
        carry >>= 8;
      }
      while (carry > 0) {
        bytes.push(carry & 255);
        carry >>= 8;
      }
    }
    for (let k2 = 0; value[k2] === this._leader && k2 < value.length - 1; ++k2) {
      bytes.push(0);
    }
    return arrayify(new Uint8Array(bytes.reverse()));
  }
}
new BaseX("abcdefghijklmnopqrstuvwxyz234567");
const Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
const version$5 = "sha2/5.5.0";
new Logger(version$5);
function sha256(data2) {
  return "0x" + hash$2.sha256().update(arrayify(data2)).digest("hex");
}
const version$4 = "networks/5.5.2";
const logger$5 = new Logger(version$4);
function isRenetworkable(value) {
  return value && typeof value.renetwork === "function";
}
function ethDefaultProvider(network) {
  const func = function(providers, options) {
    if (options == null) {
      options = {};
    }
    const providerList = [];
    if (providers.InfuraProvider) {
      try {
        providerList.push(new providers.InfuraProvider(network, options.infura));
      } catch (error) {
      }
    }
    if (providers.EtherscanProvider) {
      try {
        providerList.push(new providers.EtherscanProvider(network, options.etherscan));
      } catch (error) {
      }
    }
    if (providers.AlchemyProvider) {
      try {
        providerList.push(new providers.AlchemyProvider(network, options.alchemy));
      } catch (error) {
      }
    }
    if (providers.PocketProvider) {
      const skip = ["goerli", "ropsten", "rinkeby"];
      try {
        const provider = new providers.PocketProvider(network);
        if (provider.network && skip.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {
      }
    }
    if (providers.CloudflareProvider) {
      try {
        providerList.push(new providers.CloudflareProvider(network));
      } catch (error) {
      }
    }
    if (providerList.length === 0) {
      return null;
    }
    if (providers.FallbackProvider) {
      let quorum = 1;
      if (options.quorum != null) {
        quorum = options.quorum;
      } else if (network === "homestead") {
        quorum = 2;
      }
      return new providers.FallbackProvider(providerList, quorum);
    }
    return providerList[0];
  };
  func.renetwork = function(network2) {
    return ethDefaultProvider(network2);
  };
  return func;
}
function etcDefaultProvider(url, network) {
  const func = function(providers, options) {
    if (providers.JsonRpcProvider) {
      return new providers.JsonRpcProvider(url, network);
    }
    return null;
  };
  func.renetwork = function(network2) {
    return etcDefaultProvider(url, network2);
  };
  return func;
}
const homestead = {
  chainId: 1,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "homestead",
  _defaultProvider: ethDefaultProvider("homestead")
};
const ropsten = {
  chainId: 3,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "ropsten",
  _defaultProvider: ethDefaultProvider("ropsten")
};
const classicMordor = {
  chainId: 63,
  name: "classicMordor",
  _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
};
const networks$1 = {
  unspecified: { chainId: 0, name: "unspecified" },
  homestead,
  mainnet: homestead,
  morden: { chainId: 2, name: "morden" },
  ropsten,
  testnet: ropsten,
  rinkeby: {
    chainId: 4,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "rinkeby",
    _defaultProvider: ethDefaultProvider("rinkeby")
  },
  kovan: {
    chainId: 42,
    name: "kovan",
    _defaultProvider: ethDefaultProvider("kovan")
  },
  goerli: {
    chainId: 5,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "goerli",
    _defaultProvider: ethDefaultProvider("goerli")
  },
  kintsugi: { chainId: 1337702, name: "kintsugi" },
  classic: {
    chainId: 61,
    name: "classic",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
  },
  classicMorden: { chainId: 62, name: "classicMorden" },
  classicMordor,
  classicTestnet: classicMordor,
  classicKotti: {
    chainId: 6,
    name: "classicKotti",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
  },
  xdai: { chainId: 100, name: "xdai" },
  matic: { chainId: 137, name: "matic" },
  maticmum: { chainId: 80001, name: "maticmum" },
  optimism: { chainId: 10, name: "optimism" },
  "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
  "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
  arbitrum: { chainId: 42161, name: "arbitrum" },
  "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
  bnb: { chainId: 56, name: "bnb" },
  bnbt: { chainId: 97, name: "bnbt" }
};
function getNetwork(network) {
  if (network == null) {
    return null;
  }
  if (typeof network === "number") {
    for (const name in networks$1) {
      const standard2 = networks$1[name];
      if (standard2.chainId === network) {
        return {
          name: standard2.name,
          chainId: standard2.chainId,
          ensAddress: standard2.ensAddress || null,
          _defaultProvider: standard2._defaultProvider || null
        };
      }
    }
    return {
      chainId: network,
      name: "unknown"
    };
  }
  if (typeof network === "string") {
    const standard2 = networks$1[network];
    if (standard2 == null) {
      return null;
    }
    return {
      name: standard2.name,
      chainId: standard2.chainId,
      ensAddress: standard2.ensAddress,
      _defaultProvider: standard2._defaultProvider || null
    };
  }
  const standard = networks$1[network.name];
  if (!standard) {
    if (typeof network.chainId !== "number") {
      logger$5.throwArgumentError("invalid network chainId", "network", network);
    }
    return network;
  }
  if (network.chainId !== 0 && network.chainId !== standard.chainId) {
    logger$5.throwArgumentError("network chainId mismatch", "network", network);
  }
  let defaultProvider = network._defaultProvider || null;
  if (defaultProvider == null && standard._defaultProvider) {
    if (isRenetworkable(standard._defaultProvider)) {
      defaultProvider = standard._defaultProvider.renetwork(network);
    } else {
      defaultProvider = standard._defaultProvider;
    }
  }
  return {
    name: network.name,
    chainId: standard.chainId,
    ensAddress: network.ensAddress || standard.ensAddress || null,
    _defaultProvider: defaultProvider
  };
}
function decode$2(textData) {
  textData = atob(textData);
  const data2 = [];
  for (let i2 = 0; i2 < textData.length; i2++) {
    data2.push(textData.charCodeAt(i2));
  }
  return arrayify(data2);
}
function encode$2(data2) {
  data2 = arrayify(data2);
  let textData = "";
  for (let i2 = 0; i2 < data2.length; i2++) {
    textData += String.fromCharCode(data2[i2]);
  }
  return btoa(textData);
}
const version$3 = "web/5.5.1";
var __awaiter$3 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getUrl(href, options) {
  return __awaiter$3(this, void 0, void 0, function* () {
    if (options == null) {
      options = {};
    }
    const request2 = {
      method: options.method || "GET",
      headers: options.headers || {},
      body: options.body || void 0
    };
    if (options.skipFetchSetup !== true) {
      request2.mode = "cors";
      request2.cache = "no-cache";
      request2.credentials = "same-origin";
      request2.redirect = "follow";
      request2.referrer = "client";
    }
    const response = yield fetch(href, request2);
    const body = yield response.arrayBuffer();
    const headers = {};
    if (response.headers.forEach) {
      response.headers.forEach((value, key2) => {
        headers[key2.toLowerCase()] = value;
      });
    } else {
      response.headers.keys().forEach((key2) => {
        headers[key2.toLowerCase()] = response.headers.get(key2);
      });
    }
    return {
      headers,
      statusCode: response.status,
      statusMessage: response.statusText,
      body: arrayify(new Uint8Array(body))
    };
  });
}
var __awaiter$2 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$4 = new Logger(version$3);
function staller(duration) {
  return new Promise((resolve2) => {
    setTimeout(resolve2, duration);
  });
}
function bodyify(value, type) {
  if (value == null) {
    return null;
  }
  if (typeof value === "string") {
    return value;
  }
  if (isBytesLike(value)) {
    if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
      try {
        return toUtf8String(value);
      } catch (error) {
      }
    }
    return hexlify(value);
  }
  return value;
}
function _fetchData(connection, body, processFunc) {
  const attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
  logger$4.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
  const throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
  const throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
  logger$4.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
  const headers = {};
  let url = null;
  const options = {
    method: "GET"
  };
  let allow304 = false;
  let timeout = 2 * 60 * 1e3;
  if (typeof connection === "string") {
    url = connection;
  } else if (typeof connection === "object") {
    if (connection == null || connection.url == null) {
      logger$4.throwArgumentError("missing URL", "connection.url", connection);
    }
    url = connection.url;
    if (typeof connection.timeout === "number" && connection.timeout > 0) {
      timeout = connection.timeout;
    }
    if (connection.headers) {
      for (const key2 in connection.headers) {
        headers[key2.toLowerCase()] = { key: key2, value: String(connection.headers[key2]) };
        if (["if-none-match", "if-modified-since"].indexOf(key2.toLowerCase()) >= 0) {
          allow304 = true;
        }
      }
    }
    options.allowGzip = !!connection.allowGzip;
    if (connection.user != null && connection.password != null) {
      if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
        logger$4.throwError("basic authentication requires a secure https url", Logger.errors.INVALID_ARGUMENT, { argument: "url", url, user: connection.user, password: "[REDACTED]" });
      }
      const authorization = connection.user + ":" + connection.password;
      headers["authorization"] = {
        key: "Authorization",
        value: "Basic " + encode$2(toUtf8Bytes(authorization))
      };
    }
  }
  const reData = new RegExp("^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$", "i");
  const dataMatch = url ? url.match(reData) : null;
  if (dataMatch) {
    try {
      const response = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": dataMatch[1] },
        body: decode$2(dataMatch[2])
      };
      let result = response.body;
      if (processFunc) {
        result = processFunc(response.body, response);
      }
      return Promise.resolve(result);
    } catch (error) {
      logger$4.throwError("processing response error", Logger.errors.SERVER_ERROR, {
        body: bodyify(dataMatch[1], dataMatch[2]),
        error,
        requestBody: null,
        requestMethod: "GET",
        url
      });
    }
  }
  if (body) {
    options.method = "POST";
    options.body = body;
    if (headers["content-type"] == null) {
      headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
    }
    if (headers["content-length"] == null) {
      headers["content-length"] = { key: "Content-Length", value: String(body.length) };
    }
  }
  const flatHeaders = {};
  Object.keys(headers).forEach((key2) => {
    const header = headers[key2];
    flatHeaders[header.key] = header.value;
  });
  options.headers = flatHeaders;
  const runningTimeout = function() {
    let timer2 = null;
    const promise = new Promise(function(resolve2, reject) {
      if (timeout) {
        timer2 = setTimeout(() => {
          if (timer2 == null) {
            return;
          }
          timer2 = null;
          reject(logger$4.makeError("timeout", Logger.errors.TIMEOUT, {
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            timeout,
            url
          }));
        }, timeout);
      }
    });
    const cancel = function() {
      if (timer2 == null) {
        return;
      }
      clearTimeout(timer2);
      timer2 = null;
    };
    return { promise, cancel };
  }();
  const runningFetch = function() {
    return __awaiter$2(this, void 0, void 0, function* () {
      for (let attempt = 0; attempt < attemptLimit; attempt++) {
        let response = null;
        try {
          response = yield getUrl(url, options);
          if (attempt < attemptLimit) {
            if (response.statusCode === 301 || response.statusCode === 302) {
              const location = response.headers.location || "";
              if (options.method === "GET" && location.match(/^https:/)) {
                url = response.headers.location;
                continue;
              }
            } else if (response.statusCode === 429) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                let stall2 = 0;
                const retryAfter = response.headers["retry-after"];
                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                  stall2 = parseInt(retryAfter) * 1e3;
                } else {
                  stall2 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                }
                yield staller(stall2);
                continue;
              }
            }
          }
        } catch (error) {
          response = error.response;
          if (response == null) {
            runningTimeout.cancel();
            logger$4.throwError("missing response", Logger.errors.SERVER_ERROR, {
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              serverError: error,
              url
            });
          }
        }
        let body2 = response.body;
        if (allow304 && response.statusCode === 304) {
          body2 = null;
        } else if (response.statusCode < 200 || response.statusCode >= 300) {
          runningTimeout.cancel();
          logger$4.throwError("bad response", Logger.errors.SERVER_ERROR, {
            status: response.statusCode,
            headers: response.headers,
            body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            url
          });
        }
        if (processFunc) {
          try {
            const result = yield processFunc(body2, response);
            runningTimeout.cancel();
            return result;
          } catch (error) {
            if (error.throttleRetry && attempt < attemptLimit) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                const timeout2 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                yield staller(timeout2);
                continue;
              }
            }
            runningTimeout.cancel();
            logger$4.throwError("processing response error", Logger.errors.SERVER_ERROR, {
              body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
              error,
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              url
            });
          }
        }
        runningTimeout.cancel();
        return body2;
      }
      return logger$4.throwError("failed response", Logger.errors.SERVER_ERROR, {
        requestBody: bodyify(options.body, flatHeaders["content-type"]),
        requestMethod: options.method,
        url
      });
    });
  }();
  return Promise.race([runningTimeout.promise, runningFetch]);
}
function fetchJson(connection, json, processFunc) {
  let processJsonFunc = (value, response) => {
    let result = null;
    if (value != null) {
      try {
        result = JSON.parse(toUtf8String(value));
      } catch (error) {
        logger$4.throwError("invalid JSON", Logger.errors.SERVER_ERROR, {
          body: value,
          error
        });
      }
    }
    if (processFunc) {
      result = processFunc(result, response);
    }
    return result;
  };
  let body = null;
  if (json != null) {
    body = toUtf8Bytes(json);
    const updated = typeof connection === "string" ? { url: connection } : shallowCopy(connection);
    if (updated.headers) {
      const hasContentType = Object.keys(updated.headers).filter((k2) => k2.toLowerCase() === "content-type").length !== 0;
      if (!hasContentType) {
        updated.headers = shallowCopy(updated.headers);
        updated.headers["content-type"] = "application/json";
      }
    } else {
      updated.headers = { "content-type": "application/json" };
    }
    connection = updated;
  }
  return _fetchData(connection, body, processJsonFunc);
}
function poll(func, options) {
  if (!options) {
    options = {};
  }
  options = shallowCopy(options);
  if (options.floor == null) {
    options.floor = 0;
  }
  if (options.ceiling == null) {
    options.ceiling = 1e4;
  }
  if (options.interval == null) {
    options.interval = 250;
  }
  return new Promise(function(resolve2, reject) {
    let timer2 = null;
    let done = false;
    const cancel = () => {
      if (done) {
        return false;
      }
      done = true;
      if (timer2) {
        clearTimeout(timer2);
      }
      return true;
    };
    if (options.timeout) {
      timer2 = setTimeout(() => {
        if (cancel()) {
          reject(new Error("timeout"));
        }
      }, options.timeout);
    }
    const retryLimit = options.retryLimit;
    let attempt = 0;
    function check() {
      return func().then(function(result) {
        if (result !== void 0) {
          if (cancel()) {
            resolve2(result);
          }
        } else if (options.oncePoll) {
          options.oncePoll.once("poll", check);
        } else if (options.onceBlock) {
          options.onceBlock.once("block", check);
        } else if (!done) {
          attempt++;
          if (attempt > retryLimit) {
            if (cancel()) {
              reject(new Error("retry limit reached"));
            }
            return;
          }
          let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
          if (timeout < options.floor) {
            timeout = options.floor;
          }
          if (timeout > options.ceiling) {
            timeout = options.ceiling;
          }
          setTimeout(check, timeout);
        }
        return null;
      }, function(error) {
        if (cancel()) {
          reject(error);
        }
      });
    }
    check();
  });
}
var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
var ALPHABET_MAP = {};
for (var z$2 = 0; z$2 < ALPHABET.length; z$2++) {
  var x$3 = ALPHABET.charAt(z$2);
  if (ALPHABET_MAP[x$3] !== void 0)
    throw new TypeError(x$3 + " is ambiguous");
  ALPHABET_MAP[x$3] = z$2;
}
function polymodStep(pre) {
  var b2 = pre >> 25;
  return (pre & 33554431) << 5 ^ -(b2 >> 0 & 1) & 996825010 ^ -(b2 >> 1 & 1) & 642813549 ^ -(b2 >> 2 & 1) & 513874426 ^ -(b2 >> 3 & 1) & 1027748829 ^ -(b2 >> 4 & 1) & 705979059;
}
function prefixChk(prefix) {
  var chk = 1;
  for (var i2 = 0; i2 < prefix.length; ++i2) {
    var c2 = prefix.charCodeAt(i2);
    if (c2 < 33 || c2 > 126)
      return "Invalid prefix (" + prefix + ")";
    chk = polymodStep(chk) ^ c2 >> 5;
  }
  chk = polymodStep(chk);
  for (i2 = 0; i2 < prefix.length; ++i2) {
    var v2 = prefix.charCodeAt(i2);
    chk = polymodStep(chk) ^ v2 & 31;
  }
  return chk;
}
function encode$1(prefix, words, LIMIT) {
  LIMIT = LIMIT || 90;
  if (prefix.length + 7 + words.length > LIMIT)
    throw new TypeError("Exceeds length limit");
  prefix = prefix.toLowerCase();
  var chk = prefixChk(prefix);
  if (typeof chk === "string")
    throw new Error(chk);
  var result = prefix + "1";
  for (var i2 = 0; i2 < words.length; ++i2) {
    var x2 = words[i2];
    if (x2 >> 5 !== 0)
      throw new Error("Non 5-bit word");
    chk = polymodStep(chk) ^ x2;
    result += ALPHABET.charAt(x2);
  }
  for (i2 = 0; i2 < 6; ++i2) {
    chk = polymodStep(chk);
  }
  chk ^= 1;
  for (i2 = 0; i2 < 6; ++i2) {
    var v2 = chk >> (5 - i2) * 5 & 31;
    result += ALPHABET.charAt(v2);
  }
  return result;
}
function __decode(str, LIMIT) {
  LIMIT = LIMIT || 90;
  if (str.length < 8)
    return str + " too short";
  if (str.length > LIMIT)
    return "Exceeds length limit";
  var lowered = str.toLowerCase();
  var uppered = str.toUpperCase();
  if (str !== lowered && str !== uppered)
    return "Mixed-case string " + str;
  str = lowered;
  var split = str.lastIndexOf("1");
  if (split === -1)
    return "No separator character for " + str;
  if (split === 0)
    return "Missing prefix for " + str;
  var prefix = str.slice(0, split);
  var wordChars = str.slice(split + 1);
  if (wordChars.length < 6)
    return "Data too short";
  var chk = prefixChk(prefix);
  if (typeof chk === "string")
    return chk;
  var words = [];
  for (var i2 = 0; i2 < wordChars.length; ++i2) {
    var c2 = wordChars.charAt(i2);
    var v2 = ALPHABET_MAP[c2];
    if (v2 === void 0)
      return "Unknown character " + c2;
    chk = polymodStep(chk) ^ v2;
    if (i2 + 6 >= wordChars.length)
      continue;
    words.push(v2);
  }
  if (chk !== 1)
    return "Invalid checksum for " + str;
  return { prefix, words };
}
function decodeUnsafe() {
  var res = __decode.apply(null, arguments);
  if (typeof res === "object")
    return res;
}
function decode$1(str) {
  var res = __decode.apply(null, arguments);
  if (typeof res === "object")
    return res;
  throw new Error(res);
}
function convert(data2, inBits, outBits, pad2) {
  var value = 0;
  var bits = 0;
  var maxV = (1 << outBits) - 1;
  var result = [];
  for (var i2 = 0; i2 < data2.length; ++i2) {
    value = value << inBits | data2[i2];
    bits += inBits;
    while (bits >= outBits) {
      bits -= outBits;
      result.push(value >> bits & maxV);
    }
  }
  if (pad2) {
    if (bits > 0) {
      result.push(value << outBits - bits & maxV);
    }
  } else {
    if (bits >= inBits)
      return "Excess padding";
    if (value << outBits - bits & maxV)
      return "Non-zero padding";
  }
  return result;
}
function toWordsUnsafe(bytes) {
  var res = convert(bytes, 8, 5, true);
  if (Array.isArray(res))
    return res;
}
function toWords(bytes) {
  var res = convert(bytes, 8, 5, true);
  if (Array.isArray(res))
    return res;
  throw new Error(res);
}
function fromWordsUnsafe(words) {
  var res = convert(words, 5, 8, false);
  if (Array.isArray(res))
    return res;
}
function fromWords(words) {
  var res = convert(words, 5, 8, false);
  if (Array.isArray(res))
    return res;
  throw new Error(res);
}
var bech32 = {
  decodeUnsafe,
  decode: decode$1,
  encode: encode$1,
  toWordsUnsafe,
  toWords,
  fromWordsUnsafe,
  fromWords
};
const version$2 = "providers/5.5.3";
const logger$3 = new Logger(version$2);
class Formatter {
  constructor() {
    logger$3.checkNew(new.target, Formatter);
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const formats = {};
    const address = this.address.bind(this);
    const bigNumber = this.bigNumber.bind(this);
    const blockTag = this.blockTag.bind(this);
    const data2 = this.data.bind(this);
    const hash2 = this.hash.bind(this);
    const hex = this.hex.bind(this);
    const number = this.number.bind(this);
    const type = this.type.bind(this);
    const strictData = (v2) => {
      return this.data(v2, true);
    };
    formats.transaction = {
      hash: hash2,
      type,
      accessList: Formatter.allowNull(this.accessList.bind(this), null),
      blockHash: Formatter.allowNull(hash2, null),
      blockNumber: Formatter.allowNull(number, null),
      transactionIndex: Formatter.allowNull(number, null),
      confirmations: Formatter.allowNull(number, null),
      from: address,
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      gasLimit: bigNumber,
      to: Formatter.allowNull(address, null),
      value: bigNumber,
      nonce: number,
      data: data2,
      r: Formatter.allowNull(this.uint256),
      s: Formatter.allowNull(this.uint256),
      v: Formatter.allowNull(number),
      creates: Formatter.allowNull(address, null),
      raw: Formatter.allowNull(data2)
    };
    formats.transactionRequest = {
      from: Formatter.allowNull(address),
      nonce: Formatter.allowNull(number),
      gasLimit: Formatter.allowNull(bigNumber),
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      to: Formatter.allowNull(address),
      value: Formatter.allowNull(bigNumber),
      data: Formatter.allowNull(strictData),
      type: Formatter.allowNull(number),
      accessList: Formatter.allowNull(this.accessList.bind(this), null)
    };
    formats.receiptLog = {
      transactionIndex: number,
      blockNumber: number,
      transactionHash: hash2,
      address,
      topics: Formatter.arrayOf(hash2),
      data: data2,
      logIndex: number,
      blockHash: hash2
    };
    formats.receipt = {
      to: Formatter.allowNull(this.address, null),
      from: Formatter.allowNull(this.address, null),
      contractAddress: Formatter.allowNull(address, null),
      transactionIndex: number,
      root: Formatter.allowNull(hex),
      gasUsed: bigNumber,
      logsBloom: Formatter.allowNull(data2),
      blockHash: hash2,
      transactionHash: hash2,
      logs: Formatter.arrayOf(this.receiptLog.bind(this)),
      blockNumber: number,
      confirmations: Formatter.allowNull(number, null),
      cumulativeGasUsed: bigNumber,
      effectiveGasPrice: Formatter.allowNull(bigNumber),
      status: Formatter.allowNull(number),
      type
    };
    formats.block = {
      hash: hash2,
      parentHash: hash2,
      number,
      timestamp: number,
      nonce: Formatter.allowNull(hex),
      difficulty: this.difficulty.bind(this),
      gasLimit: bigNumber,
      gasUsed: bigNumber,
      miner: address,
      extraData: data2,
      transactions: Formatter.allowNull(Formatter.arrayOf(hash2)),
      baseFeePerGas: Formatter.allowNull(bigNumber)
    };
    formats.blockWithTransactions = shallowCopy(formats.block);
    formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
    formats.filter = {
      fromBlock: Formatter.allowNull(blockTag, void 0),
      toBlock: Formatter.allowNull(blockTag, void 0),
      blockHash: Formatter.allowNull(hash2, void 0),
      address: Formatter.allowNull(address, void 0),
      topics: Formatter.allowNull(this.topics.bind(this), void 0)
    };
    formats.filterLog = {
      blockNumber: Formatter.allowNull(number),
      blockHash: Formatter.allowNull(hash2),
      transactionIndex: number,
      removed: Formatter.allowNull(this.boolean.bind(this)),
      address,
      data: Formatter.allowFalsish(data2, "0x"),
      topics: Formatter.arrayOf(hash2),
      transactionHash: hash2,
      logIndex: number
    };
    return formats;
  }
  accessList(accessList) {
    return accessListify(accessList || []);
  }
  number(number) {
    if (number === "0x") {
      return 0;
    }
    return BigNumber.from(number).toNumber();
  }
  type(number) {
    if (number === "0x" || number == null) {
      return 0;
    }
    return BigNumber.from(number).toNumber();
  }
  bigNumber(value) {
    return BigNumber.from(value);
  }
  boolean(value) {
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "string") {
      value = value.toLowerCase();
      if (value === "true") {
        return true;
      }
      if (value === "false") {
        return false;
      }
    }
    throw new Error("invalid boolean - " + value);
  }
  hex(value, strict) {
    if (typeof value === "string") {
      if (!strict && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (isHexString$2(value)) {
        return value.toLowerCase();
      }
    }
    return logger$3.throwArgumentError("invalid hash", "value", value);
  }
  data(value, strict) {
    const result = this.hex(value, strict);
    if (result.length % 2 !== 0) {
      throw new Error("invalid data; odd-length - " + value);
    }
    return result;
  }
  address(value) {
    return getAddress(value);
  }
  callAddress(value) {
    if (!isHexString$2(value, 32)) {
      return null;
    }
    const address = getAddress(hexDataSlice(value, 12));
    return address === AddressZero ? null : address;
  }
  contractAddress(value) {
    return getContractAddress(value);
  }
  blockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    if (blockTag === "earliest") {
      return "0x0";
    }
    if (blockTag === "latest" || blockTag === "pending") {
      return blockTag;
    }
    if (typeof blockTag === "number" || isHexString$2(blockTag)) {
      return hexValue(blockTag);
    }
    throw new Error("invalid blockTag");
  }
  hash(value, strict) {
    const result = this.hex(value, strict);
    if (hexDataLength(result) !== 32) {
      return logger$3.throwArgumentError("invalid hash", "value", value);
    }
    return result;
  }
  difficulty(value) {
    if (value == null) {
      return null;
    }
    const v2 = BigNumber.from(value);
    try {
      return v2.toNumber();
    } catch (error) {
    }
    return null;
  }
  uint256(value) {
    if (!isHexString$2(value)) {
      throw new Error("invalid uint256");
    }
    return hexZeroPad(value, 32);
  }
  _block(value, format2) {
    if (value.author != null && value.miner == null) {
      value.miner = value.author;
    }
    const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;
    const result = Formatter.check(format2, value);
    result._difficulty = difficulty == null ? null : BigNumber.from(difficulty);
    return result;
  }
  block(value) {
    return this._block(value, this.formats.block);
  }
  blockWithTransactions(value) {
    return this._block(value, this.formats.blockWithTransactions);
  }
  transactionRequest(value) {
    return Formatter.check(this.formats.transactionRequest, value);
  }
  transactionResponse(transaction) {
    if (transaction.gas != null && transaction.gasLimit == null) {
      transaction.gasLimit = transaction.gas;
    }
    if (transaction.to && BigNumber.from(transaction.to).isZero()) {
      transaction.to = "0x0000000000000000000000000000000000000000";
    }
    if (transaction.input != null && transaction.data == null) {
      transaction.data = transaction.input;
    }
    if (transaction.to == null && transaction.creates == null) {
      transaction.creates = this.contractAddress(transaction);
    }
    if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
      transaction.accessList = [];
    }
    const result = Formatter.check(this.formats.transaction, transaction);
    if (transaction.chainId != null) {
      let chainId = transaction.chainId;
      if (isHexString$2(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      result.chainId = chainId;
    } else {
      let chainId = transaction.networkId;
      if (chainId == null && result.v == null) {
        chainId = transaction.chainId;
      }
      if (isHexString$2(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      if (typeof chainId !== "number" && result.v != null) {
        chainId = (result.v - 35) / 2;
        if (chainId < 0) {
          chainId = 0;
        }
        chainId = parseInt(chainId);
      }
      if (typeof chainId !== "number") {
        chainId = 0;
      }
      result.chainId = chainId;
    }
    if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
      result.blockHash = null;
    }
    return result;
  }
  transaction(value) {
    return parse(value);
  }
  receiptLog(value) {
    return Formatter.check(this.formats.receiptLog, value);
  }
  receipt(value) {
    const result = Formatter.check(this.formats.receipt, value);
    if (result.root != null) {
      if (result.root.length <= 4) {
        const value2 = BigNumber.from(result.root).toNumber();
        if (value2 === 0 || value2 === 1) {
          if (result.status != null && result.status !== value2) {
            logger$3.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
          }
          result.status = value2;
          delete result.root;
        } else {
          logger$3.throwArgumentError("invalid alt-root-status", "value.root", result.root);
        }
      } else if (result.root.length !== 66) {
        logger$3.throwArgumentError("invalid root hash", "value.root", result.root);
      }
    }
    if (result.status != null) {
      result.byzantium = true;
    }
    return result;
  }
  topics(value) {
    if (Array.isArray(value)) {
      return value.map((v2) => this.topics(v2));
    } else if (value != null) {
      return this.hash(value, true);
    }
    return null;
  }
  filter(value) {
    return Formatter.check(this.formats.filter, value);
  }
  filterLog(value) {
    return Formatter.check(this.formats.filterLog, value);
  }
  static check(format2, object) {
    const result = {};
    for (const key2 in format2) {
      try {
        const value = format2[key2](object[key2]);
        if (value !== void 0) {
          result[key2] = value;
        }
      } catch (error) {
        error.checkKey = key2;
        error.checkValue = object[key2];
        throw error;
      }
    }
    return result;
  }
  static allowNull(format2, nullValue) {
    return function(value) {
      if (value == null) {
        return nullValue;
      }
      return format2(value);
    };
  }
  static allowFalsish(format2, replaceValue) {
    return function(value) {
      if (!value) {
        return replaceValue;
      }
      return format2(value);
    };
  }
  static arrayOf(format2) {
    return function(array) {
      if (!Array.isArray(array)) {
        throw new Error("not an array");
      }
      const result = [];
      array.forEach(function(value) {
        result.push(format2(value));
      });
      return result;
    };
  }
}
var __awaiter$1 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$2 = new Logger(version$2);
function checkTopic(topic) {
  if (topic == null) {
    return "null";
  }
  if (hexDataLength(topic) !== 32) {
    logger$2.throwArgumentError("invalid topic", "topic", topic);
  }
  return topic.toLowerCase();
}
function serializeTopics(topics) {
  topics = topics.slice();
  while (topics.length > 0 && topics[topics.length - 1] == null) {
    topics.pop();
  }
  return topics.map((topic) => {
    if (Array.isArray(topic)) {
      const unique = {};
      topic.forEach((topic2) => {
        unique[checkTopic(topic2)] = true;
      });
      const sorted = Object.keys(unique);
      sorted.sort();
      return sorted.join("|");
    } else {
      return checkTopic(topic);
    }
  }).join("&");
}
function deserializeTopics(data2) {
  if (data2 === "") {
    return [];
  }
  return data2.split(/&/g).map((topic) => {
    if (topic === "") {
      return [];
    }
    const comps = topic.split("|").map((topic2) => {
      return topic2 === "null" ? null : topic2;
    });
    return comps.length === 1 ? comps[0] : comps;
  });
}
function getEventTag(eventName) {
  if (typeof eventName === "string") {
    eventName = eventName.toLowerCase();
    if (hexDataLength(eventName) === 32) {
      return "tx:" + eventName;
    }
    if (eventName.indexOf(":") === -1) {
      return eventName;
    }
  } else if (Array.isArray(eventName)) {
    return "filter:*:" + serializeTopics(eventName);
  } else if (ForkEvent.isForkEvent(eventName)) {
    logger$2.warn("not implemented");
    throw new Error("not implemented");
  } else if (eventName && typeof eventName === "object") {
    return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
  }
  throw new Error("invalid event - " + eventName);
}
function getTime() {
  return new Date().getTime();
}
function stall(duration) {
  return new Promise((resolve2) => {
    setTimeout(resolve2, duration);
  });
}
const PollableEvents = ["block", "network", "pending", "poll"];
class Event {
  constructor(tag, listener, once3) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "listener", listener);
    defineReadOnly(this, "once", once3);
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const comps = this.tag.split(":");
    if (comps[0] !== "tx") {
      return null;
    }
    return comps[1];
  }
  get filter() {
    const comps = this.tag.split(":");
    if (comps[0] !== "filter") {
      return null;
    }
    const address = comps[1];
    const topics = deserializeTopics(comps[2]);
    const filter = {};
    if (topics.length > 0) {
      filter.topics = topics;
    }
    if (address && address !== "*") {
      filter.address = address;
    }
    return filter;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
  }
}
const coinInfos = {
  "0": { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  "2": { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  "3": { symbol: "doge", p2pkh: 30, p2sh: 22 },
  "60": { symbol: "eth", ilk: "eth" },
  "61": { symbol: "etc", ilk: "eth" },
  "700": { symbol: "xdai", ilk: "eth" }
};
function bytes32ify(value) {
  return hexZeroPad(BigNumber.from(value).toHexString(), 32);
}
function base58Encode(data2) {
  return Base58.encode(concat([data2, hexDataSlice(sha256(sha256(data2)), 0, 4)]));
}
const matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
const matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
function _parseString(result) {
  try {
    return toUtf8String(_parseBytes(result));
  } catch (error) {
  }
  return null;
}
function _parseBytes(result) {
  if (result === "0x") {
    return null;
  }
  const offset2 = BigNumber.from(hexDataSlice(result, 0, 32)).toNumber();
  const length = BigNumber.from(hexDataSlice(result, offset2, offset2 + 32)).toNumber();
  return hexDataSlice(result, offset2 + 32, offset2 + 32 + length);
}
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    logger$2.throwArgumentError("unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
class Resolver {
  constructor(provider, address, name, resolvedAddress) {
    defineReadOnly(this, "provider", provider);
    defineReadOnly(this, "name", name);
    defineReadOnly(this, "address", provider.formatter.address(address));
    defineReadOnly(this, "_resolvedAddress", resolvedAddress);
  }
  _fetchBytes(selector, parameters) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const tx = {
        to: this.address,
        data: hexConcat([selector, namehash(this.name), parameters || "0x"])
      };
      try {
        return _parseBytes(yield this.provider.call(tx));
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          return null;
        }
        return null;
      }
    });
  }
  _getAddress(coinType, hexBytes) {
    const coinInfo = coinInfos[String(coinType)];
    if (coinInfo == null) {
      logger$2.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${coinType})`
      });
    }
    if (coinInfo.ilk === "eth") {
      return this.provider.formatter.address(hexBytes);
    }
    const bytes = arrayify(hexBytes);
    if (coinInfo.p2pkh != null) {
      const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (p2pkh) {
        const length = parseInt(p2pkh[1], 16);
        if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode(concat([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
        }
      }
    }
    if (coinInfo.p2sh != null) {
      const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (p2sh) {
        const length = parseInt(p2sh[1], 16);
        if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode(concat([[coinInfo.p2sh], "0x" + p2sh[2]]));
        }
      }
    }
    if (coinInfo.prefix != null) {
      const length = bytes[1];
      let version2 = bytes[0];
      if (version2 === 0) {
        if (length !== 20 && length !== 32) {
          version2 = -1;
        }
      } else {
        version2 = -1;
      }
      if (version2 >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {
        const words = bech32.toWords(bytes.slice(2));
        words.unshift(version2);
        return bech32.encode(coinInfo.prefix, words);
      }
    }
    return null;
  }
  getAddress(coinType) {
    return __awaiter$1(this, void 0, void 0, function* () {
      if (coinType == null) {
        coinType = 60;
      }
      if (coinType === 60) {
        try {
          const transaction = {
            to: this.address,
            data: "0x3b3b57de" + namehash(this.name).substring(2)
          };
          const hexBytes2 = yield this.provider.call(transaction);
          if (hexBytes2 === "0x" || hexBytes2 === HashZero) {
            return null;
          }
          return this.provider.formatter.callAddress(hexBytes2);
        } catch (error) {
          if (error.code === Logger.errors.CALL_EXCEPTION) {
            return null;
          }
          throw error;
        }
      }
      const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const address = this._getAddress(coinType, hexBytes);
      if (address == null) {
        logger$2.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `getAddress(${coinType})`,
          coinType,
          data: hexBytes
        });
      }
      return address;
    });
  }
  getAvatar() {
    return __awaiter$1(this, void 0, void 0, function* () {
      const linkage = [{ type: "name", content: this.name }];
      try {
        const avatar = yield this.getText("avatar");
        if (avatar == null) {
          return null;
        }
        for (let i2 = 0; i2 < matchers.length; i2++) {
          const match = avatar.match(matchers[i2]);
          if (match == null) {
            continue;
          }
          const scheme = match[1].toLowerCase();
          switch (scheme) {
            case "https":
              linkage.push({ type: "url", content: avatar });
              return { linkage, url: avatar };
            case "data":
              linkage.push({ type: "data", content: avatar });
              return { linkage, url: avatar };
            case "ipfs":
              linkage.push({ type: "ipfs", content: avatar });
              return { linkage, url: getIpfsLink(avatar) };
            case "erc721":
            case "erc1155": {
              const selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              linkage.push({ type: scheme, content: avatar });
              const owner = this._resolvedAddress || (yield this.getAddress());
              const comps = (match[2] || "").split("/");
              if (comps.length !== 2) {
                return null;
              }
              const addr = yield this.provider.formatter.address(comps[0]);
              const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);
              if (scheme === "erc721") {
                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x6352211e", tokenId])
                }));
                if (owner !== tokenOwner) {
                  return null;
                }
                linkage.push({ type: "owner", content: tokenOwner });
              } else if (scheme === "erc1155") {
                const balance = BigNumber.from(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x00fdd58e", hexZeroPad(owner, 32), tokenId])
                }));
                if (balance.isZero()) {
                  return null;
                }
                linkage.push({ type: "balance", content: balance.toString() });
              }
              const tx = {
                to: this.provider.formatter.address(comps[0]),
                data: hexConcat([selector, tokenId])
              };
              let metadataUrl = _parseString(yield this.provider.call(tx));
              if (metadataUrl == null) {
                return null;
              }
              linkage.push({ type: "metadata-url-base", content: metadataUrl });
              if (scheme === "erc1155") {
                metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                linkage.push({ type: "metadata-url-expanded", content: metadataUrl });
              }
              if (metadataUrl.match(/^ipfs:/i)) {
                metadataUrl = getIpfsLink(metadataUrl);
              }
              linkage.push({ type: "metadata-url", content: metadataUrl });
              const metadata = yield fetchJson(metadataUrl);
              if (!metadata) {
                return null;
              }
              linkage.push({ type: "metadata", content: JSON.stringify(metadata) });
              let imageUrl = metadata.image;
              if (typeof imageUrl !== "string") {
                return null;
              }
              if (imageUrl.match(/^(https:\/\/|data:)/i)) {
              } else {
                const ipfs = imageUrl.match(matcherIpfs);
                if (ipfs == null) {
                  return null;
                }
                linkage.push({ type: "url-ipfs", content: imageUrl });
                imageUrl = getIpfsLink(imageUrl);
              }
              linkage.push({ type: "url", content: imageUrl });
              return { linkage, url: imageUrl };
            }
          }
        }
      } catch (error) {
      }
      return null;
    });
  }
  getContentHash() {
    return __awaiter$1(this, void 0, void 0, function* () {
      const hexBytes = yield this._fetchBytes("0xbc1c58d1");
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipfs) {
        const length = parseInt(ipfs[3], 16);
        if (ipfs[4].length === length * 2) {
          return "ipfs://" + Base58.encode("0x" + ipfs[1]);
        }
      }
      const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (swarm) {
        if (swarm[1].length === 32 * 2) {
          return "bzz://" + swarm[1];
        }
      }
      return logger$2.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: hexBytes
      });
    });
  }
  getText(key2) {
    return __awaiter$1(this, void 0, void 0, function* () {
      let keyBytes = toUtf8Bytes(key2);
      keyBytes = concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
      if (keyBytes.length % 32 !== 0) {
        keyBytes = concat([keyBytes, hexZeroPad("0x", 32 - key2.length % 32)]);
      }
      const hexBytes = yield this._fetchBytes("0x59d1d43c", hexlify(keyBytes));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      return toUtf8String(hexBytes);
    });
  }
}
let defaultFormatter = null;
let nextPollId = 1;
class BaseProvider extends Provider {
  constructor(network) {
    logger$2.checkNew(new.target, Provider);
    super();
    this._events = [];
    this._emitted = { block: -2 };
    this.formatter = new.target.getFormatter();
    defineReadOnly(this, "anyNetwork", network === "any");
    if (this.anyNetwork) {
      network = this.detectNetwork();
    }
    if (network instanceof Promise) {
      this._networkPromise = network;
      network.catch((error) => {
      });
      this._ready().catch((error) => {
      });
    } else {
      const knownNetwork = getStatic(new.target, "getNetwork")(network);
      if (knownNetwork) {
        defineReadOnly(this, "_network", knownNetwork);
        this.emit("network", knownNetwork, null);
      } else {
        logger$2.throwArgumentError("invalid network", "network", network);
      }
    }
    this._maxInternalBlockNumber = -1024;
    this._lastBlockNumber = -2;
    this._pollingInterval = 4e3;
    this._fastQueryDate = 0;
  }
  _ready() {
    return __awaiter$1(this, void 0, void 0, function* () {
      if (this._network == null) {
        let network = null;
        if (this._networkPromise) {
          try {
            network = yield this._networkPromise;
          } catch (error) {
          }
        }
        if (network == null) {
          network = yield this.detectNetwork();
        }
        if (!network) {
          logger$2.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          if (this.anyNetwork) {
            this._network = network;
          } else {
            defineReadOnly(this, "_network", network);
          }
          this.emit("network", network, null);
        }
      }
      return this._network;
    });
  }
  get ready() {
    return poll(() => {
      return this._ready().then((network) => {
        return network;
      }, (error) => {
        if (error.code === Logger.errors.NETWORK_ERROR && error.event === "noNetwork") {
          return void 0;
        }
        throw error;
      });
    });
  }
  static getFormatter() {
    if (defaultFormatter == null) {
      defaultFormatter = new Formatter();
    }
    return defaultFormatter;
  }
  static getNetwork(network) {
    return getNetwork(network == null ? "homestead" : network);
  }
  _getInternalBlockNumber(maxAge) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this._ready();
      if (maxAge > 0) {
        while (this._internalBlockNumber) {
          const internalBlockNumber = this._internalBlockNumber;
          try {
            const result = yield internalBlockNumber;
            if (getTime() - result.respTime <= maxAge) {
              return result.blockNumber;
            }
            break;
          } catch (error) {
            if (this._internalBlockNumber === internalBlockNumber) {
              break;
            }
          }
        }
      }
      const reqTime = getTime();
      const checkInternalBlockNumber = resolveProperties({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then((network) => null, (error) => error)
      }).then(({ blockNumber, networkError }) => {
        if (networkError) {
          if (this._internalBlockNumber === checkInternalBlockNumber) {
            this._internalBlockNumber = null;
          }
          throw networkError;
        }
        const respTime = getTime();
        blockNumber = BigNumber.from(blockNumber).toNumber();
        if (blockNumber < this._maxInternalBlockNumber) {
          blockNumber = this._maxInternalBlockNumber;
        }
        this._maxInternalBlockNumber = blockNumber;
        this._setFastBlockNumber(blockNumber);
        return { blockNumber, reqTime, respTime };
      });
      this._internalBlockNumber = checkInternalBlockNumber;
      checkInternalBlockNumber.catch((error) => {
        if (this._internalBlockNumber === checkInternalBlockNumber) {
          this._internalBlockNumber = null;
        }
      });
      return (yield checkInternalBlockNumber).blockNumber;
    });
  }
  poll() {
    return __awaiter$1(this, void 0, void 0, function* () {
      const pollId = nextPollId++;
      const runners = [];
      let blockNumber = null;
      try {
        blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (error) {
        this.emit("error", error);
        return;
      }
      this._setFastBlockNumber(blockNumber);
      this.emit("poll", pollId, blockNumber);
      if (blockNumber === this._lastBlockNumber) {
        this.emit("didPoll", pollId);
        return;
      }
      if (this._emitted.block === -2) {
        this._emitted.block = blockNumber - 1;
      }
      if (Math.abs(this._emitted.block - blockNumber) > 1e3) {
        logger$2.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
        this.emit("error", logger$2.makeError("network block skew detected", Logger.errors.NETWORK_ERROR, {
          blockNumber,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        }));
        this.emit("block", blockNumber);
      } else {
        for (let i2 = this._emitted.block + 1; i2 <= blockNumber; i2++) {
          this.emit("block", i2);
        }
      }
      if (this._emitted.block !== blockNumber) {
        this._emitted.block = blockNumber;
        Object.keys(this._emitted).forEach((key2) => {
          if (key2 === "block") {
            return;
          }
          const eventBlockNumber = this._emitted[key2];
          if (eventBlockNumber === "pending") {
            return;
          }
          if (blockNumber - eventBlockNumber > 12) {
            delete this._emitted[key2];
          }
        });
      }
      if (this._lastBlockNumber === -2) {
        this._lastBlockNumber = blockNumber - 1;
      }
      this._events.forEach((event) => {
        switch (event.type) {
          case "tx": {
            const hash2 = event.hash;
            let runner = this.getTransactionReceipt(hash2).then((receipt) => {
              if (!receipt || receipt.blockNumber == null) {
                return null;
              }
              this._emitted["t:" + hash2] = receipt.blockNumber;
              this.emit(hash2, receipt);
              return null;
            }).catch((error) => {
              this.emit("error", error);
            });
            runners.push(runner);
            break;
          }
          case "filter": {
            const filter = event.filter;
            filter.fromBlock = this._lastBlockNumber + 1;
            filter.toBlock = blockNumber;
            const runner = this.getLogs(filter).then((logs) => {
              if (logs.length === 0) {
                return;
              }
              logs.forEach((log2) => {
                this._emitted["b:" + log2.blockHash] = log2.blockNumber;
                this._emitted["t:" + log2.transactionHash] = log2.blockNumber;
                this.emit(filter, log2);
              });
            }).catch((error) => {
              this.emit("error", error);
            });
            runners.push(runner);
            break;
          }
        }
      });
      this._lastBlockNumber = blockNumber;
      Promise.all(runners).then(() => {
        this.emit("didPoll", pollId);
      }).catch((error) => {
        this.emit("error", error);
      });
      return;
    });
  }
  resetEventsBlock(blockNumber) {
    this._lastBlockNumber = blockNumber - 1;
    if (this.polling) {
      this.poll();
    }
  }
  get network() {
    return this._network;
  }
  detectNetwork() {
    return __awaiter$1(this, void 0, void 0, function* () {
      return logger$2.throwError("provider does not support network detection", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }
  getNetwork() {
    return __awaiter$1(this, void 0, void 0, function* () {
      const network = yield this._ready();
      const currentNetwork = yield this.detectNetwork();
      if (network.chainId !== currentNetwork.chainId) {
        if (this.anyNetwork) {
          this._network = currentNetwork;
          this._lastBlockNumber = -2;
          this._fastBlockNumber = null;
          this._fastBlockNumberPromise = null;
          this._fastQueryDate = 0;
          this._emitted.block = -2;
          this._maxInternalBlockNumber = -1024;
          this._internalBlockNumber = null;
          this.emit("network", currentNetwork, network);
          yield stall(0);
          return this._network;
        }
        const error = logger$2.makeError("underlying network changed", Logger.errors.NETWORK_ERROR, {
          event: "changed",
          network,
          detectedNetwork: currentNetwork
        });
        this.emit("error", error);
        throw error;
      }
      return network;
    });
  }
  get blockNumber() {
    this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {
      this._setFastBlockNumber(blockNumber);
    }, (error) => {
    });
    return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }
  get polling() {
    return this._poller != null;
  }
  set polling(value) {
    if (value && !this._poller) {
      this._poller = setInterval(() => {
        this.poll();
      }, this.pollingInterval);
      if (!this._bootstrapPoll) {
        this._bootstrapPoll = setTimeout(() => {
          this.poll();
          this._bootstrapPoll = setTimeout(() => {
            if (!this._poller) {
              this.poll();
            }
            this._bootstrapPoll = null;
          }, this.pollingInterval);
        }, 0);
      }
    } else if (!value && this._poller) {
      clearInterval(this._poller);
      this._poller = null;
    }
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(value) {
    if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) {
      throw new Error("invalid polling interval");
    }
    this._pollingInterval = value;
    if (this._poller) {
      clearInterval(this._poller);
      this._poller = setInterval(() => {
        this.poll();
      }, this._pollingInterval);
    }
  }
  _getFastBlockNumber() {
    const now = getTime();
    if (now - this._fastQueryDate > 2 * this._pollingInterval) {
      this._fastQueryDate = now;
      this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
          this._fastBlockNumber = blockNumber;
        }
        return this._fastBlockNumber;
      });
    }
    return this._fastBlockNumberPromise;
  }
  _setFastBlockNumber(blockNumber) {
    if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
      return;
    }
    this._fastQueryDate = getTime();
    if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
      this._fastBlockNumber = blockNumber;
      this._fastBlockNumberPromise = Promise.resolve(blockNumber);
    }
  }
  waitForTransaction(transactionHash, confirmations, timeout) {
    return __awaiter$1(this, void 0, void 0, function* () {
      return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null);
    });
  }
  _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const receipt = yield this.getTransactionReceipt(transactionHash);
      if ((receipt ? receipt.confirmations : 0) >= confirmations) {
        return receipt;
      }
      return new Promise((resolve2, reject) => {
        const cancelFuncs = [];
        let done = false;
        const alreadyDone = function() {
          if (done) {
            return true;
          }
          done = true;
          cancelFuncs.forEach((func) => {
            func();
          });
          return false;
        };
        const minedHandler = (receipt2) => {
          if (receipt2.confirmations < confirmations) {
            return;
          }
          if (alreadyDone()) {
            return;
          }
          resolve2(receipt2);
        };
        this.on(transactionHash, minedHandler);
        cancelFuncs.push(() => {
          this.removeListener(transactionHash, minedHandler);
        });
        if (replaceable) {
          let lastBlockNumber = replaceable.startBlock;
          let scannedBlock = null;
          const replaceHandler = (blockNumber) => __awaiter$1(this, void 0, void 0, function* () {
            if (done) {
              return;
            }
            yield stall(1e3);
            this.getTransactionCount(replaceable.from).then((nonce) => __awaiter$1(this, void 0, void 0, function* () {
              if (done) {
                return;
              }
              if (nonce <= replaceable.nonce) {
                lastBlockNumber = blockNumber;
              } else {
                {
                  const mined = yield this.getTransaction(transactionHash);
                  if (mined && mined.blockNumber != null) {
                    return;
                  }
                }
                if (scannedBlock == null) {
                  scannedBlock = lastBlockNumber - 3;
                  if (scannedBlock < replaceable.startBlock) {
                    scannedBlock = replaceable.startBlock;
                  }
                }
                while (scannedBlock <= blockNumber) {
                  if (done) {
                    return;
                  }
                  const block = yield this.getBlockWithTransactions(scannedBlock);
                  for (let ti = 0; ti < block.transactions.length; ti++) {
                    const tx = block.transactions[ti];
                    if (tx.hash === transactionHash) {
                      return;
                    }
                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                      if (done) {
                        return;
                      }
                      const receipt2 = yield this.waitForTransaction(tx.hash, confirmations);
                      if (alreadyDone()) {
                        return;
                      }
                      let reason = "replaced";
                      if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                        reason = "repriced";
                      } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                        reason = "cancelled";
                      }
                      reject(logger$2.makeError("transaction was replaced", Logger.errors.TRANSACTION_REPLACED, {
                        cancelled: reason === "replaced" || reason === "cancelled",
                        reason,
                        replacement: this._wrapTransaction(tx),
                        hash: transactionHash,
                        receipt: receipt2
                      }));
                      return;
                    }
                  }
                  scannedBlock++;
                }
              }
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            }), (error) => {
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            });
          });
          if (done) {
            return;
          }
          this.once("block", replaceHandler);
          cancelFuncs.push(() => {
            this.removeListener("block", replaceHandler);
          });
        }
        if (typeof timeout === "number" && timeout > 0) {
          const timer2 = setTimeout(() => {
            if (alreadyDone()) {
              return;
            }
            reject(logger$2.makeError("timeout exceeded", Logger.errors.TIMEOUT, { timeout }));
          }, timeout);
          if (timer2.unref) {
            timer2.unref();
          }
          cancelFuncs.push(() => {
            clearTimeout(timer2);
          });
        }
      });
    });
  }
  getBlockNumber() {
    return __awaiter$1(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const result = yield this.perform("getGasPrice", {});
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result,
          error
        });
      }
    });
  }
  getBalance(addressOrName, blockTag) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getBalance", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getBalance",
          params,
          result,
          error
        });
      }
    });
  }
  getTransactionCount(addressOrName, blockTag) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getTransactionCount", params);
      try {
        return BigNumber.from(result).toNumber();
      } catch (error) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params,
          result,
          error
        });
      }
    });
  }
  getCode(addressOrName, blockTag) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getCode", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getCode",
          params,
          result,
          error
        });
      }
    });
  }
  getStorageAt(addressOrName, position, blockTag) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag),
        position: Promise.resolve(position).then((p2) => hexValue(p2))
      });
      const result = yield this.perform("getStorageAt", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params,
          result,
          error
        });
      }
    });
  }
  _wrapTransaction(tx, hash2, startBlock) {
    if (hash2 != null && hexDataLength(hash2) !== 32) {
      throw new Error("invalid response - sendTransaction");
    }
    const result = tx;
    if (hash2 != null && tx.hash !== hash2) {
      logger$2.throwError("Transaction hash mismatch from Provider.sendTransaction.", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash2 });
    }
    result.wait = (confirms, timeout) => __awaiter$1(this, void 0, void 0, function* () {
      if (confirms == null) {
        confirms = 1;
      }
      if (timeout == null) {
        timeout = 0;
      }
      let replacement = void 0;
      if (confirms !== 0 && startBlock != null) {
        replacement = {
          data: tx.data,
          from: tx.from,
          nonce: tx.nonce,
          to: tx.to,
          value: tx.value,
          startBlock
        };
      }
      const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);
      if (receipt == null && confirms === 0) {
        return null;
      }
      this._emitted["t:" + tx.hash] = receipt.blockNumber;
      if (receipt.status === 0) {
        logger$2.throwError("transaction failed", Logger.errors.CALL_EXCEPTION, {
          transactionHash: tx.hash,
          transaction: tx,
          receipt
        });
      }
      return receipt;
    });
    return result;
  }
  sendTransaction(signedTransaction) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const hexTx = yield Promise.resolve(signedTransaction).then((t2) => hexlify(t2));
      const tx = this.formatter.transaction(signedTransaction);
      if (tx.confirmations == null) {
        tx.confirmations = 0;
      }
      const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const hash2 = yield this.perform("sendTransaction", { signedTransaction: hexTx });
        return this._wrapTransaction(tx, hash2, blockNumber);
      } catch (error) {
        error.transaction = tx;
        error.transactionHash = tx.hash;
        throw error;
      }
    });
  }
  _getTransactionRequest(transaction) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const values = yield transaction;
      const tx = {};
      ["from", "to"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v2) => v2 ? this._getAddress(v2) : null);
      });
      ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v2) => v2 ? BigNumber.from(v2) : null);
      });
      ["type"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v2) => v2 != null ? v2 : null);
      });
      if (values.accessList) {
        tx.accessList = this.formatter.accessList(values.accessList);
      }
      ["data"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v2) => v2 ? hexlify(v2) : null);
      });
      return this.formatter.transactionRequest(yield resolveProperties(tx));
    });
  }
  _getFilter(filter) {
    return __awaiter$1(this, void 0, void 0, function* () {
      filter = yield filter;
      const result = {};
      if (filter.address != null) {
        result.address = this._getAddress(filter.address);
      }
      ["blockHash", "topics"].forEach((key2) => {
        if (filter[key2] == null) {
          return;
        }
        result[key2] = filter[key2];
      });
      ["fromBlock", "toBlock"].forEach((key2) => {
        if (filter[key2] == null) {
          return;
        }
        result[key2] = this._getBlockTag(filter[key2]);
      });
      return this.formatter.filter(yield resolveProperties(result));
    });
  }
  call(transaction, blockTag) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("call", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "call",
          params,
          result,
          error
        });
      }
    });
  }
  estimateGas(transaction) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction)
      });
      const result = yield this.perform("estimateGas", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "estimateGas",
          params,
          result,
          error
        });
      }
    });
  }
  _getAddress(addressOrName) {
    return __awaiter$1(this, void 0, void 0, function* () {
      addressOrName = yield addressOrName;
      if (typeof addressOrName !== "string") {
        logger$2.throwArgumentError("invalid address or ENS name", "name", addressOrName);
      }
      const address = yield this.resolveName(addressOrName);
      if (address == null) {
        logger$2.throwError("ENS name not configured", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `resolveName(${JSON.stringify(addressOrName)})`
        });
      }
      return address;
    });
  }
  _getBlock(blockHashOrBlockTag, includeTransactions) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      blockHashOrBlockTag = yield blockHashOrBlockTag;
      let blockNumber = -128;
      const params = {
        includeTransactions: !!includeTransactions
      };
      if (isHexString$2(blockHashOrBlockTag, 32)) {
        params.blockHash = blockHashOrBlockTag;
      } else {
        try {
          params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
          if (isHexString$2(params.blockTag)) {
            blockNumber = parseInt(params.blockTag.substring(2), 16);
          }
        } catch (error) {
          logger$2.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
        }
      }
      return poll(() => __awaiter$1(this, void 0, void 0, function* () {
        const block = yield this.perform("getBlock", params);
        if (block == null) {
          if (params.blockHash != null) {
            if (this._emitted["b:" + params.blockHash] == null) {
              return null;
            }
          }
          if (params.blockTag != null) {
            if (blockNumber > this._emitted.block) {
              return null;
            }
          }
          return void 0;
        }
        if (includeTransactions) {
          let blockNumber2 = null;
          for (let i2 = 0; i2 < block.transactions.length; i2++) {
            const tx = block.transactions[i2];
            if (tx.blockNumber == null) {
              tx.confirmations = 0;
            } else if (tx.confirmations == null) {
              if (blockNumber2 == null) {
                blockNumber2 = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
              }
              let confirmations = blockNumber2 - tx.blockNumber + 1;
              if (confirmations <= 0) {
                confirmations = 1;
              }
              tx.confirmations = confirmations;
            }
          }
          const blockWithTxs = this.formatter.blockWithTransactions(block);
          blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));
          return blockWithTxs;
        }
        return this.formatter.block(block);
      }), { oncePoll: this });
    });
  }
  getBlock(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, false);
  }
  getBlockWithTransactions(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, true);
  }
  getTransaction(transactionHash) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter$1(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransaction", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        const tx = this.formatter.transactionResponse(result);
        if (tx.blockNumber == null) {
          tx.confirmations = 0;
        } else if (tx.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - tx.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          tx.confirmations = confirmations;
        }
        return this._wrapTransaction(tx);
      }), { oncePoll: this });
    });
  }
  getTransactionReceipt(transactionHash) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter$1(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransactionReceipt", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        if (result.blockHash == null) {
          return void 0;
        }
        const receipt = this.formatter.receipt(result);
        if (receipt.blockNumber == null) {
          receipt.confirmations = 0;
        } else if (receipt.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - receipt.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          receipt.confirmations = confirmations;
        }
        return receipt;
      }), { oncePoll: this });
    });
  }
  getLogs(filter) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({ filter: this._getFilter(filter) });
      const logs = yield this.perform("getLogs", params);
      logs.forEach((log2) => {
        if (log2.removed == null) {
          log2.removed = false;
        }
      });
      return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
    });
  }
  getEtherPrice() {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      return this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(blockTag) {
    return __awaiter$1(this, void 0, void 0, function* () {
      blockTag = yield blockTag;
      if (typeof blockTag === "number" && blockTag < 0) {
        if (blockTag % 1) {
          logger$2.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
        }
        let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        blockNumber += blockTag;
        if (blockNumber < 0) {
          blockNumber = 0;
        }
        return this.formatter.blockTag(blockNumber);
      }
      return this.formatter.blockTag(blockTag);
    });
  }
  getResolver(name) {
    return __awaiter$1(this, void 0, void 0, function* () {
      try {
        const address = yield this._getResolver(name);
        if (address == null) {
          return null;
        }
        return new Resolver(this, address, name);
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          return null;
        }
        throw error;
      }
    });
  }
  _getResolver(name) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const network = yield this.getNetwork();
      if (!network.ensAddress) {
        logger$2.throwError("network does not support ENS", Logger.errors.UNSUPPORTED_OPERATION, { operation: "ENS", network: network.name });
      }
      const transaction = {
        to: network.ensAddress,
        data: "0x0178b8bf" + namehash(name).substring(2)
      };
      try {
        return this.formatter.callAddress(yield this.call(transaction));
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          return null;
        }
        throw error;
      }
    });
  }
  resolveName(name) {
    return __awaiter$1(this, void 0, void 0, function* () {
      name = yield name;
      try {
        return Promise.resolve(this.formatter.address(name));
      } catch (error) {
        if (isHexString$2(name)) {
          throw error;
        }
      }
      if (typeof name !== "string") {
        logger$2.throwArgumentError("invalid ENS name", "name", name);
      }
      const resolver = yield this.getResolver(name);
      if (!resolver) {
        return null;
      }
      return yield resolver.getAddress();
    });
  }
  lookupAddress(address) {
    return __awaiter$1(this, void 0, void 0, function* () {
      address = yield address;
      address = this.formatter.address(address);
      const reverseName = address.substring(2).toLowerCase() + ".addr.reverse";
      const resolverAddress = yield this._getResolver(reverseName);
      if (!resolverAddress) {
        return null;
      }
      let bytes = arrayify(yield this.call({
        to: resolverAddress,
        data: "0x691f3431" + namehash(reverseName).substring(2)
      }));
      if (bytes.length < 32 || !BigNumber.from(bytes.slice(0, 32)).eq(32)) {
        return null;
      }
      bytes = bytes.slice(32);
      if (bytes.length < 32) {
        return null;
      }
      const length = BigNumber.from(bytes.slice(0, 32)).toNumber();
      bytes = bytes.slice(32);
      if (length > bytes.length) {
        return null;
      }
      const name = toUtf8String(bytes.slice(0, length));
      const addr = yield this.resolveName(name);
      if (addr != address) {
        return null;
      }
      return name;
    });
  }
  getAvatar(nameOrAddress) {
    return __awaiter$1(this, void 0, void 0, function* () {
      let resolver = null;
      if (isHexString$2(nameOrAddress)) {
        const address = this.formatter.address(nameOrAddress);
        const reverseName = address.substring(2).toLowerCase() + ".addr.reverse";
        const resolverAddress = yield this._getResolver(reverseName);
        if (!resolverAddress) {
          return null;
        }
        resolver = new Resolver(this, resolverAddress, "_", address);
      } else {
        resolver = yield this.getResolver(nameOrAddress);
        if (!resolver) {
          return null;
        }
      }
      const avatar = yield resolver.getAvatar();
      if (avatar == null) {
        return null;
      }
      return avatar.url;
    });
  }
  perform(method, params) {
    return logger$2.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
  }
  _startEvent(event) {
    this.polling = this._events.filter((e2) => e2.pollable()).length > 0;
  }
  _stopEvent(event) {
    this.polling = this._events.filter((e2) => e2.pollable()).length > 0;
  }
  _addEventListener(eventName, listener, once3) {
    const event = new Event(getEventTag(eventName), listener, once3);
    this._events.push(event);
    this._startEvent(event);
    return this;
  }
  on(eventName, listener) {
    return this._addEventListener(eventName, listener, false);
  }
  once(eventName, listener) {
    return this._addEventListener(eventName, listener, true);
  }
  emit(eventName, ...args) {
    let result = false;
    let stopped = [];
    let eventTag = getEventTag(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag) {
        return true;
      }
      setTimeout(() => {
        event.listener.apply(this, args);
      }, 0);
      result = true;
      if (event.once) {
        stopped.push(event);
        return false;
      }
      return true;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return result;
  }
  listenerCount(eventName) {
    if (!eventName) {
      return this._events.length;
    }
    let eventTag = getEventTag(eventName);
    return this._events.filter((event) => {
      return event.tag === eventTag;
    }).length;
  }
  listeners(eventName) {
    if (eventName == null) {
      return this._events.map((event) => event.listener);
    }
    let eventTag = getEventTag(eventName);
    return this._events.filter((event) => event.tag === eventTag).map((event) => event.listener);
  }
  off(eventName, listener) {
    if (listener == null) {
      return this.removeAllListeners(eventName);
    }
    const stopped = [];
    let found = false;
    let eventTag = getEventTag(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag || event.listener != listener) {
        return true;
      }
      if (found) {
        return true;
      }
      found = true;
      stopped.push(event);
      return false;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
  removeAllListeners(eventName) {
    let stopped = [];
    if (eventName == null) {
      stopped = this._events;
      this._events = [];
    } else {
      const eventTag = getEventTag(eventName);
      this._events = this._events.filter((event) => {
        if (event.tag !== eventTag) {
          return true;
        }
        stopped.push(event);
        return false;
      });
    }
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
}
var __awaiter = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$1 = new Logger(version$2);
const errorGas = ["call", "estimateGas"];
function checkError(method, error, params) {
  if (method === "call" && error.code === Logger.errors.SERVER_ERROR) {
    const e2 = error.error;
    if (e2 && e2.message.match("reverted") && isHexString$2(e2.data)) {
      return e2.data;
    }
    logger$1.throwError("missing revert data in call exception", Logger.errors.CALL_EXCEPTION, {
      error,
      data: "0x"
    });
  }
  let message = error.message;
  if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof error.error.message === "string") {
    message = error.error.message;
  } else if (typeof error.body === "string") {
    message = error.body;
  } else if (typeof error.responseText === "string") {
    message = error.responseText;
  }
  message = (message || "").toLowerCase();
  const transaction = params.transaction || params.signedTransaction;
  if (message.match(/insufficient funds|base fee exceeds gas limit/)) {
    logger$1.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/nonce too low/)) {
    logger$1.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/replacement transaction underpriced/)) {
    logger$1.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/only replay-protected/)) {
    logger$1.throwError("legacy pre-eip-155 transactions not supported", Logger.errors.UNSUPPORTED_OPERATION, {
      error,
      method,
      transaction
    });
  }
  if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {
    logger$1.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
function timer(timeout) {
  return new Promise(function(resolve2) {
    setTimeout(resolve2, timeout);
  });
}
function getResult(payload) {
  if (payload.error) {
    const error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }
  return payload.result;
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
const _constructorGuard = {};
class JsonRpcSigner extends Signer {
  constructor(constructorGuard, provider, addressOrIndex) {
    logger$1.checkNew(new.target, JsonRpcSigner);
    super();
    if (constructorGuard !== _constructorGuard) {
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    }
    defineReadOnly(this, "provider", provider);
    if (addressOrIndex == null) {
      addressOrIndex = 0;
    }
    if (typeof addressOrIndex === "string") {
      defineReadOnly(this, "_address", this.provider.formatter.address(addressOrIndex));
      defineReadOnly(this, "_index", null);
    } else if (typeof addressOrIndex === "number") {
      defineReadOnly(this, "_index", addressOrIndex);
      defineReadOnly(this, "_address", null);
    } else {
      logger$1.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
    }
  }
  connect(provider) {
    return logger$1.throwError("cannot alter JSON-RPC Signer connection", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }
  connectUnchecked() {
    return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);
  }
  getAddress() {
    if (this._address) {
      return Promise.resolve(this._address);
    }
    return this.provider.send("eth_accounts", []).then((accounts) => {
      if (accounts.length <= this._index) {
        logger$1.throwError("unknown account #" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "getAddress"
        });
      }
      return this.provider.formatter.address(accounts[this._index]);
    });
  }
  sendUncheckedTransaction(transaction) {
    transaction = shallowCopy(transaction);
    const fromAddress = this.getAddress().then((address) => {
      if (address) {
        address = address.toLowerCase();
      }
      return address;
    });
    if (transaction.gasLimit == null) {
      const estimate = shallowCopy(transaction);
      estimate.from = fromAddress;
      transaction.gasLimit = this.provider.estimateGas(estimate);
    }
    if (transaction.to != null) {
      transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter(this, void 0, void 0, function* () {
        if (to == null) {
          return null;
        }
        const address = yield this.provider.resolveName(to);
        if (address == null) {
          logger$1.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
        }
        return address;
      }));
    }
    return resolveProperties({
      tx: resolveProperties(transaction),
      sender: fromAddress
    }).then(({ tx, sender }) => {
      if (tx.from != null) {
        if (tx.from.toLowerCase() !== sender) {
          logger$1.throwArgumentError("from address mismatch", "transaction", transaction);
        }
      } else {
        tx.from = sender;
      }
      const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });
      return this.provider.send("eth_sendTransaction", [hexTx]).then((hash2) => {
        return hash2;
      }, (error) => {
        return checkError("sendTransaction", error, hexTx);
      });
    });
  }
  signTransaction(transaction) {
    return logger$1.throwError("signing transactions is unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }
  sendTransaction(transaction) {
    return __awaiter(this, void 0, void 0, function* () {
      const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
      const hash2 = yield this.sendUncheckedTransaction(transaction);
      try {
        return yield poll(() => __awaiter(this, void 0, void 0, function* () {
          const tx = yield this.provider.getTransaction(hash2);
          if (tx === null) {
            return void 0;
          }
          return this.provider._wrapTransaction(tx, hash2, blockNumber);
        }), { oncePoll: this.provider });
      } catch (error) {
        error.transactionHash = hash2;
        throw error;
      }
    });
  }
  signMessage(message) {
    return __awaiter(this, void 0, void 0, function* () {
      const data2 = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      return yield this.provider.send("personal_sign", [hexlify(data2), address.toLowerCase()]);
    });
  }
  _legacySignMessage(message) {
    return __awaiter(this, void 0, void 0, function* () {
      const data2 = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      return yield this.provider.send("eth_sign", [address.toLowerCase(), hexlify(data2)]);
    });
  }
  _signTypedData(domain2, types, value) {
    return __awaiter(this, void 0, void 0, function* () {
      const populated = yield TypedDataEncoder.resolveNames(domain2, types, value, (name) => {
        return this.provider.resolveName(name);
      });
      const address = yield this.getAddress();
      return yield this.provider.send("eth_signTypedData_v4", [
        address.toLowerCase(),
        JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))
      ]);
    });
  }
  unlock(password) {
    return __awaiter(this, void 0, void 0, function* () {
      const provider = this.provider;
      const address = yield this.getAddress();
      return provider.send("personal_unlockAccount", [address.toLowerCase(), password, null]);
    });
  }
}
class UncheckedJsonRpcSigner extends JsonRpcSigner {
  sendTransaction(transaction) {
    return this.sendUncheckedTransaction(transaction).then((hash2) => {
      return {
        hash: hash2,
        nonce: null,
        gasLimit: null,
        gasPrice: null,
        data: null,
        value: null,
        chainId: null,
        confirmations: 0,
        from: null,
        wait: (confirmations) => {
          return this.provider.waitForTransaction(hash2, confirmations);
        }
      };
    });
  }
}
const allowedTransactionKeys = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true
};
class JsonRpcProvider extends BaseProvider {
  constructor(url, network) {
    logger$1.checkNew(new.target, JsonRpcProvider);
    let networkOrReady = network;
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve2, reject) => {
        setTimeout(() => {
          this.detectNetwork().then((network2) => {
            resolve2(network2);
          }, (error) => {
            reject(error);
          });
        }, 0);
      });
    }
    super(networkOrReady);
    if (!url) {
      url = getStatic(this.constructor, "defaultUrl")();
    }
    if (typeof url === "string") {
      defineReadOnly(this, "connection", Object.freeze({
        url
      }));
    } else {
      defineReadOnly(this, "connection", Object.freeze(shallowCopy(url)));
    }
    this._nextId = 42;
  }
  get _cache() {
    if (this._eventLoopCache == null) {
      this._eventLoopCache = {};
    }
    return this._eventLoopCache;
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    if (!this._cache["detectNetwork"]) {
      this._cache["detectNetwork"] = this._uncachedDetectNetwork();
      setTimeout(() => {
        this._cache["detectNetwork"] = null;
      }, 0);
    }
    return this._cache["detectNetwork"];
  }
  _uncachedDetectNetwork() {
    return __awaiter(this, void 0, void 0, function* () {
      yield timer(0);
      let chainId = null;
      try {
        chainId = yield this.send("eth_chainId", []);
      } catch (error) {
        try {
          chainId = yield this.send("net_version", []);
        } catch (error2) {
        }
      }
      if (chainId != null) {
        const getNetwork2 = getStatic(this.constructor, "getNetwork");
        try {
          return getNetwork2(BigNumber.from(chainId).toNumber());
        } catch (error) {
          return logger$1.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
            chainId,
            event: "invalidNetwork",
            serverError: error
          });
        }
      }
      return logger$1.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }
  getSigner(addressOrIndex) {
    return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);
  }
  getUncheckedSigner(addressOrIndex) {
    return this.getSigner(addressOrIndex).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((accounts) => {
      return accounts.map((a2) => this.formatter.address(a2));
    });
  }
  send(method, params) {
    const request2 = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: deepCopy(request2),
      provider: this
    });
    const cache = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;
    if (cache && this._cache[method]) {
      return this._cache[method];
    }
    const result = fetchJson(this.connection, JSON.stringify(request2), getResult).then((result2) => {
      this.emit("debug", {
        action: "response",
        request: request2,
        response: result2,
        provider: this
      });
      return result2;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        error,
        request: request2,
        provider: this
      });
      throw error;
    });
    if (cache) {
      this._cache[method] = result;
      setTimeout(() => {
        this._cache[method] = null;
      }, 0);
    }
    return result;
  }
  prepareRequest(method, params) {
    switch (method) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
      case "getCode":
        return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [getLowerCase(params.address), params.position, params.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [params.signedTransaction]];
      case "getBlock":
        if (params.blockTag) {
          return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
        } else if (params.blockHash) {
          return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
        }
        return null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [params.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [params.transactionHash]];
      case "call": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
      }
      case "estimateGas": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
      }
      case "getLogs":
        if (params.filter && params.filter.address != null) {
          params.filter.address = getLowerCase(params.filter.address);
        }
        return ["eth_getLogs", [params.filter]];
    }
    return null;
  }
  perform(method, params) {
    return __awaiter(this, void 0, void 0, function* () {
      if (method === "call" || method === "estimateGas") {
        const tx = params.transaction;
        if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {
          if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
            const feeData = yield this.getFeeData();
            if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
              params = shallowCopy(params);
              params.transaction = shallowCopy(tx);
              delete params.transaction.type;
            }
          }
        }
      }
      const args = this.prepareRequest(method, params);
      if (args == null) {
        logger$1.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
      }
      try {
        return yield this.send(args[0], args[1]);
      } catch (error) {
        return checkError(method, error, params);
      }
    });
  }
  _startEvent(event) {
    if (event.tag === "pending") {
      this._startPending();
    }
    super._startEvent(event);
  }
  _startPending() {
    if (this._pendingFilter != null) {
      return;
    }
    const self2 = this;
    const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = pendingFilter;
    pendingFilter.then(function(filterId) {
      function poll2() {
        self2.send("eth_getFilterChanges", [filterId]).then(function(hashes) {
          if (self2._pendingFilter != pendingFilter) {
            return null;
          }
          let seq = Promise.resolve();
          hashes.forEach(function(hash2) {
            self2._emitted["t:" + hash2.toLowerCase()] = "pending";
            seq = seq.then(function() {
              return self2.getTransaction(hash2).then(function(tx) {
                self2.emit("pending", tx);
                return null;
              });
            });
          });
          return seq.then(function() {
            return timer(1e3);
          });
        }).then(function() {
          if (self2._pendingFilter != pendingFilter) {
            self2.send("eth_uninstallFilter", [filterId]);
            return;
          }
          setTimeout(function() {
            poll2();
          }, 0);
          return null;
        }).catch((error) => {
        });
      }
      poll2();
      return filterId;
    }).catch((error) => {
    });
  }
  _stopEvent(event) {
    if (event.tag === "pending" && this.listenerCount("pending") === 0) {
      this._pendingFilter = null;
    }
    super._stopEvent(event);
  }
  static hexlifyTransaction(transaction, allowExtra) {
    const allowed = shallowCopy(allowedTransactionKeys);
    if (allowExtra) {
      for (const key2 in allowExtra) {
        if (allowExtra[key2]) {
          allowed[key2] = true;
        }
      }
    }
    checkProperties(transaction, allowed);
    const result = {};
    ["gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(key2) {
      if (transaction[key2] == null) {
        return;
      }
      const value = hexValue(transaction[key2]);
      if (key2 === "gasLimit") {
        key2 = "gas";
      }
      result[key2] = value;
    });
    ["from", "to", "data"].forEach(function(key2) {
      if (transaction[key2] == null) {
        return;
      }
      result[key2] = hexlify(transaction[key2]);
    });
    if (transaction.accessList) {
      result["accessList"] = accessListify(transaction.accessList);
    }
    return result;
  }
}
const logger = new Logger(version$2);
let _nextId = 1;
function buildWeb3LegacyFetcher(provider, sendFunc) {
  const fetcher = "Web3LegacyFetcher";
  return function(method, params) {
    const request2 = {
      method,
      params,
      id: _nextId++,
      jsonrpc: "2.0"
    };
    return new Promise((resolve2, reject) => {
      this.emit("debug", {
        action: "request",
        fetcher,
        request: deepCopy(request2),
        provider: this
      });
      sendFunc(request2, (error, response) => {
        if (error) {
          this.emit("debug", {
            action: "response",
            fetcher,
            error,
            request: request2,
            provider: this
          });
          return reject(error);
        }
        this.emit("debug", {
          action: "response",
          fetcher,
          request: request2,
          response,
          provider: this
        });
        if (response.error) {
          const error2 = new Error(response.error.message);
          error2.code = response.error.code;
          error2.data = response.error.data;
          return reject(error2);
        }
        resolve2(response.result);
      });
    });
  };
}
function buildEip1193Fetcher(provider) {
  return function(method, params) {
    if (params == null) {
      params = [];
    }
    const request2 = { method, params };
    this.emit("debug", {
      action: "request",
      fetcher: "Eip1193Fetcher",
      request: deepCopy(request2),
      provider: this
    });
    return provider.request(request2).then((response) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request: request2,
        response,
        provider: this
      });
      return response;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request: request2,
        error,
        provider: this
      });
      throw error;
    });
  };
}
class Web3Provider extends JsonRpcProvider {
  constructor(provider, network) {
    logger.checkNew(new.target, Web3Provider);
    if (provider == null) {
      logger.throwArgumentError("missing provider", "provider", provider);
    }
    let path = null;
    let jsonRpcFetchFunc = null;
    let subprovider = null;
    if (typeof provider === "function") {
      path = "unknown:";
      jsonRpcFetchFunc = provider;
    } else {
      path = provider.host || provider.path || "";
      if (!path && provider.isMetaMask) {
        path = "metamask";
      }
      subprovider = provider;
      if (provider.request) {
        if (path === "") {
          path = "eip-1193:";
        }
        jsonRpcFetchFunc = buildEip1193Fetcher(provider);
      } else if (provider.sendAsync) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
      } else if (provider.send) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
      } else {
        logger.throwArgumentError("unsupported provider", "provider", provider);
      }
      if (!path) {
        path = "unknown:";
      }
    }
    super(path, network);
    defineReadOnly(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
    defineReadOnly(this, "provider", subprovider);
  }
  send(method, params) {
    return this.jsonRpcFetchFunc(method, params);
  }
}
class WalletConnectionError extends Error {
  constructor(message) {
    super(message);
    this.name = "WalletConnectionError";
    this.code = 4001;
  }
}
class UnsupportedChainError extends Error {
  constructor(message) {
    super(message);
    this.name = "UnsupportedChainError";
  }
}
class VerificationAbortedError extends Error {
  constructor(message) {
    super(message);
    this.name = "VerificationAbortedError";
    this.code = 4001;
  }
}
class UserRejectedRequestError extends Error {
  constructor() {
    super("User rejected the request.");
    this.name = "UserRejectedRequestError";
    this.code = 4001;
  }
}
class BadRequestError extends Error {
  constructor({ errors, requestId }) {
    super("Provided paramaters are not valid. Please fix validation errors below and try again.");
    this.name = "BadRequestError";
    this.fields = errors.map((field) => `${field.param}: ${field.msg}`);
    this.requestId = requestId;
  }
}
class InvalidCredentialsError extends Error {
  constructor({ requestId }) {
    super("Invalid API key or application is not authorized for use on this domain");
    this.name = "InvalidCredentialsError";
    this.requestId = requestId;
  }
}
class InternalServerError extends Error {
  constructor({ message, requestId }) {
    super(message);
    this.name = "InternalServerError";
    this.requestId = requestId;
  }
}
class RateLimitedError extends Error {
  constructor({ message, requestId }) {
    super(message);
    this.name = "RateLimitedError";
    this.requestId = requestId;
  }
}
class NetworkError extends Error {
  constructor() {
    super("Unable to connect to the Verify API");
    this.name = "NetworkError";
  }
}
class DumbassError extends Error {
  constructor() {
    super("That's your SECRET key, it should NEVER be used on the frontend!");
    this.name = "DumbassError";
  }
}
function makeMap(str, expectsLowerCase) {
  const map = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i2 = 0; i2 < list.length; i2++) {
    map[list[i2]] = true;
  }
  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function normalizeStyle(value) {
  if (isArray$4(value)) {
    const res = {};
    for (let i2 = 0; i2 < value.length; i2++) {
      const item = value[i2];
      const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key2 in normalized) {
          res[key2] = normalized[key2];
        }
      }
    }
    return res;
  } else if (isString$1(value)) {
    return value;
  } else if (isObject$2(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$1(value)) {
    res = value;
  } else if (isArray$4(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      const normalized = normalizeClass(value[i2]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$2(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
const toDisplayString = (val) => {
  return isString$1(val) ? val : val == null ? "" : isArray$4(val) || isObject$2(val) && (val.toString === objectToString || !isFunction$1(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key2, val2]) => {
        entries[`${key2} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject$2(val) && !isArray$4(val) && !isPlainObject$1(val)) {
    return String(val);
  }
  return val;
};
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key2) => onRE.test(key2);
const isModelListener = (key2) => key2.startsWith("onUpdate:");
const extend$1 = Object.assign;
const remove = (arr, el) => {
  const i2 = arr.indexOf(el);
  if (i2 > -1) {
    arr.splice(i2, 1);
  }
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key2) => hasOwnProperty.call(val, key2);
const isArray$4 = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isFunction$1 = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$2 = (val) => val !== null && typeof val === "object";
const isPromise$1 = (val) => {
  return isObject$2(val) && isFunction$1(val.then) && isFunction$1(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key2) => isString$1(key2) && key2 !== "NaN" && key2[0] !== "-" && "" + parseInt(key2, 10) === key2;
const isReservedProp = /* @__PURE__ */ makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i2 = 0; i2 < fns.length; i2++) {
    fns[i2](arg);
  }
};
const def = (obj, key2, value) => {
  Object.defineProperty(obj, key2, {
    configurable: true,
    enumerable: false,
    value
  });
};
const toNumber = (val) => {
  const n2 = parseFloat(val);
  return isNaN(n2) ? val : n2;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : {});
};
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.active = true;
    this.effects = [];
    this.cleanups = [];
    if (!detached && activeEffectScope) {
      this.parent = activeEffectScope;
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  run(fn) {
    if (this.active) {
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = this.parent;
      }
    }
  }
  on() {
    activeEffectScope = this;
  }
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this.active) {
      let i2, l2;
      for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
        this.effects[i2].stop();
      }
      for (i2 = 0, l2 = this.cleanups.length; i2 < l2; i2++) {
        this.cleanups[i2]();
      }
      if (this.scopes) {
        for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
          this.scopes[i2].stop(true);
        }
      }
      if (this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.active = false;
    }
  }
}
function recordEffectScope(effect, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect) => {
  const { deps } = effect;
  if (deps.length) {
    let ptr = 0;
    for (let i2 = 0; i2 < deps.length; i2++) {
      const dep = deps[i2];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
    }
  }
  stop() {
    if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect) {
  const { deps } = effect;
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].delete(effect);
    }
    deps.length = 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key2) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key2);
    if (!dep) {
      depsMap.set(key2, dep = createDep());
    }
    trackEffects(dep);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger(target, type, key2, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key2 === "length" && isArray$4(target)) {
    depsMap.forEach((dep, key3) => {
      if (key3 === "length" || key3 >= newValue) {
        deps.push(dep);
      }
    });
  } else {
    if (key2 !== void 0) {
      deps.push(depsMap.get(key2));
    }
    switch (type) {
      case "add":
        if (!isArray$4(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key2)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$4(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  for (const effect of isArray$4(dep) ? dep : [...dep]) {
    if (effect !== activeEffect || effect.allowRecurse) {
      if (effect.scheduler) {
        effect.scheduler();
      } else {
        effect.run();
      }
    }
  }
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key2) => Symbol[key2]).filter(isSymbol));
const get = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key2) => {
    instrumentations[key2] = function(...args) {
      const arr = toRaw(this);
      for (let i2 = 0, l2 = this.length; i2 < l2; i2++) {
        track(arr, "get", i2 + "");
      }
      const res = arr[key2](...args);
      if (res === -1 || res === false) {
        return arr[key2](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key2) => {
    instrumentations[key2] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key2].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get3(target, key2, receiver) {
    if (key2 === "__v_isReactive") {
      return !isReadonly2;
    } else if (key2 === "__v_isReadonly") {
      return isReadonly2;
    } else if (key2 === "__v_isShallow") {
      return shallow;
    } else if (key2 === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray$4(target);
    if (!isReadonly2 && targetIsArray && hasOwn(arrayInstrumentations, key2)) {
      return Reflect.get(arrayInstrumentations, key2, receiver);
    }
    const res = Reflect.get(target, key2, receiver);
    if (isSymbol(key2) ? builtInSymbols.has(key2) : isNonTrackableKeys(key2)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key2);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      const shouldUnwrap = !targetIsArray || !isIntegerKey(key2);
      return shouldUnwrap ? res.value : res;
    }
    if (isObject$2(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target, key2, value, receiver) {
    let oldValue = target[key2];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow && !isReadonly(value)) {
      if (!isShallow(value)) {
        value = toRaw(value);
        oldValue = toRaw(oldValue);
      }
      if (!isArray$4(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray$4(target) && isIntegerKey(key2) ? Number(key2) < target.length : hasOwn(target, key2);
    const result = Reflect.set(target, key2, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key2, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key2, value);
      }
    }
    return result;
  };
}
function deleteProperty(target, key2) {
  const hadKey = hasOwn(target, key2);
  target[key2];
  const result = Reflect.deleteProperty(target, key2);
  if (result && hadKey) {
    trigger(target, "delete", key2, void 0);
  }
  return result;
}
function has(target, key2) {
  const result = Reflect.has(target, key2);
  if (!isSymbol(key2) || !builtInSymbols.has(key2)) {
    track(target, "has", key2);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", isArray$4(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get,
  set,
  deleteProperty,
  has,
  ownKeys
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key2) {
    return true;
  },
  deleteProperty(target, key2) {
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend$1({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
});
const toShallow = (value) => value;
const getProto = (v2) => Reflect.getPrototypeOf(v2);
function get$1(target, key2, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key2);
  if (key2 !== rawKey) {
    !isReadonly2 && track(rawTarget, "get", key2);
  }
  !isReadonly2 && track(rawTarget, "get", rawKey);
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key2)) {
    return wrap(target.get(key2));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key2);
  }
}
function has$1(key2, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key2);
  if (key2 !== rawKey) {
    !isReadonly2 && track(rawTarget, "has", key2);
  }
  !isReadonly2 && track(rawTarget, "has", rawKey);
  return key2 === rawKey ? target.has(key2) : target.has(key2) || target.has(rawKey);
}
function size$1(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add3(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set$1(key2, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get3 } = getProto(target);
  let hadKey = has2.call(target, key2);
  if (!hadKey) {
    key2 = toRaw(key2);
    hadKey = has2.call(target, key2);
  }
  const oldValue = get3.call(target, key2);
  target.set(key2, value);
  if (!hadKey) {
    trigger(target, "add", key2, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key2, value);
  }
  return this;
}
function deleteEntry(key2) {
  const target = toRaw(this);
  const { has: has2, get: get3 } = getProto(target);
  let hadKey = has2.call(target, key2);
  if (!hadKey) {
    key2 = toRaw(key2);
    hadKey = has2.call(target, key2);
  }
  get3 ? get3.call(target, key2) : void 0;
  const result = target.delete(key2);
  if (hadKey) {
    trigger(target, "delete", key2, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach3(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key2) => {
      return callback.call(thisArg, wrap(value), wrap(key2), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key2) {
      return get$1(this, key2);
    },
    get size() {
      return size$1(this);
    },
    has: has$1,
    add: add3,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key2) {
      return get$1(this, key2, false, true);
    },
    get size() {
      return size$1(this);
    },
    has: has$1,
    add: add3,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key2) {
      return get$1(this, key2, true);
    },
    get size() {
      return size$1(this, true);
    },
    has(key2) {
      return has$1.call(this, key2, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key2) {
      return get$1(this, key2, true, true);
    },
    get size() {
      return size$1(this, true);
    },
    has(key2) {
      return has$1.call(this, key2, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key2, receiver) => {
    if (key2 === "__v_isReactive") {
      return !isReadonly2;
    } else if (key2 === "__v_isReadonly") {
      return isReadonly2;
    } else if (key2 === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn(instrumentations, key2) && key2 in target ? instrumentations : target, key2, receiver);
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$2(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject$2(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$2(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  if (ref2.dep) {
    {
      triggerEffects(ref2.dep);
    }
  }
}
function isRef(r2) {
  return !!(r2 && r2.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    newVal = this.__v_isShallow ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = this.__v_isShallow ? newVal : toReactive(newVal);
      triggerRefValue(this);
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key2, receiver) => unref(Reflect.get(target, key2, receiver)),
  set: (target, key2, value, receiver) => {
    const oldValue = target[key2];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key2, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$1(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
Promise.resolve();
function callWithErrorHandling(fn, instance, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$1(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise$1(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i2 = 0; i2 < fn.length; i2++) {
    values.push(callWithAsyncErrorHandling(fn[i2], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
          if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPreFlushCbs = [];
let activePreFlushCbs = null;
let preFlushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = Promise.resolve();
let currentFlushPromise = null;
let currentPreFlushParentJob = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id2) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id2 ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if ((!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) && job !== currentPreFlushParentJob) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i2 = queue.indexOf(job);
  if (i2 > flushIndex) {
    queue.splice(i2, 1);
  }
}
function queueCb(cb, activeQueue, pendingQueue, index2) {
  if (!isArray$4(cb)) {
    if (!activeQueue || !activeQueue.includes(cb, cb.allowRecurse ? index2 + 1 : index2)) {
      pendingQueue.push(cb);
    }
  } else {
    pendingQueue.push(...cb);
  }
  queueFlush();
}
function queuePreFlushCb(cb) {
  queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}
function queuePostFlushCb(cb) {
  queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}
function flushPreFlushCbs(seen, parentJob = null) {
  if (pendingPreFlushCbs.length) {
    currentPreFlushParentJob = parentJob;
    activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
    pendingPreFlushCbs.length = 0;
    for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
      activePreFlushCbs[preFlushIndex]();
    }
    activePreFlushCbs = null;
    preFlushIndex = 0;
    currentPreFlushParentJob = null;
    flushPreFlushCbs(seen, parentJob);
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a2, b2) => getId(a2) - getId(b2));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  flushPreFlushCbs(seen);
  queue.sort((a2, b2) => getId(a2) - getId(b2));
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPreFlushCbs.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}
function emit$1(instance, event, ...rawArgs) {
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim: trim2 } = props[modifiersKey] || EMPTY_OBJ;
    if (trim2) {
      args = rawArgs.map((a2) => a2.trim());
    } else if (number) {
      args = rawArgs.map(toNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6, args);
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6, args);
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$1(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    cache.set(comp, null);
    return null;
  }
  if (isArray$4(raw)) {
    raw.forEach((key2) => normalized[key2] = null);
  } else {
    extend$1(normalized, raw);
  }
  cache.set(comp, normalized);
  return normalized;
}
function isEmitListener(options, key2) {
  if (!options || !isOn(key2)) {
    return false;
  }
  key2 = key2.slice(2).replace(/Once$/, "");
  return hasOwn(options, key2[0].toLowerCase() + key2.slice(1)) || hasOwn(options, hyphenate(key2)) || hasOwn(options, key2);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id2) {
  currentScopeId = id2;
}
function popScopeId() {
  currentScopeId = null;
}
const withScopeId = (_id) => withCtx;
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    const res = fn(...args);
    setCurrentRenderingInstance(prevInstance);
    if (renderFnWithContext._d) {
      setBlockTracking(1);
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit: emit3, render: render3, renderCache, data: data2, setupState, ctx, inheritAttrs } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(render3.call(proxyToUse, proxyToUse, renderCache, props, setupState, data2, ctx));
      fallthroughAttrs = attrs;
    } else {
      const render4 = Component;
      if (false)
        ;
      result = normalizeVNode(render4.length > 1 ? render4(props, false ? {
        get attrs() {
          markAttrsAccessed();
          return attrs;
        },
        slots,
        emit: emit3
      } : { attrs, slots, emit: emit3 }) : render4(props, null));
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment$1);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
        }
        root = cloneVNode(root, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root.transition = vnode.transition;
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key2 in attrs) {
    if (key2 === "class" || key2 === "style" || isOn(key2)) {
      (res || (res = {}))[key2] = attrs[key2];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key2 in attrs) {
    if (!isModelListener(key2) || !(key2.slice(9) in props)) {
      res[key2] = attrs[key2];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i2 = 0; i2 < dynamicProps.length; i2++) {
        const key2 = dynamicProps[i2];
        if (nextProps[key2] !== prevProps[key2] && !isEmitListener(emits, key2)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i2 = 0; i2 < nextKeys.length; i2++) {
    const key2 = nextKeys[i2];
    if (nextProps[key2] !== prevProps[key2] && !isEmitListener(emitsOptions, key2)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$4(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function provide(key2, value) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key2] = value;
  }
}
function inject(key2, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance) {
    const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
    if (provides && key2 in provides) {
      return provides[key2];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
    } else
      ;
  }
}
function watchEffect(effect, options) {
  return doWatch(effect, null, options);
}
const INITIAL_WATCHER_VALUE = {};
function watch(source2, cb, options) {
  return doWatch(source2, cb, options);
}
function doWatch(source2, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  const instance = currentInstance;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source2)) {
    getter = () => source2.value;
    forceTrigger = isShallow(source2);
  } else if (isReactive(source2)) {
    getter = () => source2;
    deep = true;
  } else if (isArray$4(source2)) {
    isMultiSource = true;
    forceTrigger = source2.some(isReactive);
    getter = () => source2.map((s2) => {
      if (isRef(s2)) {
        return s2.value;
      } else if (isReactive(s2)) {
        return traverse(s2);
      } else if (isFunction$1(s2)) {
        return callWithErrorHandling(s2, instance, 2);
      } else
        ;
    });
  } else if (isFunction$1(source2)) {
    if (cb) {
      getter = () => callWithErrorHandling(source2, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(source2, instance, 3, [onCleanup]);
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
    };
  };
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    return NOOP;
  }
  let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i2) => hasChanged(v2, oldValue[i2])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    scheduler = () => {
      if (!instance || instance.isMounted) {
        queuePreFlushCb(job);
      } else {
        job();
      }
    };
  }
  const effect = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
  } else {
    effect.run();
  }
  return () => {
    effect.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect);
    }
  };
}
function instanceWatch(source2, value, options) {
  const publicThis = this.proxy;
  const getter = isString$1(source2) ? source2.includes(".") ? createPathGetter(publicThis, source2) : () => publicThis[source2] : source2.bind(publicThis, publicThis);
  let cb;
  if (isFunction$1(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments2 = path.split(".");
  return () => {
    let cur = ctx;
    for (let i2 = 0; i2 < segments2.length && cur; i2++) {
      cur = cur[segments2[i2]];
    }
    return cur;
  };
}
function traverse(value, seen) {
  if (!isObject$2(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, seen);
  } else if (isArray$4(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      traverse(value[i2], seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v2) => {
      traverse(v2, seen);
    });
  } else if (isPlainObject$1(value)) {
    for (const key2 in value) {
      traverse(value[key2], seen);
    }
  }
  return value;
}
function defineComponent(options) {
  return isFunction$1(options) ? { setup: options, name: options.name } : options;
}
const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(type, hook, keepAliveRoot, true);
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, hook, target);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook(options.beforeCreate, instance, "bc");
  }
  const {
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render: render3,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    expose,
    inheritAttrs,
    components,
    directives: directives2,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
  }
  if (methods) {
    for (const key2 in methods) {
      const methodHandler = methods[key2];
      if (isFunction$1(methodHandler)) {
        {
          ctx[key2] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data2 = dataOptions.call(publicThis, publicThis);
    if (!isObject$2(data2))
      ;
    else {
      instance.data = reactive(data2);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key2 in computedOptions) {
      const opt = computedOptions[key2];
      const get3 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c2 = computed({
        get: get3,
        set: set2
      });
      Object.defineProperty(ctx, key2, {
        enumerable: true,
        configurable: true,
        get: () => c2.value,
        set: (v2) => c2.value = v2
      });
    }
  }
  if (watchOptions) {
    for (const key2 in watchOptions) {
      createWatcher(watchOptions[key2], ctx, publicThis, key2);
    }
  }
  if (provideOptions) {
    const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key2) => {
      provide(key2, provides[key2]);
    });
  }
  if (created) {
    callHook(created, instance, "c");
  }
  function registerLifecycleHook(register2, hook) {
    if (isArray$4(hook)) {
      hook.forEach((_hook) => register2(_hook.bind(publicThis)));
    } else if (hook) {
      register2(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$4(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key2) => {
        Object.defineProperty(exposed, key2, {
          get: () => publicThis[key2],
          set: (val) => publicThis[key2] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render3 && instance.render === NOOP) {
    instance.render = render3;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives2)
    instance.directives = directives2;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
  if (isArray$4(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key2 in injectOptions) {
    const opt = injectOptions[key2];
    let injected;
    if (isObject$2(opt)) {
      if ("default" in opt) {
        injected = inject(opt.from || key2, opt.default, true);
      } else {
        injected = inject(opt.from || key2);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      if (unwrapRef) {
        Object.defineProperty(ctx, key2, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v2) => injected.value = v2
        });
      } else {
        ctx[key2] = injected;
      }
    } else {
      ctx[key2] = injected;
    }
  }
}
function callHook(hook, instance, type) {
  callWithAsyncErrorHandling(isArray$4(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key2) {
  const getter = key2.includes(".") ? createPathGetter(publicThis, key2) : () => publicThis[key2];
  if (isString$1(raw)) {
    const handler = ctx[raw];
    if (isFunction$1(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction$1(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$2(raw)) {
    if (isArray$4(raw)) {
      raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key2));
    } else {
      const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$1(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base2 = instance.type;
  const { mixins, extends: extendsOptions } = base2;
  const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
  const cached = cache.get(base2);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base2;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach((m2) => mergeOptions(resolved, m2, optionMergeStrategies, true));
    }
    mergeOptions(resolved, base2, optionMergeStrategies);
  }
  cache.set(base2, resolved);
  return resolved;
}
function mergeOptions(to, from2, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from2;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach((m2) => mergeOptions(to, m2, strats, true));
  }
  for (const key2 in from2) {
    if (asMixin && key2 === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key2] || strats && strats[key2];
      to[key2] = strat ? strat(to[key2], from2[key2]) : from2[key2];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  watch: mergeWatchOptions,
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from2) {
  if (!from2) {
    return to;
  }
  if (!to) {
    return from2;
  }
  return function mergedDataFn() {
    return extend$1(isFunction$1(to) ? to.call(this, this) : to, isFunction$1(from2) ? from2.call(this, this) : from2);
  };
}
function mergeInject(to, from2) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from2));
}
function normalizeInject(raw) {
  if (isArray$4(raw)) {
    const res = {};
    for (let i2 = 0; i2 < raw.length; i2++) {
      res[raw[i2]] = raw[i2];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from2) {
  return to ? [...new Set([].concat(to, from2))] : from2;
}
function mergeObjectOptions(to, from2) {
  return to ? extend$1(extend$1(/* @__PURE__ */ Object.create(null), to), from2) : from2;
}
function mergeWatchOptions(to, from2) {
  if (!to)
    return from2;
  if (!from2)
    return to;
  const merged = extend$1(/* @__PURE__ */ Object.create(null), to);
  for (const key2 in from2) {
    merged[key2] = mergeAsArray(to[key2], from2[key2]);
  }
  return merged;
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key2 in instance.propsOptions[0]) {
    if (!(key2 in props)) {
      props[key2] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const { props, attrs, vnode: { patchFlag } } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if ((optimized || patchFlag > 0) && !(patchFlag & 16)) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
        let key2 = propsToUpdate[i2];
        const value = rawProps[key2];
        if (options) {
          if (hasOwn(attrs, key2)) {
            if (value !== attrs[key2]) {
              attrs[key2] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key2);
            props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false);
          }
        } else {
          if (value !== attrs[key2]) {
            attrs[key2] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key2 in rawCurrentProps) {
      if (!rawProps || !hasOwn(rawProps, key2) && ((kebabKey = hyphenate(key2)) === key2 || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && (rawPrevProps[key2] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
            props[key2] = resolvePropValue(options, rawCurrentProps, key2, void 0, instance, true);
          }
        } else {
          delete props[key2];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key2 in attrs) {
        if (!rawProps || !hasOwn(rawProps, key2) && true) {
          delete attrs[key2];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key2 in rawProps) {
      if (isReservedProp(key2)) {
        continue;
      }
      const value = rawProps[key2];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key2))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key2)) {
        if (!(key2 in attrs) || value !== attrs[key2]) {
          attrs[key2] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i2 = 0; i2 < needCastKeys.length; i2++) {
      const key2 = needCastKeys[i2];
      props[key2] = resolvePropValue(options, rawCurrentProps, key2, castValues[key2], instance, !hasOwn(castValues, key2));
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key2, value, instance, isAbsent) {
  const opt = options[key2];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && isFunction$1(defaultValue)) {
        const { propsDefaults } = instance;
        if (key2 in propsDefaults) {
          value = propsDefaults[key2];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key2] = defaultValue.call(null, props);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[0]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1] && (value === "" || value === hyphenate(key2))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend$1(normalized, props);
      if (keys)
        needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    cache.set(comp, EMPTY_ARR);
    return EMPTY_ARR;
  }
  if (isArray$4(raw)) {
    for (let i2 = 0; i2 < raw.length; i2++) {
      const normalizedKey = camelize(raw[i2]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key2 in raw) {
      const normalizedKey = camelize(key2);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key2];
        const prop = normalized[normalizedKey] = isArray$4(opt) || isFunction$1(opt) ? { type: opt } : opt;
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[0] = booleanIndex > -1;
          prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  cache.set(comp, res);
  return res;
}
function validatePropName(key2) {
  if (key2[0] !== "$") {
    return true;
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ctor === null ? "null" : "";
}
function isSameType(a2, b2) {
  return getType(a2) === getType(b2);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray$4(expectedTypes)) {
    return expectedTypes.findIndex((t2) => isSameType(t2, type));
  } else if (isFunction$1(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key2) => key2[0] === "_" || key2 === "$stable";
const normalizeSlotValue = (value) => isArray$4(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key2, rawSlot, ctx) => {
  const normalized = withCtx((...args) => {
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key2 in rawSlots) {
    if (isInternalKey(key2))
      continue;
    const value = rawSlots[key2];
    if (isFunction$1(value)) {
      slots[key2] = normalizeSlot(key2, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key2] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(children, instance.slots = {});
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend$1(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key2 in slots) {
      if (!isInternalKey(key2) && !(key2 in deletionComparisonTarget)) {
        delete slots[key2];
      }
    }
  }
};
function withDirectives(vnode, directives2) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    return vnode;
  }
  const instance = internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i2 = 0; i2 < directives2.length; i2++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives2[i2];
    if (isFunction$1(dir)) {
      dir = {
        mounted: dir,
        updated: dir
      };
    }
    if (dir.deep) {
      traverse(value);
    }
    bindings.push({
      dir,
      instance,
      value,
      oldValue: void 0,
      arg,
      modifiers
    });
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i2 = 0; i2 < bindings.length; i2++) {
    const binding2 = bindings[i2];
    if (oldBindings) {
      binding2.oldValue = oldBindings[i2].value;
    }
    let hook = binding2.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding2,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render3, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (rootProps != null && !isObject$2(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version: version$1,
      get config() {
        return context.config;
      },
      set config(v2) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin))
          ;
        else if (plugin && isFunction$1(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction$1(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else
          ;
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render3(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render3(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key2, value) {
        context.provides[key2] = value;
        return app;
      }
    };
    return app;
  };
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$4(rawRef)) {
    rawRef.forEach((r2, i2) => setRef(r2, oldRawRef && (isArray$4(oldRawRef) ? oldRawRef[i2] : oldRawRef), parentSuspense, vnode, isUnmount));
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString$1(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$1(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value, refs]);
  } else {
    const _isString = isString$1(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray$4(existing) && remove(existing, refValue);
          } else {
            if (!isArray$4(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value;
          if (hasOwn(setupState, ref2)) {
            setupState[ref2] = value;
          }
        } else if (isRef(ref2)) {
          ref2.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else
          ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref2, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment$1:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        }
        break;
      case Fragment:
        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;
      default:
        if (shapeFlag & 1) {
          processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 6) {
          processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 64) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (shapeFlag & 128) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else
          ;
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;
    if (vnode.el && hostCloneNode !== void 0 && patchFlag === -1) {
      el = vnode.el = hostCloneNode(vnode.el);
    } else {
      el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      if (props) {
        for (const key2 in props) {
          if (key2 !== "value" && !isReservedProp(key2)) {
            hostPatchProp(el, key2, null, props[key2], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
        if ("value" in props) {
          hostPatchProp(el, "value", null, props.value);
        }
        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
        hostSetScopeId(el, slotScopeIds[i2]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
    } else if (!optimized) {
      patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            const key2 = propsToUpdate[i2];
            const prev = oldProps[key2];
            const next = newProps[key2];
            if (next !== prev || key2 === "value") {
              hostPatchProp(el, key2, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i2 = 0; i2 < newChildren.length; i2++) {
      const oldVNode = oldChildren[i2];
      const newVNode = newChildren[i2];
      const container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      for (const key2 in newProps) {
        if (isReservedProp(key2))
          continue;
        const next = newProps[key2];
        const prev = oldProps[key2];
        if (next !== prev && key2 !== "value") {
          hostPatchProp(el, key2, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if (oldProps !== EMPTY_OBJ) {
        for (const key2 in oldProps) {
          if (!isReservedProp(key2) && !(key2 in newProps)) {
            hostPatchProp(el, key2, oldProps[key2], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
        if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
          traverseStaticChildren(n1, n2, true);
        }
      } else {
        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
      } else {
        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment$1);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.component = n1.component;
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m: m2, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(el, instance.subTree, instance, parentSuspense, null);
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(() => !instance.isUnmounted && hydrateSubTree());
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
          initialVNode.el = subTree.el;
        }
        if (m2) {
          queuePostRenderEffect(m2, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
        }
        if (initialVNode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u: u2, parent, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(prevTree, nextTree, hostParentNode(prevTree.el), getNextHostNode(prevTree), instance, parentSuspense, isSVG);
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u2) {
          queuePostRenderEffect(u2, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
        }
      }
    };
    const effect = instance.effect = new ReactiveEffect(componentUpdateFn, () => queueJob(instance.update), instance.scope);
    const update7 = instance.update = effect.run.bind(effect);
    update7.id = instance.uid;
    toggleRecurse(instance, true);
    update7();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(void 0, instance.update);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i2;
    for (i2 = 0; i2 < commonLength; i2++) {
      const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      patch(c1[i2], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
    if (oldLength > newLength) {
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i2 = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[i2];
      const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      i2++;
    }
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i2 > e1) {
      if (i2 <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i2 <= e2) {
          patch(null, c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i2++;
        }
      }
    } else if (i2 > e2) {
      while (i2 <= e1) {
        unmount(c1[i2], parentComponent, parentSuspense, true);
        i2++;
      }
    } else {
      const s1 = i2;
      const s2 = i2;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i2 = s2; i2 <= e2; i2++) {
        const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i2);
        }
      }
      let j2;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i2 = 0; i2 < toBePatched; i2++)
        newIndexToOldIndexMap[i2] = 0;
      for (i2 = s1; i2 <= e1; i2++) {
        const prevChild = c1[i2];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j2 = s2; j2 <= e2; j2++) {
            if (newIndexToOldIndexMap[j2 - s2] === 0 && isSameVNodeType(prevChild, c2[j2])) {
              newIndex = j2;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j2 = increasingNewIndexSequence.length - 1;
      for (i2 = toBePatched - 1; i2 >= 0; i2--) {
        const nextIndex = s2 + i2;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i2] === 0) {
          patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (moved) {
          if (j2 < 0 || i2 !== increasingNewIndexSequence[j2]) {
            move(nextChild, container, anchor, 2);
          } else {
            j2--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i2 = 0; i2 < children.length; i2++) {
        move(children[i2], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove3 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove3();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove3, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const { type, props, ref: ref2, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
      } else if (dynamicChildren && (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      removeFragment(el, anchor);
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update: update7, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update7) {
      update7.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render3 = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(internals);
  }
  return {
    render: render3,
    hydrate,
    createApp: createAppAPI(render3, hydrate)
  };
}
function toggleRecurse({ effect, update: update7 }, allowed) {
  effect.allowRecurse = update7.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$4(ch1) && isArray$4(ch2)) {
    for (let i2 = 0; i2 < ch1.length; i2++) {
      const c1 = ch1[i2];
      let c2 = ch2[i2];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i2, j2, u2, v2, c2;
  const len = arr.length;
  for (i2 = 0; i2 < len; i2++) {
    const arrI = arr[i2];
    if (arrI !== 0) {
      j2 = result[result.length - 1];
      if (arr[j2] < arrI) {
        p2[i2] = j2;
        result.push(i2);
        continue;
      }
      u2 = 0;
      v2 = result.length - 1;
      while (u2 < v2) {
        c2 = u2 + v2 >> 1;
        if (arr[result[c2]] < arrI) {
          u2 = c2 + 1;
        } else {
          v2 = c2;
        }
      }
      if (arrI < arr[result[u2]]) {
        if (u2 > 0) {
          p2[i2] = result[u2 - 1];
        }
        result[u2] = i2;
      }
    }
  }
  u2 = result.length;
  v2 = result[u2 - 1];
  while (u2-- > 0) {
    result[u2] = v2;
    v2 = p2[v2];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString$1(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
    const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const target = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target) {
        insert(targetAnchor, target);
        isSVG = isSVG || isTargetSVG(target);
      }
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(children, container2, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
      } else if (target) {
        mount(target, targetAnchor);
      }
    } else {
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      isSVG = isSVG || isTargetSVG(target);
      if (dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(n2, container, mainAnchor, internals, 1);
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
          if (nextTarget) {
            moveTeleport(n2, nextTarget, null, internals, 0);
          }
        } else if (wasDisabled) {
          moveTeleport(n2, target, targetAnchor, internals, 1);
        }
      }
    }
  },
  remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
    if (target) {
      hostRemove(targetAnchor);
    }
    if (doRemove || !isTeleportDisabled(props)) {
      hostRemove(anchor);
      if (shapeFlag & 16) {
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
        }
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i2 = 0; i2 < children.length; i2++) {
        move(children[i2], container, parentAnchor, 2);
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
  const target = vnode.target = resolveTarget(vnode.props, querySelector);
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        vnode.targetAnchor = hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
      }
      target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
    }
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol();
function resolveDynamicComponent(component) {
  if (isString$1(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(Component);
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
        return Component;
      }
    }
    const res = resolve(instance[type] || Component[type], name) || resolve(instance.appContext[type], name);
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
}
const Fragment = Symbol(void 0);
const Text = Symbol(void 0);
const Comment$1 = Symbol(void 0);
const Static = Symbol(void 0);
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true));
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true));
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key: key2 }) => key2 != null ? key2 : null;
const normalizeRef = ({ ref: ref2, ref_key, ref_for }) => {
  return ref2 != null ? isString$1(ref2) || isRef(ref2) || isFunction$1(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$1(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment$1;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(type, props, true);
    if (children) {
      normalizeChildren(cloned, children);
    }
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style: style2 } = props;
    if (klass && !isString$1(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$2(style2)) {
      if (isProxy(style2) && !isArray$4(style2)) {
        style2 = extend$1({}, style2);
      }
      props.style = normalizeStyle(style2);
    }
  }
  const shapeFlag = isString$1(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$2(type) ? 4 : isFunction$1(type) ? 2 : 0;
  return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend$1({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref: ref2, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray$4(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment$1, null, text)) : createVNode(Comment$1, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment$1);
  } else if (isArray$4(child)) {
    return createVNode(Fragment, null, child.slice());
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$4(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$1(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMerge = args[i2];
    for (const key2 in toMerge) {
      if (key2 === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key2 === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key2)) {
        const existing = ret[key2];
        const incoming = toMerge[key2];
        if (incoming && existing !== incoming && !(isArray$4(existing) && existing.includes(incoming))) {
          ret[key2] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key2 !== "") {
        ret[key2] = toMerge[key2];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
function renderList(source2, renderItem, cache, index2) {
  let ret;
  const cached = cache && cache[index2];
  if (isArray$4(source2) || isString$1(source2)) {
    ret = new Array(source2.length);
    for (let i2 = 0, l2 = source2.length; i2 < l2; i2++) {
      ret[i2] = renderItem(source2[i2], i2, void 0, cached && cached[i2]);
    }
  } else if (typeof source2 === "number") {
    ret = new Array(source2);
    for (let i2 = 0; i2 < source2; i2++) {
      ret[i2] = renderItem(i2 + 1, i2, void 0, cached && cached[i2]);
    }
  } else if (isObject$2(source2)) {
    if (source2[Symbol.iterator]) {
      ret = Array.from(source2, (item, i2) => renderItem(item, i2, void 0, cached && cached[i2]));
    } else {
      const keys = Object.keys(source2);
      ret = new Array(keys.length);
      for (let i2 = 0, l2 = keys.length; i2 < l2; i2++) {
        const key2 = keys[i2];
        ret[i2] = renderItem(source2[key2], key2, i2, cached && cached[i2]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index2] = ret;
  }
  return ret;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE) {
    return createVNode("slot", name === "default" ? null : { name }, fallback && fallback());
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(Fragment, { key: props.key || `_${name}` }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment$1)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
const getPublicInstance = (i2) => {
  if (!i2)
    return null;
  if (isStatefulComponent(i2))
    return getExposeProxy(i2) || i2.proxy;
  return getPublicInstance(i2.parent);
};
const publicPropertiesMap = extend$1(/* @__PURE__ */ Object.create(null), {
  $: (i2) => i2,
  $el: (i2) => i2.vnode.el,
  $data: (i2) => i2.data,
  $props: (i2) => i2.props,
  $attrs: (i2) => i2.attrs,
  $slots: (i2) => i2.slots,
  $refs: (i2) => i2.refs,
  $parent: (i2) => getPublicInstance(i2.parent),
  $root: (i2) => getPublicInstance(i2.root),
  $emit: (i2) => i2.emit,
  $options: (i2) => resolveMergedOptions(i2),
  $forceUpdate: (i2) => () => queueJob(i2.update),
  $nextTick: (i2) => nextTick.bind(i2.proxy),
  $watch: (i2) => instanceWatch.bind(i2)
});
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key2) {
    const { ctx, setupState, data: data2, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key2[0] !== "$") {
      const n2 = accessCache[key2];
      if (n2 !== void 0) {
        switch (n2) {
          case 1:
            return setupState[key2];
          case 2:
            return data2[key2];
          case 4:
            return ctx[key2];
          case 3:
            return props[key2];
        }
      } else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key2)) {
        accessCache[key2] = 1;
        return setupState[key2];
      } else if (data2 !== EMPTY_OBJ && hasOwn(data2, key2)) {
        accessCache[key2] = 2;
        return data2[key2];
      } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key2)) {
        accessCache[key2] = 3;
        return props[key2];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key2)) {
        accessCache[key2] = 4;
        return ctx[key2];
      } else if (shouldCacheAccess) {
        accessCache[key2] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key2];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key2 === "$attrs") {
        track(instance, "get", key2);
      }
      return publicGetter(instance);
    } else if ((cssModule = type.__cssModules) && (cssModule = cssModule[key2])) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key2)) {
      accessCache[key2] = 4;
      return ctx[key2];
    } else if (globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key2)) {
      {
        return globalProperties[key2];
      }
    } else
      ;
  },
  set({ _: instance }, key2, value) {
    const { data: data2, setupState, ctx } = instance;
    if (setupState !== EMPTY_OBJ && hasOwn(setupState, key2)) {
      setupState[key2] = value;
      return true;
    } else if (data2 !== EMPTY_OBJ && hasOwn(data2, key2)) {
      data2[key2] = value;
      return true;
    } else if (hasOwn(instance.props, key2)) {
      return false;
    }
    if (key2[0] === "$" && key2.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key2] = value;
      }
    }
    return true;
  },
  has({ _: { data: data2, setupState, accessCache, ctx, appContext, propsOptions } }, key2) {
    let normalizedProps;
    return !!accessCache[key2] || data2 !== EMPTY_OBJ && hasOwn(data2, key2) || setupState !== EMPTY_OBJ && hasOwn(setupState, key2) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key2) || hasOwn(ctx, key2) || hasOwn(publicPropertiesMap, key2) || hasOwn(appContext.config.globalProperties, key2);
  },
  defineProperty(target, key2, descriptor) {
    if (descriptor.get != null) {
      this.set(target, key2, descriptor.get(), null);
    } else if (descriptor.value != null) {
      this.set(target, key2, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key2, descriptor);
  }
};
const emptyAppContext = createAppContext();
let uid$1$1 = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid$1$1++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new EffectScope(true),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    components: null,
    directives: null,
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    emit: null,
    emitted: null,
    propsDefaults: EMPTY_OBJ,
    inheritAttrs: type.inheritAttrs,
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit$1.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const setCurrentInstance = (instance) => {
  currentInstance = instance;
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  currentInstance = null;
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(setup, instance, 0, [instance.props, setupContext]);
    resetTracking();
    unsetCurrentInstance();
    if (isPromise$1(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e2) => {
          handleError(e2, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$1(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$2(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend$1(extend$1({
          isCustomElement,
          delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
}
function createAttrsProxy(instance) {
  return new Proxy(instance.attrs, {
    get(target, key2) {
      track(instance, "get", "$attrs");
      return target[key2];
    }
  });
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  let attrs;
  {
    return {
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance));
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key2) {
        if (key2 in target) {
          return target[key2];
        } else if (key2 in publicPropertiesMap) {
          return publicPropertiesMap[key2](instance);
        }
      }
    }));
  }
}
function getComponentName(Component) {
  return isFunction$1(Component) ? Component.displayName || Component.name : Component.name;
}
function isClassComponent(value) {
  return isFunction$1(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function h$3(type, propsOrChildren, children) {
  const l2 = arguments.length;
  if (l2 === 2) {
    if (isObject$2(propsOrChildren) && !isArray$4(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l2 > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l2 === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const version$1 = "3.2.31";
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is, props) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id2) {
    el.setAttribute(id2, "");
  },
  cloneNode(el) {
    const cloned = el.cloneNode(true);
    if (`_value` in el) {
      cloned._value = el._value;
    }
    return cloned;
  },
  insertStaticContent(content, parent, anchor, isSVG, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      before ? before.nextSibling : parent.firstChild,
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el, value, isSVG) {
  const transitionClasses = el._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
function patchStyle(el, prev, next) {
  const style2 = el.style;
  const isCssString = isString$1(next);
  if (next && !isCssString) {
    for (const key2 in next) {
      setStyle(style2, key2, next[key2]);
    }
    if (prev && !isString$1(prev)) {
      for (const key2 in prev) {
        if (next[key2] == null) {
          setStyle(style2, key2, "");
        }
      }
    }
  } else {
    const currentDisplay = style2.display;
    if (isCssString) {
      if (prev !== next) {
        style2.cssText = next;
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
    if ("_vod" in el) {
      style2.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style2, name, val) {
  if (isArray$4(val)) {
    val.forEach((v2) => setStyle(style2, name, v2));
  } else {
    if (name.startsWith("--")) {
      style2.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style2, name);
      if (importantRE.test(val)) {
        style2.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
      } else {
        style2[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style2, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style2) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i2 = 0; i2 < prefixes.length; i2++) {
    const prefixed = prefixes[i2] + name;
    if (prefixed in style2) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key2, value, isSVG, instance) {
  if (isSVG && key2.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key2.slice(6, key2.length));
    } else {
      el.setAttributeNS(xlinkNS, key2, value);
    }
  } else {
    const isBoolean = isSpecialBooleanAttr(key2);
    if (value == null || isBoolean && !includeBooleanAttr(value)) {
      el.removeAttribute(key2);
    } else {
      el.setAttribute(key2, isBoolean ? "" : value);
    }
  }
}
function patchDOMProp(el, key2, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key2 === "innerHTML" || key2 === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key2] = value == null ? "" : value;
    return;
  }
  if (key2 === "value" && el.tagName !== "PROGRESS" && !el.tagName.includes("-")) {
    el._value = value;
    const newValue = value == null ? "" : value;
    if (el.value !== newValue || el.tagName === "OPTION") {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key2);
    }
    return;
  }
  if (value === "" || value == null) {
    const type = typeof el[key2];
    if (type === "boolean") {
      el[key2] = includeBooleanAttr(value);
      return;
    } else if (value == null && type === "string") {
      el[key2] = "";
      el.removeAttribute(key2);
      return;
    } else if (type === "number") {
      try {
        el[key2] = 0;
      } catch (_a) {
      }
      el.removeAttribute(key2);
      return;
    }
  }
  try {
    el[key2] = value;
  } catch (e2) {
  }
}
let _getNow = Date.now;
let skipTimestampCheck = false;
if (typeof window !== "undefined") {
  if (_getNow() > document.createEvent("Event").timeStamp) {
    _getNow = () => performance.now();
  }
  const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
  skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53);
}
let cachedNow = 0;
const p$2 = Promise.resolve();
const reset = () => {
  cachedNow = 0;
};
const getNow = () => cachedNow || (p$2.then(reset), cachedNow = _getNow());
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m2;
    while (m2 = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m2[0].length);
      options[m2[0].toLowerCase()] = true;
    }
  }
  return [hyphenate(name.slice(2)), options];
}
function createInvoker(initialValue, instance) {
  const invoker = (e2) => {
    const timeStamp = e2.timeStamp || _getNow();
    if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
      callWithAsyncErrorHandling(patchStopImmediatePropagation(e2, invoker.value), instance, 5, [e2]);
    }
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e2, value) {
  if (isArray$4(value)) {
    const originalStop = e2.stopImmediatePropagation;
    e2.stopImmediatePropagation = () => {
      originalStop.call(e2);
      e2._stopped = true;
    };
    return value.map((fn) => (e3) => !e3._stopped && fn && fn(e3));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key2, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key2 === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key2 === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key2)) {
    if (!isModelListener(key2)) {
      patchEvent(el, key2, prevValue, nextValue, parentComponent);
    }
  } else if (key2[0] === "." ? (key2 = key2.slice(1), true) : key2[0] === "^" ? (key2 = key2.slice(1), false) : shouldSetAsProp(el, key2, nextValue, isSVG)) {
    patchDOMProp(el, key2, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
  } else {
    if (key2 === "true-value") {
      el._trueValue = nextValue;
    } else if (key2 === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key2, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key2, value, isSVG) {
  if (isSVG) {
    if (key2 === "innerHTML" || key2 === "textContent") {
      return true;
    }
    if (key2 in el && nativeOnRE.test(key2) && isFunction$1(value)) {
      return true;
    }
    return false;
  }
  if (key2 === "spellcheck" || key2 === "draggable") {
    return false;
  }
  if (key2 === "form") {
    return false;
  }
  if (key2 === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key2 === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key2) && isString$1(value)) {
    return false;
  }
  return key2 in el;
}
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  return (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some((k2) => k2 === eventKey || keyNames[k2] === eventKey)) {
      return fn(event);
    }
  };
};
const rendererOptions = extend$1({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app._component;
    if (!isFunction$1(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
function normalizeContainer(container) {
  if (isString$1(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
var Loading_vue_vue_type_style_index_0_scoped_true_lang$1 = "";
var _export_sfc$1 = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key2, val] of props) {
    target[key2] = val;
  }
  return target;
};
const _sfc_main$u = {};
const _withScopeId$3 = (n2) => (pushScopeId("data-v-2ebdabe3"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$t = {
  xmlns: "http://www.w3.org/2000/svg",
  fill: "none",
  viewBox: "0 0 24 24"
};
const _hoisted_2$r = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("circle", {
  cx: "12",
  cy: "12",
  r: "10",
  stroke: "currentColor",
  "stroke-width": "4"
}, null, -1));
const _hoisted_3$h = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
}, null, -1));
const _hoisted_4$c = [
  _hoisted_2$r,
  _hoisted_3$h
];
function _sfc_render$a(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$t, _hoisted_4$c);
}
var Loading$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$u, [["render", _sfc_render$a], ["__scopeId", "data-v-2ebdabe3"]]);
const _sfc_main$t = {};
const _hoisted_1$s = {
  version: "1.1",
  id: "L5",
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  x: "0px",
  y: "0px",
  viewBox: "0 0 60 100",
  "xml:space": "preserve"
};
const _hoisted_2$q = /* @__PURE__ */ createStaticVNode('<circle fill="currentColor" stroke="none" cx="6" cy="50" r="6"><animateTransform attributeName="transform" dur="1s" type="translate" values="0 15 ; 0 -15; 0 15" repeatCount="indefinite" begin="0.1"></animateTransform></circle><circle fill="currentColor" stroke="none" cx="30" cy="50" r="6"><animateTransform attributeName="transform" dur="1s" type="translate" values="0 10 ; 0 -10; 0 10" repeatCount="indefinite" begin="0.2"></animateTransform></circle><circle fill="currentColor" stroke="none" cx="54" cy="50" r="6"><animateTransform attributeName="transform" dur="1s" type="translate" values="0 5 ; 0 -5; 0 5" repeatCount="indefinite" begin="0.3"></animateTransform></circle>', 3);
const _hoisted_5$9 = [
  _hoisted_2$q
];
function _sfc_render$9(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$s, _hoisted_5$9);
}
var LoadingDots = /* @__PURE__ */ _export_sfc$1(_sfc_main$t, [["render", _sfc_render$9]]);
var MetaMask_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$s = {};
const _hoisted_1$r = {
  version: "1.1",
  id: "Layer_1",
  "xmlns:ev": "http://www.w3.org/2001/xml-events",
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  x: "0px",
  y: "0px",
  viewBox: "0 0 318.6 318.6",
  style: { "enable-background": "new 0 0 318.6 318.6" },
  "xml:space": "preserve"
};
const _hoisted_2$p = /* @__PURE__ */ createStaticVNode('<polygon class="st0" points="274.1,35.5 174.6,109.4 193,65.8 " data-v-246a9848></polygon><g data-v-246a9848><polygon class="st1" points="44.4,35.5 143.1,110.1 125.6,65.8   " data-v-246a9848></polygon><polygon class="st1" points="238.3,206.8 211.8,247.4 268.5,263 284.8,207.7  " data-v-246a9848></polygon><polygon class="st1" points="33.9,207.7 50.1,263 106.8,247.4 80.3,206.8   " data-v-246a9848></polygon><polygon class="st1" points="103.6,138.2 87.8,162.1 144.1,164.6 142.1,104.1   " data-v-246a9848></polygon><polygon class="st1" points="214.9,138.2 175.9,103.4 174.6,164.6 230.8,162.1  " data-v-246a9848></polygon><polygon class="st1" points="106.8,247.4 140.6,230.9 111.4,208.1  " data-v-246a9848></polygon><polygon class="st1" points="177.9,230.9 211.8,247.4 207.1,208.1  " data-v-246a9848></polygon></g><g data-v-246a9848><polygon class="st2" points="211.8,247.4 177.9,230.9 180.6,253 180.3,262.3  " data-v-246a9848></polygon><polygon class="st2" points="106.8,247.4 138.3,262.3 138.1,253 140.6,230.9  " data-v-246a9848></polygon></g><polygon class="st3" points="138.8,193.5 110.6,185.2 130.5,176.1 " data-v-246a9848></polygon><polygon class="st3" points="179.7,193.5 188,176.1 208,185.2 " data-v-246a9848></polygon><g data-v-246a9848><polygon class="st4" points="106.8,247.4 111.6,206.8 80.3,207.7   " data-v-246a9848></polygon><polygon class="st4" points="207,206.8 211.8,247.4 238.3,207.7  " data-v-246a9848></polygon><polygon class="st4" points="230.8,162.1 174.6,164.6 179.8,193.5 188.1,176.1 208.1,185.2  " data-v-246a9848></polygon><polygon class="st4" points="110.6,185.2 130.6,176.1 138.8,193.5 144.1,164.6 87.8,162.1   " data-v-246a9848></polygon></g><g data-v-246a9848><polygon class="st5" points="87.8,162.1 111.4,208.1 110.6,185.2   " data-v-246a9848></polygon><polygon class="st5" points="208.1,185.2 207.1,208.1 230.8,162.1  " data-v-246a9848></polygon><polygon class="st5" points="144.1,164.6 138.8,193.5 145.4,227.6 146.9,182.7  " data-v-246a9848></polygon><polygon class="st5" points="174.6,164.6 171.9,182.6 173.1,227.6 179.8,193.5  " data-v-246a9848></polygon></g><polygon class="st6" points="179.8,193.5 173.1,227.6 177.9,230.9 207.1,208.1 208.1,185.2 " data-v-246a9848></polygon><polygon class="st6" points="110.6,185.2 111.4,208.1 140.6,230.9 145.4,227.6 138.8,193.5 " data-v-246a9848></polygon><polygon class="st7" points="180.3,262.3 180.6,253 178.1,250.8 140.4,250.8 138.1,253 138.3,262.3 106.8,247.4 117.8,256.4 \n      140.1,271.9 178.4,271.9 200.8,256.4 211.8,247.4 " data-v-246a9848></polygon><polygon class="st8" points="177.9,230.9 173.1,227.6 145.4,227.6 140.6,230.9 138.1,253 140.4,250.8 178.1,250.8 180.6,253 " data-v-246a9848></polygon><g data-v-246a9848><polygon class="st9" points="278.3,114.2 286.8,73.4 274.1,35.5 177.9,106.9 214.9,138.2 267.2,153.5 278.8,140 273.8,136.4 \n        281.8,129.1 275.6,124.3 283.6,118.2   " data-v-246a9848></polygon><polygon class="st9" points="31.8,73.4 40.3,114.2 34.9,118.2 42.9,124.3 36.8,129.1 44.8,136.4 39.8,140 51.3,153.5 103.6,138.2 \n        140.6,106.9 44.4,35.5   " data-v-246a9848></polygon></g><polygon class="st6" points="267.2,153.5 214.9,138.2 230.8,162.1 207.1,208.1 238.3,207.7 284.8,207.7 " data-v-246a9848></polygon><polygon class="st6" points="103.6,138.2 51.3,153.5 33.9,207.7 80.3,207.7 111.4,208.1 87.8,162.1 " data-v-246a9848></polygon><polygon class="st6" points="174.6,164.6 177.9,106.9 193.1,65.8 125.6,65.8 140.6,106.9 144.1,164.6 145.3,182.8 145.4,227.6 \n      173.1,227.6 173.3,182.8 " data-v-246a9848></polygon>', 15);
const _hoisted_17 = [
  _hoisted_2$p
];
function _sfc_render$8(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$r, _hoisted_17);
}
var MetaMaskIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$s, [["render", _sfc_render$8], ["__scopeId", "data-v-246a9848"]]);
const _sfc_main$r = {};
const _hoisted_1$q = {
  width: "64px",
  height: "64px",
  viewBox: "0 0 64 64",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink"
};
const _hoisted_2$o = /* @__PURE__ */ createBaseVNode("g", {
  id: "OpenSea",
  stroke: "none",
  "stroke-width": "1",
  fill: "none",
  "fill-rule": "evenodd"
}, [
  /* @__PURE__ */ createBaseVNode("g", {
    id: "Logomark-Transparent-White",
    transform: "translate(6.000000, 8.000000)",
    fill: "currentColor",
    "fill-rule": "nonzero"
  }, [
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M3.15558079,27.4266402 L3.33614536,27.1322887 L14.5225503,9.51448157 C14.6859182,9.263417 15.0728423,9.28938919 15.1932187,9.56642596 C17.0590526,13.7825793 18.6755354,19.0289631 17.9188838,22.2928026 C17.6007463,23.6346994 16.7151201,25.4527532 15.7177158,27.1322887 C15.5887411,27.3746958 15.4511681,27.617103 15.2963984,27.8508528 C15.2276119,27.9547416 15.1072356,28.0153434 14.9782609,28.0153434 L3.48231668,28.0153434 C3.17277742,28.0153434 2.99221285,27.6777048 3.15558079,27.4266402 Z M53,33.4868196 C53,33.6513102 52.9054186,33.7898285 52.7678456,33.8504303 C51.899416,34.2226985 48.9329981,35.5992249 47.7034393,37.3220474 C44.5564568,41.7286635 42.1575276,48.03125 36.7835821,48.03125 L14.376379,48.03125 C6.43153796,48.03125 0,41.5295433 0,33.5041344 L0,33.2444124 C0,33.0366348 0.171966256,32.8634868 0.386924075,32.8634868 L12.8716742,32.8634868 C13.1210253,32.8634868 13.3015899,33.0885792 13.2843933,33.3396438 C13.1898118,34.1534393 13.3445814,34.993207 13.7315055,35.7550581 C14.4709604,37.270103 16.0100584,38.2137595 17.6695328,38.2137595 L23.8517197,38.2137595 L23.8517197,33.3569586 L17.7383193,33.3569586 C17.42878,33.3569586 17.2396171,32.9933478 17.4201817,32.7336259 C17.4889682,32.6297371 17.5577547,32.5258483 17.6437378,32.4046447 C18.2198248,31.5735344 19.0452628,30.2922393 19.8707008,28.8291389 C20.4295912,27.8421954 20.9712849,26.7859927 21.4097988,25.72979 C21.495782,25.5393272 21.5645685,25.3402071 21.6419533,25.1497443 C21.7623297,24.8121057 21.882706,24.4917819 21.9686892,24.1801156 C22.0546723,23.9117362 22.1320571,23.6346994 22.2008436,23.3749775 C22.4072031,22.474608 22.4931862,21.5222941 22.4931862,20.5353506 C22.4931862,20.1457676 22.4759896,19.7388699 22.4415964,19.3579443 C22.4243997,18.9337318 22.3728099,18.5095192 22.32122,18.0853066 C22.2868267,17.7130385 22.2180402,17.3407703 22.1492537,16.9598448 C22.0546723,16.3971138 21.9342959,15.8343829 21.7967229,15.2716519 L21.745133,15.055217 C21.6419533,14.665634 21.5473718,14.3020233 21.4269955,13.9124403 C21.0744646,12.7004044 20.6789422,11.5143408 20.2490266,10.4061937 C20.094257,9.96466632 19.9222907,9.54045377 19.7417262,9.12489861 C19.4837768,8.48425108 19.2172291,7.90420534 18.9764763,7.3587892 C18.8475016,7.10772463 18.7443219,6.88263225 18.6411421,6.64888248 C18.5207657,6.38916051 18.4003894,6.12943854 18.2714147,5.87837396 C18.1854315,5.68791118 18.0822518,5.5061058 18.0134653,5.33295782 L17.2568138,3.93045917 C17.153634,3.7399964 17.3256003,3.50624662 17.5319598,3.56684841 L22.2610318,4.85680087 L22.2782284,4.85680087 C22.2868267,4.85680087 22.2868267,4.85680087 22.295425,4.85680087 L22.9145036,5.03860625 L23.6023686,5.22906903 L23.8517197,5.29832823 L23.8517197,2.47601613 C23.8517197,1.10814708 24.9351071,0 26.2850422,0 C26.9557106,0 27.5661908,0.27703677 27.9961064,0.727221521 C28.4346204,1.17740627 28.7097664,1.79208161 28.7097664,2.47601613 L28.7097664,6.67485468 L29.2170668,6.81337306 C29.2514601,6.83068786 29.2944517,6.84800266 29.3288449,6.87397486 C29.4492213,6.96054885 29.6297859,7.09906723 29.853342,7.27221521 C30.0339066,7.4107336 30.2230694,7.58388158 30.4466256,7.76568696 C30.9023361,8.13795512 31.4526282,8.61411207 32.0459117,9.15952821 C32.2006814,9.29804659 32.355451,9.43656498 32.5016223,9.58374076 C33.2668722,10.3023049 34.1267034,11.1420726 34.9521415,12.0770717 C35.1842959,12.3454511 35.407852,12.605173 35.6400065,12.8908672 C35.8635626,13.1765614 36.1129137,13.4535981 36.3192732,13.7306349 C36.6030175,14.1029031 36.8953602,14.492486 37.1619079,14.8993838 C37.2822842,15.0898466 37.4284555,15.2889667 37.5402336,15.4794295 C37.8841661,15.9902161 38.1765088,16.5183174 38.4602531,17.0464188 C38.5806295,17.2888259 38.7010058,17.5572053 38.8041856,17.8169273 C39.1223232,18.526834 39.3716742,19.2453981 39.5264439,19.9726196 C39.5780337,20.1284528 39.612427,20.2929434 39.6296236,20.4487766 L39.6296236,20.4834062 C39.6812135,20.6911838 39.6984101,20.9162761 39.7156067,21.1500259 C39.7843933,21.8859048 39.75,22.6304411 39.5952304,23.3749775 C39.5264439,23.6866438 39.4404607,23.9809954 39.337281,24.3013192 C39.2255029,24.6043281 39.1223232,24.9159945 38.9847502,25.2190035 C38.7182025,25.8336788 38.4086632,26.4570115 38.0389358,27.0283999 C37.9185594,27.2448349 37.7723881,27.4699272 37.6348151,27.6863622 C37.4800454,27.9114546 37.3166775,28.1278896 37.1791045,28.3356671 C36.9813433,28.6040465 36.7749838,28.8810833 36.560026,29.1321478 C36.3708631,29.3918698 36.1817002,29.6515918 35.9667424,29.8853416 C35.6743997,30.2402949 35.3906554,30.5692761 35.0897145,30.8895999 C34.9177482,31.0973774 34.7285853,31.3138124 34.5308241,31.5042752 C34.3416613,31.7207102 34.1439001,31.9111729 33.9719338,32.0843209 C33.6709929,32.3873299 33.4302401,32.6124223 33.2238806,32.8115424 L32.7337768,33.2530698 C32.6649903,33.322329 32.5704088,33.3569586 32.4758274,33.3569586 L28.7097664,33.3569586 L28.7097664,38.2137595 L33.4474367,38.2137595 C34.5050292,38.2137595 35.5110318,37.8414913 36.3278715,37.140242 C36.6030175,36.8978348 37.8153796,35.8416321 39.2512979,34.2486707 C39.3028877,34.1880689 39.3630759,34.1534393 39.4318624,34.1361245 L52.5098962,30.3268689 C52.7592472,30.2576097 53,30.4394151 53,30.6991371 L53,33.4868196 L53,33.4868196 Z",
      id: "Shape"
    })
  ])
], -1);
const _hoisted_3$g = [
  _hoisted_2$o
];
function _sfc_render$7(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$q, _hoisted_3$g);
}
var OpenSeaIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$r, [["render", _sfc_render$7]]);
const _sfc_main$q = {};
const _hoisted_1$p = {
  viewBox: "0 0 80 48",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink"
};
const _hoisted_2$n = /* @__PURE__ */ createBaseVNode("g", {
  id: "Page-1",
  stroke: "none",
  "stroke-width": "1",
  fill: "none",
  "fill-rule": "evenodd"
}, [
  /* @__PURE__ */ createBaseVNode("g", {
    id: "logo.ca418d755e6ce4e95fd276056b9285f2",
    fill: "currentColor",
    "fill-rule": "nonzero"
  }, [
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M56.01,12.0873003 L60.64,17.5273003 C61.17,18.1383003 61.64,18.6409003 61.83,18.9267003 C63.2147,20.3028003 63.9911,22.1626003 63.99,24.1006003 C63.86,26.3870003 62.37,27.9441003 60.99,29.6096003 L57.75,33.4137003 L56.06,35.3847003 C55.9994,35.4526003 55.9603,35.5366003 55.9475,35.6263003 C55.9348,35.7159003 55.949,35.8072003 55.9884,35.8890003 C56.0277,35.9708003 56.0905,36.0394003 56.169,36.0864003 C56.2475,36.1333003 56.3382,36.1566003 56.43,36.1534003 L73.32,36.1534003 C75.9,36.1534003 79.15,38.3215003 78.96,41.6131003 C78.9547,43.1091003 78.3493,44.5425003 77.2759,45.6003003 C76.2025,46.6582003 74.7481,47.2548003 73.23,47.2600003 L46.78,47.2600003 C45.04,47.2600003 40.36,47.4473003 39.05,43.4560003 C38.7714,42.6219003 38.7333,41.7281003 38.94,40.8739003 C39.3208,39.6110003 39.9232,38.4235003 40.72,37.3655003 C42.05,35.3945003 43.49,33.4235003 44.91,31.5116003 C46.74,29.0084003 48.62,26.5841003 50.47,24.0316003 C50.5357,23.9485003 50.5714,23.8462003 50.5714,23.7409003 C50.5714,23.6356003 50.5357,23.5333003 50.47,23.4502003 L43.75,15.5661003 C43.7062,15.5090003 43.6495,15.4626003 43.5844,15.4307003 C43.5194,15.3988003 43.4477,15.3822003 43.375,15.3822003 C43.3023,15.3822003 43.2306,15.3988003 43.1656,15.4307003 C43.1005,15.4626003 43.0438,15.5090003 43,15.5661003 C41.2,17.9609003 33.32,28.5650003 31.64,30.7134003 C29.96,32.8618003 25.82,32.9800003 23.53,30.7134003 L13.02,20.3163003 C12.9529,20.2499003 12.8672,20.2046003 12.774,20.1863003 C12.6807,20.1679003 12.584,20.1773003 12.4962,20.2132003 C12.4083,20.2491003 12.3332,20.3099003 12.2805,20.3879003 C12.2278,20.4659003 12.1998,20.5576003 12.2,20.6513003 L12.2,40.6473003 C12.2247,42.0663003 11.7984,43.4573003 10.9806,44.6255003 C10.1629,45.7936003 8.9948,46.6804003 7.64,47.1615003 C6.7743,47.4584003 5.8492,47.5471003 4.9416,47.4201003 C4.0341,47.2931003 3.1706,46.9541003 2.423,46.4314003 C1.6754,45.9088003 1.0654,45.2175003 0.6439,44.4154003 C0.2225,43.6132003 0.0017,42.7234003 0,41.8200003 L0,5.86870027 C0.0603,4.57310027 0.5333,3.32920027 1.3519,2.31370027 C2.1705,1.29820027 3.293,0.562800268 4.56,0.211900268 C5.6468,-0.0734197318 6.7908,-0.0705597318 7.8761,0.220200268 C8.9614,0.510900268 9.9494,1.07930027 10.74,1.86760027 L26.9,17.8131003 C26.9484,17.8615003 27.0069,17.8989003 27.0716,17.9225003 C27.1362,17.9461003 27.2054,17.9555003 27.2741,17.9498003 C27.3428,17.9442003 27.4094,17.9237003 27.4692,17.8899003 C27.529,17.8560003 27.5804,17.8096003 27.62,17.7539003 L39.1,2.09420027 C39.6305,1.45850027 40.2956,0.944800268 41.0488,0.589000268 C41.8019,0.233200268 42.6249,0.0440002682 43.46,0.0345002682 L73.32,0.0345002682 C74.1372,0.0359002682 74.9447,0.209100268 75.6884,0.542700268 C76.4322,0.876400268 77.0951,1.36270027 77.6328,1.96910027 C78.1705,2.57550027 78.5706,3.28810027 78.8064,4.05920027 C79.0422,4.83030027 79.1082,5.64210027 79,6.44030027 C78.7896,7.82500027 78.0767,9.08760027 76.9936,9.99370027 C75.9104,10.8998003 74.5306,11.3881003 73.11,11.3679003 L56.39,11.3679003 C56.306,11.3699003 56.2241,11.3941003 56.1527,11.4379003 C56.0814,11.4817003 56.0233,11.5436003 55.9845,11.6170003 C55.9457,11.6905003 55.9276,11.7729003 55.9321,11.8556003 C55.9366,11.9383003 55.9635,12.0183003 56.01,12.0873003 Z",
      id: "Path"
    })
  ])
], -1);
const _hoisted_3$f = [
  _hoisted_2$n
];
function _sfc_render$6(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$p, _hoisted_3$f);
}
var MagicEdenIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$q, [["render", _sfc_render$6]]);
const _sfc_main$p = {};
const _hoisted_1$o = {
  viewBox: "0 0 148 118",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink"
};
const _hoisted_2$m = /* @__PURE__ */ createStaticVNode('<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="image-(25)"><path d="M33.379,24.73 C55.81,2.423 92.19,2.423 114.62,24.73 L134,44 L114.62,63.27 C92.19,85.577 55.81,85.577 33.379,63.27 L14,44 L33.379,24.73 Z" id="Path" fill="none" fill-rule="nonzero"></path><path d="M0,44.03 L44,0 L104,0 L148,44.03 L74,118 L0,44.03 Z M108,28 C89.3,9.223 58.7,9.223 40,28 L24,44 L40,60 C58.7,78.778 89.3,78.778 108,60 L124,44 L108,28 Z" id="Shape" fill="currentColor"></path><path d="M74,58 C66.27,58 60,51.735 60,44 C60,36.265 66.27,30 74,30 C81.73,30 88,36.265 88,44 C88,51.735 81.73,58 74,58 Z" id="Path" fill="none" fill-rule="nonzero"></path><path d="M51,44 C51,56.708 61.3,67 74,67 C86.7,67 97,56.708 97,44 C97,31.292 86.7,21 74,21 C61.3,21 51,31.292 51,44 Z M64,44 C64,49.525 68.48,54 74,54 C79.52,54 84,49.525 84,44 C84,38.475 79.52,34 74,34 C68.48,34 64,38.475 64,44 Z" id="Shape" fill="currentColor"></path></g></g>', 1);
const _hoisted_3$e = [
  _hoisted_2$m
];
function _sfc_render$5(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$o, _hoisted_3$e);
}
var LooksRareIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$p, [["render", _sfc_render$5]]);
const _sfc_main$o = {};
const _hoisted_1$n = {
  viewBox: "0 0 1664 1670",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink"
};
const _hoisted_2$l = /* @__PURE__ */ createStaticVNode('<g id="Artboard" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="ov8h1rgqvwq8idm9gji1" transform="translate(123.418000, 126.418000)"><path d="M1211.642,737.577 C1117.132,910.029 960.162,1039.742 772.992,1100.052 C578.38,1163.392 455.023,1120.062 283.414,1039.492 C472.248,1056.512 602.987,1055.012 764.218,928.979 C853.504394,859.399928 926.314454,770.952492 977.442,669.961 C1058.59213,679.977757 1137.64046,702.799838 1211.642,737.577 Z" id="Path" fill-opacity="0.8" fill="currentColor" fill-rule="nonzero"></path><path d="M977.972,669.958 C926.801703,770.92209 853.955441,859.332995 764.642,928.869 C603.411,1054.902 472.672,1056.402 283.838,1039.392 C467.109,990.812 589.503,944.592 697.775,771.062 C716.885559,740.547323 733.831181,708.72917 748.487,675.842 C824.257293,662.415241 901.613194,660.431835 977.972,669.958 L977.972,669.958 Z" id="Path" fill="currentColor" fill-rule="nonzero"></path><path d="M977.972,669.959 C901.643389,660.478847 824.324664,662.498302 748.595,675.95 C780.013815,605.729904 800.680152,531.179188 809.899,454.805 C889.411754,436.571209 971.310794,431.046763 1052.552,438.437 C1040.11355,519.074505 1014.93962,597.223056 977.972,669.959 Z" id="Path" fill-opacity="0.8" fill="currentColor" fill-rule="nonzero"></path><path d="M748.596,675.95 C713.194755,682.286406 678.270052,691.044645 644.068,702.163 C449.457,765.499 375.208,873.342 283.947,1039.492 C312.834,851.945 345.785,725.378 507.016,599.346 C596.112453,529.466873 699.533398,480.112774 809.9,454.805 C800.68021,531.179002 780.013911,605.729579 748.596,675.95 L748.596,675.95 Z" id="Path" fill="currentColor" fill-rule="nonzero"></path><path d="M809.901,454.807 C699.534387,480.114743 596.113435,529.468845 507.017,599.348 C345.786,725.38 312.836,851.947 283.949,1039.492 C246.931,853.337 234.735,723.134 343.007,549.599 C446.867,382.764 610.565,261.933 800.595,211.837 C816.477638,291.831004 819.618378,373.832489 809.901,454.807 L809.901,454.807 Z" id="Path" fill-opacity="0.8" fill="currentColor" fill-rule="nonzero"></path><path d="M708.582,1417.162 C1099.922,1417.162 1417.162,1099.922 1417.162,708.582 C1417.162,317.243 1099.922,0 708.582,0 C317.243,0 0,317.243 0,708.582 C0,1099.922 317.243,1417.162 708.582,1417.162 Z" id="Path" stroke="currentColor" stroke-width="111.881"></path></g></g>', 1);
const _hoisted_3$d = [
  _hoisted_2$l
];
function _sfc_render$4(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$n, _hoisted_3$d);
}
var SolanartIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$o, [["render", _sfc_render$4]]);
const _sfc_main$n = {};
const _hoisted_1$m = {
  width: "512px",
  height: "512px",
  viewBox: "0 0 512 512",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink"
};
const _hoisted_2$k = /* @__PURE__ */ createStaticVNode('<defs><radialGradient cx="0%" cy="50%" fx="0%" fy="50%" r="100%" id="radialGradient-1"><stop stop-color="#5D9DF6" offset="0%"></stop><stop stop-color="#006FFF" offset="100%"></stop></radialGradient></defs><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="logo"><rect id="base" fill="url(#radialGradient-1)" x="0" y="0" width="512" height="512" rx="256"></rect><path d="M169.209772,184.531136 C217.142772,137.600733 294.857519,137.600733 342.790517,184.531136 L348.559331,190.179285 C350.955981,192.525805 350.955981,196.330266 348.559331,198.676787 L328.82537,217.99798 C327.627045,219.171241 325.684176,219.171241 324.485851,217.99798 L316.547278,210.225455 C283.10802,177.485633 228.89227,177.485633 195.453011,210.225455 L186.951456,218.549188 C185.75313,219.722448 183.810261,219.722448 182.611937,218.549188 L162.877976,199.227995 C160.481326,196.881474 160.481326,193.077013 162.877976,190.730493 L169.209772,184.531136 Z M383.602212,224.489406 L401.165475,241.685365 C403.562113,244.031874 403.562127,247.836312 401.165506,250.182837 L321.971538,327.721548 C319.574905,330.068086 315.689168,330.068112 313.292501,327.721609 C313.292491,327.721599 313.29248,327.721588 313.29247,327.721578 L257.08541,272.690097 C256.486248,272.103467 255.514813,272.103467 254.915651,272.690097 C254.915647,272.690101 254.915644,272.690105 254.91564,272.690108 L198.709777,327.721548 C196.313151,330.068092 192.427413,330.068131 190.030739,327.721634 C190.030725,327.72162 190.03071,327.721606 190.030695,327.721591 L110.834524,250.181849 C108.437875,247.835329 108.437875,244.030868 110.834524,241.684348 L128.397819,224.488418 C130.794468,222.141898 134.680206,222.141898 137.076856,224.488418 L193.284734,279.520668 C193.883897,280.107298 194.85533,280.107298 195.454493,279.520668 C195.454502,279.520659 195.45451,279.520651 195.454519,279.520644 L251.65958,224.488418 C254.056175,222.141844 257.941913,222.141756 260.338618,224.488222 C260.338651,224.488255 260.338684,224.488288 260.338717,224.488321 L316.546521,279.520644 C317.145683,280.107273 318.117118,280.107273 318.71628,279.520644 L374.923175,224.489406 C377.319825,222.142885 381.205562,222.142885 383.602212,224.489406 Z" id="WalletConnect" fill="#FFFFFF" fill-rule="nonzero"></path></g></g>', 2);
const _hoisted_4$b = [
  _hoisted_2$k
];
function _sfc_render$3(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$m, _hoisted_4$b);
}
var WalletConnectIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$n, [["render", _sfc_render$3]]);
function render$f(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "fill-rule": "evenodd",
      d: "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z",
      "clip-rule": "evenodd"
    })
  ]);
}
function render$e(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "fill-rule": "evenodd",
      d: "M12.316 3.051a1 1 0 01.633 1.265l-4 12a1 1 0 11-1.898-.632l4-12a1 1 0 011.265-.633zM5.707 6.293a1 1 0 010 1.414L3.414 10l2.293 2.293a1 1 0 11-1.414 1.414l-3-3a1 1 0 010-1.414l3-3a1 1 0 011.414 0zm8.586 0a1 1 0 011.414 0l3 3a1 1 0 010 1.414l-3 3a1 1 0 11-1.414-1.414L16.586 10l-2.293-2.293a1 1 0 010-1.414z",
      "clip-rule": "evenodd"
    })
  ]);
}
function render$d(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "fill-rule": "evenodd",
      d: "M6 2a2 2 0 00-2 2v12a2 2 0 002 2h8a2 2 0 002-2V7.414A2 2 0 0015.414 6L12 2.586A2 2 0 0010.586 2H6zm5 6a1 1 0 10-2 0v3.586l-1.293-1.293a1 1 0 10-1.414 1.414l3 3a1 1 0 001.414 0l3-3a1 1 0 00-1.414-1.414L11 11.586V8z",
      "clip-rule": "evenodd"
    })
  ]);
}
function render$c(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "fill-rule": "evenodd",
      d: "M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4zm2 6a1 1 0 011-1h6a1 1 0 110 2H7a1 1 0 01-1-1zm1 3a1 1 0 100 2h6a1 1 0 100-2H7z",
      "clip-rule": "evenodd"
    })
  ]);
}
function render$b(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "fill-rule": "evenodd",
      d: "M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z",
      "clip-rule": "evenodd"
    })
  ]);
}
function render$a(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "fill-rule": "evenodd",
      d: "M10 18a8 8 0 100-16 8 8 0 000 16zM4.332 8.027a6.012 6.012 0 011.912-2.706C6.512 5.73 6.974 6 7.5 6A1.5 1.5 0 019 7.5V8a2 2 0 004 0 2 2 0 011.523-1.943A5.977 5.977 0 0116 10c0 .34-.028.675-.083 1H15a2 2 0 00-2 2v2.197A5.973 5.973 0 0110 16v-2a2 2 0 00-2-2 2 2 0 01-2-2 2 2 0 00-1.668-1.973z",
      "clip-rule": "evenodd"
    })
  ]);
}
function render$9(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "fill-rule": "evenodd",
      d: "M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z",
      "clip-rule": "evenodd"
    })
  ]);
}
function render$8(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", { d: "M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 015.905-.75 1 1 0 001.937-.5A5.002 5.002 0 0010 2z" })
  ]);
}
function render$7(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "fill-rule": "evenodd",
      d: "M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z",
      "clip-rule": "evenodd"
    })
  ]);
}
function render$6(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "fill-rule": "evenodd",
      d: "M10 1.944A11.954 11.954 0 012.166 5C2.056 5.649 2 6.319 2 7c0 5.225 3.34 9.67 8 11.317C14.66 16.67 18 12.225 18 7c0-.682-.057-1.35-.166-2.001A11.954 11.954 0 0110 1.944zM11 14a1 1 0 11-2 0 1 1 0 012 0zm0-7a1 1 0 10-2 0v3a1 1 0 102 0V7z",
      "clip-rule": "evenodd"
    })
  ]);
}
function render$5(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", { d: "M8 5a1 1 0 100 2h5.586l-1.293 1.293a1 1 0 001.414 1.414l3-3a1 1 0 000-1.414l-3-3a1 1 0 10-1.414 1.414L13.586 5H8zM12 15a1 1 0 100-2H6.414l1.293-1.293a1 1 0 10-1.414-1.414l-3 3a1 1 0 000 1.414l3 3a1 1 0 001.414-1.414L6.414 15H12z" })
  ]);
}
function render$4(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", { d: "M2 6a2 2 0 012-2h6a2 2 0 012 2v8a2 2 0 01-2 2H4a2 2 0 01-2-2V6zM14.553 7.106A1 1 0 0014 8v4a1 1 0 00.553.894l2 1A1 1 0 0018 13V7a1 1 0 00-1.447-.894l-2 1z" })
  ]);
}
function render$3(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "fill-rule": "evenodd",
      d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z",
      "clip-rule": "evenodd"
    })
  ]);
}
const _sfc_main$m = {
  props: { type: String },
  setup(__props) {
    const props = __props;
    const icon = computed(() => {
      return {
        image: render$7,
        video: render$4,
        file: render$d,
        text: render$c,
        json: render$e,
        webhook: render$5
      }[props.type];
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(unref(icon)));
    };
  }
};
const TwitterIcon = defineComponent({
  render: () => h$3("svg", { fill: "currentColor", viewBox: "0 0 24 24" }, [
    h$3("path", {
      d: "M8.29 20.251c7.547 0 11.675-6.253 11.675-11.675 0-.178 0-.355-.012-.53A8.348 8.348 0 0022 5.92a8.19 8.19 0 01-2.357.646 4.118 4.118 0 001.804-2.27 8.224 8.224 0 01-2.605.996 4.107 4.107 0 00-6.993 3.743 11.65 11.65 0 01-8.457-4.287 4.106 4.106 0 001.27 5.477A4.072 4.072 0 012.8 9.713v.052a4.105 4.105 0 003.292 4.022 4.095 4.095 0 01-1.853.07 4.108 4.108 0 003.834 2.85A8.233 8.233 0 012 18.407a11.616 11.616 0 006.29 1.84"
    })
  ])
});
const DiscordIcon = defineComponent({
  render: () => h$3("svg", { fill: "currentColor", fillRule: "evenodd", clipRule: "evenodd", viewBox: "0 0 24 24" }, [
    h$3("path", {
      d: "M19.54 0c1.356 0 2.46 1.104 2.46 2.472v21.528l-2.58-2.28-1.452-1.344-1.536-1.428.636 2.22h-13.608c-1.356 0-2.46-1.104-2.46-2.472v-16.224c0-1.368 1.104-2.472 2.46-2.472h16.08zm-4.632 15.672c2.652-.084 3.672-1.824 3.672-1.824 0-3.864-1.728-6.996-1.728-6.996-1.728-1.296-3.372-1.26-3.372-1.26l-.168.192c2.04.624 2.988 1.524 2.988 1.524-1.248-.684-2.472-1.02-3.612-1.152-.864-.096-1.692-.072-2.424.024l-.204.024c-.42.036-1.44.192-2.724.756-.444.204-.708.348-.708.348s.996-.948 3.156-1.572l-.12-.144s-1.644-.036-3.372 1.26c0 0-1.728 3.132-1.728 6.996 0 0 1.008 1.74 3.66 1.824 0 0 .444-.54.804-.996-1.524-.456-2.1-1.416-2.1-1.416l.336.204.048.036.047.027.014.006.047.027c.3.168.6.3.876.408.492.192 1.08.384 1.764.516.9.168 1.956.228 3.108.012.564-.096 1.14-.264 1.74-.516.42-.156.888-.384 1.38-.708 0 0-.6.984-2.172 1.428.36.456.792.972.792.972zm-5.58-5.604c-.684 0-1.224.6-1.224 1.332 0 .732.552 1.332 1.224 1.332.684 0 1.224-.6 1.224-1.332.012-.732-.54-1.332-1.224-1.332zm4.38 0c-.684 0-1.224.6-1.224 1.332 0 .732.552 1.332 1.224 1.332.684 0 1.224-.6 1.224-1.332 0-.732-.54-1.332-1.224-1.332z"
    })
  ])
});
const chains = {
  ETH: {
    name: "Ethereum",
    symbol: "ETH",
    decimals: 18
  },
  MATIC: {
    name: "Polygon",
    symbol: "MATIC",
    decimals: 18
  }
};
const networks = {
  ETH: {
    mainnet: {
      chainId: "0x1",
      nativeCurrency: chains.ETH,
      rpcUrls: ["https://mainnet.infura.io/v3/"]
    },
    ropsten: {
      chainId: "0x3",
      nativeCurrency: chains.ETH,
      rpcUrls: ["https://ropsten.infura.io/v3/"]
    },
    rinkeby: {
      chainId: "0x4",
      nativeCurrency: chains.ETH,
      rpcUrls: ["https://rinkeby.infura.io/v3/"]
    }
  },
  MATIC: {
    mainnet: {
      chainId: "0x89",
      chainName: "Polygon Mainnet",
      nativeCurrency: chains.MATIC,
      rpcUrls: ["https://polygon-rpc.com/"],
      blockExplorerUrls: ["https://polygonscan.com/"]
    },
    mumbai: {
      chainId: "0x13881",
      chainName: "Polygon Mumbai",
      nativeCurrency: chains.MATIC,
      rpcUrls: ["https://rpc-mumbai.maticvigil.com/"],
      blockExplorerUrls: ["https://mumbai.polygonscan.com/"]
    }
  }
};
class MetaMaskProvider {
  constructor() {
    this.name = "MetaMask";
    this.supportedChains = ["ETH", "MATIC"];
    this.available = false;
    this.metadata = {
      icon: MetaMaskIcon,
      desc: "Browser extension & app"
    };
    if (window.ethereum) {
      this.provider = new Web3Provider(window.ethereum);
      this.available = true;
    }
  }
  async switchChain(chain) {
    try {
      await window.ethereum.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: chain.chainId }]
      });
    } catch (err) {
      if (err.code === 4902) {
        try {
          await window.ethereum.request({
            method: "wallet_addEthereumChain",
            params: [chain]
          });
        } catch (addError) {
          throw new UnsupportedChainError(`User rejected the request to enable ${chain.chainName}`);
        }
      } else {
        throw new UnsupportedChainError(`User rejected the request to enable ${chain.chainName}`);
      }
    }
  }
  async getAddress() {
    return this.address;
  }
  async connect(_chain, network = "mainnet") {
    let address;
    try {
      [address] = await window.ethereum.request({
        method: "wallet_requestPermissions",
        params: [{
          eth_accounts: {}
        }]
      }).then(() => ethereum.request({
        method: "eth_requestAccounts"
      }));
    } catch (err) {
      if (err.code === 4001) {
        throw new UserRejectedRequestError();
      }
      throw err;
    }
    const requiredChain = networks[_chain][network];
    const currentChainId = await window.ethereum.request({ method: "eth_chainId" });
    if (currentChainId !== requiredChain.chainId) {
      console.log(`User is on incorrect chain`);
      await this.switchChain(requiredChain);
    }
    this.address = address;
  }
  async sign(message) {
    const signer = this.provider.getSigner();
    return signer.signMessage(message);
  }
}
var cjs$3 = {};
var cjs$2 = {};
Object.defineProperty(cjs$2, "__esModule", { value: true });
var getLocalStorage_1 = cjs$2.getLocalStorage = getLocalStorageOrThrow_1 = cjs$2.getLocalStorageOrThrow = getCrypto_1 = cjs$2.getCrypto = getCryptoOrThrow_1 = cjs$2.getCryptoOrThrow = getLocation_1 = cjs$2.getLocation = getLocationOrThrow_1 = cjs$2.getLocationOrThrow = getNavigator_1 = cjs$2.getNavigator = getNavigatorOrThrow_1 = cjs$2.getNavigatorOrThrow = getDocument_1 = cjs$2.getDocument = getDocumentOrThrow_1 = cjs$2.getDocumentOrThrow = getFromWindowOrThrow_1 = cjs$2.getFromWindowOrThrow = getFromWindow_1 = cjs$2.getFromWindow = void 0;
function getFromWindow$1(name) {
  let res = void 0;
  if (typeof window !== "undefined" && typeof window[name] !== "undefined") {
    res = window[name];
  }
  return res;
}
var getFromWindow_1 = cjs$2.getFromWindow = getFromWindow$1;
function getFromWindowOrThrow$1(name) {
  const res = getFromWindow$1(name);
  if (!res) {
    throw new Error(`${name} is not defined in Window`);
  }
  return res;
}
var getFromWindowOrThrow_1 = cjs$2.getFromWindowOrThrow = getFromWindowOrThrow$1;
function getDocumentOrThrow$1() {
  return getFromWindowOrThrow$1("document");
}
var getDocumentOrThrow_1 = cjs$2.getDocumentOrThrow = getDocumentOrThrow$1;
function getDocument$1() {
  return getFromWindow$1("document");
}
var getDocument_1 = cjs$2.getDocument = getDocument$1;
function getNavigatorOrThrow$1() {
  return getFromWindowOrThrow$1("navigator");
}
var getNavigatorOrThrow_1 = cjs$2.getNavigatorOrThrow = getNavigatorOrThrow$1;
function getNavigator$1() {
  return getFromWindow$1("navigator");
}
var getNavigator_1 = cjs$2.getNavigator = getNavigator$1;
function getLocationOrThrow$1() {
  return getFromWindowOrThrow$1("location");
}
var getLocationOrThrow_1 = cjs$2.getLocationOrThrow = getLocationOrThrow$1;
function getLocation$1() {
  return getFromWindow$1("location");
}
var getLocation_1 = cjs$2.getLocation = getLocation$1;
function getCryptoOrThrow$1() {
  return getFromWindowOrThrow$1("crypto");
}
var getCryptoOrThrow_1 = cjs$2.getCryptoOrThrow = getCryptoOrThrow$1;
function getCrypto$1() {
  return getFromWindow$1("crypto");
}
var getCrypto_1 = cjs$2.getCrypto = getCrypto$1;
function getLocalStorageOrThrow$1() {
  return getFromWindowOrThrow$1("localStorage");
}
var getLocalStorageOrThrow_1 = cjs$2.getLocalStorageOrThrow = getLocalStorageOrThrow$1;
function getLocalStorage$1() {
  return getFromWindow$1("localStorage");
}
getLocalStorage_1 = cjs$2.getLocalStorage = getLocalStorage$1;
Object.defineProperty(cjs$3, "__esModule", { value: true });
var getWindowMetadata_1 = cjs$3.getWindowMetadata = void 0;
const window_getters_1 = cjs$2;
function getWindowMetadata() {
  let doc2;
  let loc;
  try {
    doc2 = window_getters_1.getDocumentOrThrow();
    loc = window_getters_1.getLocationOrThrow();
  } catch (e2) {
    return null;
  }
  function getIcons() {
    const links = doc2.getElementsByTagName("link");
    const icons2 = [];
    for (let i2 = 0; i2 < links.length; i2++) {
      const link = links[i2];
      const rel = link.getAttribute("rel");
      if (rel) {
        if (rel.toLowerCase().indexOf("icon") > -1) {
          const href = link.getAttribute("href");
          if (href) {
            if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
              let absoluteHref = loc.protocol + "//" + loc.host;
              if (href.indexOf("/") === 0) {
                absoluteHref += href;
              } else {
                const path = loc.pathname.split("/");
                path.pop();
                const finalPath = path.join("/");
                absoluteHref += finalPath + "/" + href;
              }
              icons2.push(absoluteHref);
            } else if (href.indexOf("//") === 0) {
              const absoluteUrl = loc.protocol + href;
              icons2.push(absoluteUrl);
            } else {
              icons2.push(href);
            }
          }
        }
      }
    }
    return icons2;
  }
  function getWindowMetadataOfAny(...args) {
    const metaTags = doc2.getElementsByTagName("meta");
    for (let i2 = 0; i2 < metaTags.length; i2++) {
      const tag = metaTags[i2];
      const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
        if (attr) {
          return args.includes(attr);
        }
        return false;
      });
      if (attributes.length && attributes) {
        const content = tag.getAttribute("content");
        if (content) {
          return content;
        }
      }
    }
    return "";
  }
  function getName() {
    let name2 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
    if (!name2) {
      name2 = doc2.title;
    }
    return name2;
  }
  function getDescription() {
    const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
    return description2;
  }
  const name = getName();
  const description = getDescription();
  const url = loc.origin;
  const icons = getIcons();
  const meta = {
    description,
    url,
    icons,
    name
  };
  return meta;
}
getWindowMetadata_1 = cjs$3.getWindowMetadata = getWindowMetadata;
var __spreadArrays = globalThis && globalThis.__spreadArrays || function() {
  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
    s2 += arguments[i2].length;
  for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
    for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
      r2[k2] = a2[j2];
  return r2;
};
var BrowserInfo = function() {
  function BrowserInfo2(name, version2, os) {
    this.name = name;
    this.version = version2;
    this.os = os;
    this.type = "browser";
  }
  return BrowserInfo2;
}();
var NodeInfo = function() {
  function NodeInfo2(version2) {
    this.version = version2;
    this.type = "node";
    this.name = "node";
    this.os = browser$1$1.platform;
  }
  return NodeInfo2;
}();
var SearchBotDeviceInfo = function() {
  function SearchBotDeviceInfo2(name, version2, os, bot) {
    this.name = name;
    this.version = version2;
    this.os = os;
    this.bot = bot;
    this.type = "bot-device";
  }
  return SearchBotDeviceInfo2;
}();
var BotInfo = function() {
  function BotInfo2() {
    this.type = "bot";
    this.bot = true;
    this.name = "bot";
    this.version = null;
    this.os = null;
  }
  return BotInfo2;
}();
var ReactNativeInfo = function() {
  function ReactNativeInfo2() {
    this.type = "react-native";
    this.name = "react-native";
    this.version = null;
    this.os = null;
  }
  return ReactNativeInfo2;
}();
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FBAV\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a) {
    var browser2 = _a[0], regex2 = _a[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex2.exec(ua);
    return !!uaMatch && [browser2, uaMatch];
  }, false);
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name = matchedRule[0], match = matchedRule[1];
  if (name === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
    }
  } else {
    versionParts = [];
  }
  var version2 = versionParts.join(".");
  var os = detectOS$1(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version2, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name, version2, os);
}
function detectOS$1(ua) {
  for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
    var _a = operatingSystemRules[ii], os = _a[0], regex2 = _a[1];
    var match = regex2.exec(ua);
    if (match) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode2 = typeof browser$1$1 !== "undefined" && browser$1$1.version;
  return isNode2 ? new NodeInfo(browser$1$1.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output = [];
  for (var ii = 0; ii < count; ii++) {
    output.push("0");
  }
  return output;
}
function detectEnv(userAgent) {
  return detect(userAgent);
}
function detectOS() {
  const env2 = detectEnv();
  return env2 && env2.os ? env2.os : void 0;
}
function isAndroid() {
  const os = detectOS();
  return os ? os.toLowerCase().includes("android") : false;
}
function isIOS$1() {
  const os = detectOS();
  return os ? os.toLowerCase().includes("ios") || os.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
}
function isMobile() {
  const os = detectOS();
  return os ? isAndroid() || isIOS$1() : false;
}
function isNode$3() {
  const env2 = detectEnv();
  const result = env2 && env2.name ? env2.name.toLowerCase() === "node" : false;
  return result;
}
function isBrowser$1() {
  const result = !isNode$3() && !!getNavigator();
  return result;
}
const getFromWindow = getFromWindow_1;
const getFromWindowOrThrow = getFromWindowOrThrow_1;
const getDocumentOrThrow = getDocumentOrThrow_1;
const getDocument = getDocument_1;
const getNavigatorOrThrow = getNavigatorOrThrow_1;
const getNavigator = getNavigator_1;
const getLocationOrThrow = getLocationOrThrow_1;
const getLocation = getLocation_1;
const getCryptoOrThrow = getCryptoOrThrow_1;
const getCrypto = getCrypto_1;
const getLocalStorageOrThrow = getLocalStorageOrThrow_1;
const getLocalStorage = getLocalStorage_1;
function getClientMeta() {
  return getWindowMetadata_1();
}
function safeJsonParse$1(value) {
  if (typeof value !== "string") {
    throw new Error(`Cannot safe json parse value of type ${typeof value}`);
  }
  try {
    return JSON.parse(value);
  } catch (_a) {
    return value;
  }
}
function safeJsonStringify$1(value) {
  return typeof value === "string" ? value : JSON.stringify(value);
}
const safeJsonParse = safeJsonParse$1;
const safeJsonStringify = safeJsonStringify$1;
function setLocal(key2, data2) {
  const raw = safeJsonStringify(data2);
  const local = getLocalStorage();
  if (local) {
    local.setItem(key2, raw);
  }
}
function getLocal(key2) {
  let data2 = null;
  let raw = null;
  const local = getLocalStorage();
  if (local) {
    raw = local.getItem(key2);
  }
  data2 = raw ? safeJsonParse(raw) : raw;
  return data2;
}
function removeLocal(key2) {
  const local = getLocalStorage();
  if (local) {
    local.removeItem(key2);
  }
}
const mobileLinkChoiceKey = "WALLETCONNECT_DEEPLINK_CHOICE";
function formatIOSMobile(uri, entry) {
  const encodedUri = encodeURIComponent(uri);
  return entry.universalLink ? `${entry.universalLink}/wc?uri=${encodedUri}` : entry.deepLink ? `${entry.deepLink}${entry.deepLink.endsWith(":") ? "//" : "/"}wc?uri=${encodedUri}` : "";
}
function saveMobileLinkInfo(data2) {
  const focusUri = data2.href.split("?")[0];
  setLocal(mobileLinkChoiceKey, Object.assign(Object.assign({}, data2), { href: focusUri }));
}
function getMobileRegistryEntry(registry, name) {
  return registry.filter((entry) => entry.name.toLowerCase().includes(name.toLowerCase()))[0];
}
function getMobileLinkRegistry(registry, whitelist) {
  let links = registry;
  if (whitelist) {
    links = whitelist.map((name) => getMobileRegistryEntry(registry, name)).filter(Boolean);
  }
  return links;
}
const API_URL = "https://registry.walletconnect.com";
function getWalletRegistryUrl() {
  return API_URL + "/api/v2/wallets";
}
function getDappRegistryUrl() {
  return API_URL + "/api/v2/dapps";
}
function formatMobileRegistryEntry(entry, platform2 = "mobile") {
  var _a;
  return {
    name: entry.name || "",
    shortName: entry.metadata.shortName || "",
    color: entry.metadata.colors.primary || "",
    logo: (_a = entry.image_url.sm) !== null && _a !== void 0 ? _a : "",
    universalLink: entry[platform2].universal || "",
    deepLink: entry[platform2].native || ""
  };
}
function formatMobileRegistry(registry, platform2 = "mobile") {
  return Object.values(registry).filter((entry) => !!entry[platform2].universal || !!entry[platform2].native).map((entry) => formatMobileRegistryEntry(entry, platform2));
}
var esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  detectEnv,
  detectOS,
  isAndroid,
  isIOS: isIOS$1,
  isMobile,
  isNode: isNode$3,
  isBrowser: isBrowser$1,
  getFromWindow,
  getFromWindowOrThrow,
  getDocumentOrThrow,
  getDocument,
  getNavigatorOrThrow,
  getNavigator,
  getLocationOrThrow,
  getLocation,
  getCryptoOrThrow,
  getCrypto,
  getLocalStorageOrThrow,
  getLocalStorage,
  getClientMeta,
  safeJsonParse,
  safeJsonStringify,
  setLocal,
  getLocal,
  removeLocal,
  mobileLinkChoiceKey,
  formatIOSMobile,
  saveMobileLinkInfo,
  getMobileRegistryEntry,
  getMobileLinkRegistry,
  getWalletRegistryUrl,
  getDappRegistryUrl,
  formatMobileRegistryEntry,
  formatMobileRegistry
}, Symbol.toStringTag, { value: "Module" }));
const reservedEvents = [
  "session_request",
  "session_update",
  "exchange_key",
  "connect",
  "disconnect",
  "display_uri",
  "modal_closed",
  "transport_open",
  "transport_close",
  "transport_error"
];
const signingMethods = [
  "eth_sendTransaction",
  "eth_signTransaction",
  "eth_sign",
  "eth_signTypedData",
  "eth_signTypedData_v1",
  "eth_signTypedData_v2",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4",
  "personal_sign",
  "wallet_addEthereumChain",
  "wallet_switchEthereumChain",
  "wallet_getPermissions",
  "wallet_requestPermissions",
  "wallet_registerOnboarding",
  "wallet_watchAsset",
  "wallet_scanQRCode"
];
var bn = { exports: {} };
(function(module) {
  (function(module2, exports) {
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN2(number, base2, endian) {
      if (BN2.isBN(number)) {
        return number;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number !== null) {
        if (base2 === "le" || base2 === "be") {
          endian = base2;
          base2 = 10;
        }
        this._init(number || 0, base2 || 10, endian || "be");
      }
    }
    if (typeof module2 === "object") {
      module2.exports = BN2;
    } else {
      exports.BN = BN2;
    }
    BN2.BN = BN2;
    BN2.wordSize = 26;
    var Buffer3;
    try {
      Buffer3 = require("buffer").Buffer;
    } catch (e2) {
    }
    BN2.isBN = function isBN(num) {
      if (num instanceof BN2) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
    };
    BN2.max = function max2(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN2.min = function min2(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN2.prototype._init = function init4(number, base2, endian) {
      if (typeof number === "number") {
        return this._initNumber(number, base2, endian);
      }
      if (typeof number === "object") {
        return this._initArray(number, base2, endian);
      }
      if (base2 === "hex") {
        base2 = 16;
      }
      assert2(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
      number = number.toString().replace(/\s+/g, "");
      var start = 0;
      if (number[0] === "-") {
        start++;
      }
      if (base2 === 16) {
        this._parseHex(number, start);
      } else {
        this._parseBase(number, base2, start);
      }
      if (number[0] === "-") {
        this.negative = 1;
      }
      this.strip();
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base2, endian);
    };
    BN2.prototype._initNumber = function _initNumber(number, base2, endian) {
      if (number < 0) {
        this.negative = 1;
        number = -number;
      }
      if (number < 67108864) {
        this.words = [number & 67108863];
        this.length = 1;
      } else if (number < 4503599627370496) {
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert2(number < 9007199254740992);
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base2, endian);
    };
    BN2.prototype._initArray = function _initArray(number, base2, endian) {
      assert2(typeof number.length === "number");
      if (number.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number.length / 3);
      this.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        this.words[i2] = 0;
      }
      var j2, w2;
      var off2 = 0;
      if (endian === "be") {
        for (i2 = number.length - 1, j2 = 0; i2 >= 0; i2 -= 3) {
          w2 = number[i2] | number[i2 - 1] << 8 | number[i2 - 2] << 16;
          this.words[j2] |= w2 << off2 & 67108863;
          this.words[j2 + 1] = w2 >>> 26 - off2 & 67108863;
          off2 += 24;
          if (off2 >= 26) {
            off2 -= 26;
            j2++;
          }
        }
      } else if (endian === "le") {
        for (i2 = 0, j2 = 0; i2 < number.length; i2 += 3) {
          w2 = number[i2] | number[i2 + 1] << 8 | number[i2 + 2] << 16;
          this.words[j2] |= w2 << off2 & 67108863;
          this.words[j2 + 1] = w2 >>> 26 - off2 & 67108863;
          off2 += 24;
          if (off2 >= 26) {
            off2 -= 26;
            j2++;
          }
        }
      }
      return this.strip();
    };
    function parseHex(str, start, end) {
      var r2 = 0;
      var len = Math.min(str.length, end);
      for (var i2 = start; i2 < len; i2++) {
        var c2 = str.charCodeAt(i2) - 48;
        r2 <<= 4;
        if (c2 >= 49 && c2 <= 54) {
          r2 |= c2 - 49 + 10;
        } else if (c2 >= 17 && c2 <= 22) {
          r2 |= c2 - 17 + 10;
        } else {
          r2 |= c2 & 15;
        }
      }
      return r2;
    }
    BN2.prototype._parseHex = function _parseHex(number, start) {
      this.length = Math.ceil((number.length - start) / 6);
      this.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        this.words[i2] = 0;
      }
      var j2, w2;
      var off2 = 0;
      for (i2 = number.length - 6, j2 = 0; i2 >= start; i2 -= 6) {
        w2 = parseHex(number, i2, i2 + 6);
        this.words[j2] |= w2 << off2 & 67108863;
        this.words[j2 + 1] |= w2 >>> 26 - off2 & 4194303;
        off2 += 24;
        if (off2 >= 26) {
          off2 -= 26;
          j2++;
        }
      }
      if (i2 + 6 !== start) {
        w2 = parseHex(number, start, i2 + 6);
        this.words[j2] |= w2 << off2 & 67108863;
        this.words[j2 + 1] |= w2 >>> 26 - off2 & 4194303;
      }
      this.strip();
    };
    function parseBase(str, start, end, mul4) {
      var r2 = 0;
      var len = Math.min(str.length, end);
      for (var i2 = start; i2 < len; i2++) {
        var c2 = str.charCodeAt(i2) - 48;
        r2 *= mul4;
        if (c2 >= 49) {
          r2 += c2 - 49 + 10;
        } else if (c2 >= 17) {
          r2 += c2 - 17 + 10;
        } else {
          r2 += c2;
        }
      }
      return r2;
    }
    BN2.prototype._parseBase = function _parseBase(number, base2, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base2 | 0;
      var total = number.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word = 0;
      for (var i2 = start; i2 < end; i2 += limbLen) {
        word = parseBase(number, i2, i2 + limbLen, base2);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod !== 0) {
        var pow = 1;
        word = parseBase(number, i2, number.length, base2);
        for (i2 = 0; i2 < mod; i2++) {
          pow *= base2;
        }
        this.imuln(pow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
    };
    BN2.prototype.copy = function copy4(dest) {
      dest.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        dest.words[i2] = this.words[i2];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    BN2.prototype.clone = function clone() {
      var r2 = new BN2(null);
      this.copy(r2);
      return r2;
    };
    BN2.prototype._expand = function _expand(size2) {
      while (this.length < size2) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN2.prototype.strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN2.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    BN2.prototype.inspect = function inspect5() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var zeros = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN2.prototype.toString = function toString4(base2, padding2) {
      base2 = base2 || 10;
      padding2 = padding2 | 0 || 1;
      var out;
      if (base2 === 16 || base2 === "hex") {
        out = "";
        var off2 = 0;
        var carry = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var w2 = this.words[i2];
          var word = ((w2 << off2 | carry) & 16777215).toString(16);
          carry = w2 >>> 24 - off2 & 16777215;
          if (carry !== 0 || i2 !== this.length - 1) {
            out = zeros[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
          off2 += 2;
          if (off2 >= 26) {
            off2 -= 26;
            i2--;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
        var groupSize = groupSizes[base2];
        var groupBase = groupBases[base2];
        out = "";
        var c2 = this.clone();
        c2.negative = 0;
        while (!c2.isZero()) {
          var r2 = c2.modn(groupBase).toString(base2);
          c2 = c2.idivn(groupBase);
          if (!c2.isZero()) {
            out = zeros[groupSize - r2.length] + r2 + out;
          } else {
            out = r2 + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert2(false, "Base should be between 2 and 36");
    };
    BN2.prototype.toNumber = function toNumber2() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN2.prototype.toJSON = function toJSON3() {
      return this.toString(16);
    };
    BN2.prototype.toBuffer = function toBuffer(endian, length) {
      assert2(typeof Buffer3 !== "undefined");
      return this.toArrayLike(Buffer3, endian, length);
    };
    BN2.prototype.toArray = function toArray2(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };
    BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      var byteLength2 = this.byteLength();
      var reqLength = length || Math.max(1, byteLength2);
      assert2(byteLength2 <= reqLength, "byte array longer than desired length");
      assert2(reqLength > 0, "Requested array length <= 0");
      this.strip();
      var littleEndian = endian === "le";
      var res = new ArrayType(reqLength);
      var b2, i2;
      var q2 = this.clone();
      if (!littleEndian) {
        for (i2 = 0; i2 < reqLength - byteLength2; i2++) {
          res[i2] = 0;
        }
        for (i2 = 0; !q2.isZero(); i2++) {
          b2 = q2.andln(255);
          q2.iushrn(8);
          res[reqLength - i2 - 1] = b2;
        }
      } else {
        for (i2 = 0; !q2.isZero(); i2++) {
          b2 = q2.andln(255);
          q2.iushrn(8);
          res[i2] = b2;
        }
        for (; i2 < reqLength; i2++) {
          res[i2] = 0;
        }
      }
      return res;
    };
    if (Math.clz32) {
      BN2.prototype._countBits = function _countBits(w2) {
        return 32 - Math.clz32(w2);
      };
    } else {
      BN2.prototype._countBits = function _countBits(w2) {
        var t2 = w2;
        var r2 = 0;
        if (t2 >= 4096) {
          r2 += 13;
          t2 >>>= 13;
        }
        if (t2 >= 64) {
          r2 += 7;
          t2 >>>= 7;
        }
        if (t2 >= 8) {
          r2 += 4;
          t2 >>>= 4;
        }
        if (t2 >= 2) {
          r2 += 2;
          t2 >>>= 2;
        }
        return r2 + t2;
      };
    }
    BN2.prototype._zeroBits = function _zeroBits(w2) {
      if (w2 === 0)
        return 26;
      var t2 = w2;
      var r2 = 0;
      if ((t2 & 8191) === 0) {
        r2 += 13;
        t2 >>>= 13;
      }
      if ((t2 & 127) === 0) {
        r2 += 7;
        t2 >>>= 7;
      }
      if ((t2 & 15) === 0) {
        r2 += 4;
        t2 >>>= 4;
      }
      if ((t2 & 3) === 0) {
        r2 += 2;
        t2 >>>= 2;
      }
      if ((t2 & 1) === 0) {
        r2++;
      }
      return r2;
    };
    BN2.prototype.bitLength = function bitLength() {
      var w2 = this.words[this.length - 1];
      var hi = this._countBits(w2);
      return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
      var w2 = new Array(num.bitLength());
      for (var bit = 0; bit < w2.length; bit++) {
        var off2 = bit / 26 | 0;
        var wbit = bit % 26;
        w2[bit] = (num.words[off2] & 1 << wbit) >>> wbit;
      }
      return w2;
    }
    BN2.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r2 = 0;
      for (var i2 = 0; i2 < this.length; i2++) {
        var b2 = this._zeroBits(this.words[i2]);
        r2 += b2;
        if (b2 !== 26)
          break;
      }
      return r2;
    };
    BN2.prototype.byteLength = function byteLength2() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN2.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN2.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN2.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN2.prototype.neg = function neg3() {
      return this.clone().ineg();
    };
    BN2.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN2.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i2 = 0; i2 < num.length; i2++) {
        this.words[i2] = this.words[i2] | num.words[i2];
      }
      return this.strip();
    };
    BN2.prototype.ior = function ior(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN2.prototype.or = function or(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN2.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN2.prototype.iuand = function iuand(num) {
      var b2;
      if (this.length > num.length) {
        b2 = num;
      } else {
        b2 = this;
      }
      for (var i2 = 0; i2 < b2.length; i2++) {
        this.words[i2] = this.words[i2] & num.words[i2];
      }
      this.length = b2.length;
      return this.strip();
    };
    BN2.prototype.iand = function iand(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN2.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN2.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN2.prototype.iuxor = function iuxor(num) {
      var a2;
      var b2;
      if (this.length > num.length) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      for (var i2 = 0; i2 < b2.length; i2++) {
        this.words[i2] = a2.words[i2] ^ b2.words[i2];
      }
      if (this !== a2) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      this.length = a2.length;
      return this.strip();
    };
    BN2.prototype.ixor = function ixor(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN2.prototype.xor = function xor(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN2.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN2.prototype.inotn = function inotn(width) {
      assert2(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i2 = 0; i2 < bytesNeeded; i2++) {
        this.words[i2] = ~this.words[i2] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
      }
      return this.strip();
    };
    BN2.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN2.prototype.setn = function setn(bit, val) {
      assert2(typeof bit === "number" && bit >= 0);
      var off2 = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off2 + 1);
      if (val) {
        this.words[off2] = this.words[off2] | 1 << wbit;
      } else {
        this.words[off2] = this.words[off2] & ~(1 << wbit);
      }
      return this.strip();
    };
    BN2.prototype.iadd = function iadd(num) {
      var r2;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r2 = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r2 = this.isub(num);
        num.negative = 1;
        return r2._normSign();
      }
      var a2, b2;
      if (this.length > num.length) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      var carry = 0;
      for (var i2 = 0; i2 < b2.length; i2++) {
        r2 = (a2.words[i2] | 0) + (b2.words[i2] | 0) + carry;
        this.words[i2] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      for (; carry !== 0 && i2 < a2.length; i2++) {
        r2 = (a2.words[i2] | 0) + carry;
        this.words[i2] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      this.length = a2.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a2 !== this) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      return this;
    };
    BN2.prototype.add = function add4(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN2.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r2 = this.iadd(num);
        num.negative = 1;
        return r2._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a2, b2;
      if (cmp > 0) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      var carry = 0;
      for (var i2 = 0; i2 < b2.length; i2++) {
        r2 = (a2.words[i2] | 0) - (b2.words[i2] | 0) + carry;
        carry = r2 >> 26;
        this.words[i2] = r2 & 67108863;
      }
      for (; carry !== 0 && i2 < a2.length; i2++) {
        r2 = (a2.words[i2] | 0) + carry;
        carry = r2 >> 26;
        this.words[i2] = r2 & 67108863;
      }
      if (carry === 0 && i2 < a2.length && a2 !== this) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      this.length = Math.max(this.length, i2);
      if (a2 !== this) {
        this.negative = 1;
      }
      return this.strip();
    };
    BN2.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len = self2.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0;
      var a2 = self2.words[0] | 0;
      var b2 = num.words[0] | 0;
      var r2 = a2 * b2;
      var lo = r2 & 67108863;
      var carry = r2 / 67108864 | 0;
      out.words[0] = lo;
      for (var k2 = 1; k2 < len; k2++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k2, num.length - 1);
        for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
          var i2 = k2 - j2 | 0;
          a2 = self2.words[i2] | 0;
          b2 = num.words[j2] | 0;
          r2 = a2 * b2 + rword;
          ncarry += r2 / 67108864 | 0;
          rword = r2 & 67108863;
        }
        out.words[k2] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k2] = carry | 0;
      } else {
        out.length--;
      }
      return out.strip();
    }
    var comb10MulTo = function comb10MulTo2(self2, num, out) {
      var a2 = self2.words;
      var b2 = num.words;
      var o2 = out.words;
      var c2 = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a2[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a2[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a22 = a2[2] | 0;
      var al2 = a22 & 8191;
      var ah2 = a22 >>> 13;
      var a3 = a2[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a2[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a2[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a2[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a2[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a2[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a2[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b2[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b2[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b22 = b2[2] | 0;
      var bl2 = b22 & 8191;
      var bh2 = b22 >>> 13;
      var b3 = b2[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b2[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b2[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b2[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b2[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b2[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b2[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o2[0] = w0;
      o2[1] = w1;
      o2[2] = w2;
      o2[3] = w3;
      o2[4] = w4;
      o2[5] = w5;
      o2[6] = w6;
      o2[7] = w7;
      o2[8] = w8;
      o2[9] = w9;
      o2[10] = w10;
      o2[11] = w11;
      o2[12] = w12;
      o2[13] = w13;
      o2[14] = w14;
      o2[15] = w15;
      o2[16] = w16;
      o2[17] = w17;
      o2[18] = w18;
      if (c2 !== 0) {
        o2[19] = c2;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k2 = 0; k2 < out.length - 1; k2++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k2, num.length - 1);
        for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
          var i2 = k2 - j2;
          var a2 = self2.words[i2] | 0;
          var b2 = num.words[j2] | 0;
          var r2 = a2 * b2;
          var lo = r2 & 67108863;
          ncarry = ncarry + (r2 / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k2] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k2] = carry;
      } else {
        out.length--;
      }
      return out.strip();
    }
    function jumboMulTo(self2, num, out) {
      var fftm = new FFTM();
      return fftm.mulp(self2, num, out);
    }
    BN2.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    function FFTM(x2, y2) {
      this.x = x2;
      this.y = y2;
    }
    FFTM.prototype.makeRBT = function makeRBT(N2) {
      var t2 = new Array(N2);
      var l2 = BN2.prototype._countBits(N2) - 1;
      for (var i2 = 0; i2 < N2; i2++) {
        t2[i2] = this.revBin(i2, l2, N2);
      }
      return t2;
    };
    FFTM.prototype.revBin = function revBin(x2, l2, N2) {
      if (x2 === 0 || x2 === N2 - 1)
        return x2;
      var rb = 0;
      for (var i2 = 0; i2 < l2; i2++) {
        rb |= (x2 & 1) << l2 - i2 - 1;
        x2 >>= 1;
      }
      return rb;
    };
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N2) {
      for (var i2 = 0; i2 < N2; i2++) {
        rtws[i2] = rws[rbt[i2]];
        itws[i2] = iws[rbt[i2]];
      }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N2, rbt) {
      this.permute(rbt, rws, iws, rtws, itws, N2);
      for (var s2 = 1; s2 < N2; s2 <<= 1) {
        var l2 = s2 << 1;
        var rtwdf = Math.cos(2 * Math.PI / l2);
        var itwdf = Math.sin(2 * Math.PI / l2);
        for (var p2 = 0; p2 < N2; p2 += l2) {
          var rtwdf_ = rtwdf;
          var itwdf_ = itwdf;
          for (var j2 = 0; j2 < s2; j2++) {
            var re = rtws[p2 + j2];
            var ie2 = itws[p2 + j2];
            var ro = rtws[p2 + j2 + s2];
            var io2 = itws[p2 + j2 + s2];
            var rx = rtwdf_ * ro - itwdf_ * io2;
            io2 = rtwdf_ * io2 + itwdf_ * ro;
            ro = rx;
            rtws[p2 + j2] = re + ro;
            itws[p2 + j2] = ie2 + io2;
            rtws[p2 + j2 + s2] = re - ro;
            itws[p2 + j2 + s2] = ie2 - io2;
            if (j2 !== l2) {
              rx = rtwdf * rtwdf_ - itwdf * itwdf_;
              itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
              rtwdf_ = rx;
            }
          }
        }
      }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n2, m2) {
      var N2 = Math.max(m2, n2) | 1;
      var odd = N2 & 1;
      var i2 = 0;
      for (N2 = N2 / 2 | 0; N2; N2 = N2 >>> 1) {
        i2++;
      }
      return 1 << i2 + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N2) {
      if (N2 <= 1)
        return;
      for (var i2 = 0; i2 < N2 / 2; i2++) {
        var t2 = rws[i2];
        rws[i2] = rws[N2 - i2 - 1];
        rws[N2 - i2 - 1] = t2;
        t2 = iws[i2];
        iws[i2] = -iws[N2 - i2 - 1];
        iws[N2 - i2 - 1] = -t2;
      }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N2) {
      var carry = 0;
      for (var i2 = 0; i2 < N2 / 2; i2++) {
        var w2 = Math.round(ws[2 * i2 + 1] / N2) * 8192 + Math.round(ws[2 * i2] / N2) + carry;
        ws[i2] = w2 & 67108863;
        if (w2 < 67108864) {
          carry = 0;
        } else {
          carry = w2 / 67108864 | 0;
        }
      }
      return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N2) {
      var carry = 0;
      for (var i2 = 0; i2 < len; i2++) {
        carry = carry + (ws[i2] | 0);
        rws[2 * i2] = carry & 8191;
        carry = carry >>> 13;
        rws[2 * i2 + 1] = carry & 8191;
        carry = carry >>> 13;
      }
      for (i2 = 2 * len; i2 < N2; ++i2) {
        rws[i2] = 0;
      }
      assert2(carry === 0);
      assert2((carry & ~8191) === 0);
    };
    FFTM.prototype.stub = function stub(N2) {
      var ph = new Array(N2);
      for (var i2 = 0; i2 < N2; i2++) {
        ph[i2] = 0;
      }
      return ph;
    };
    FFTM.prototype.mulp = function mulp(x2, y2, out) {
      var N2 = 2 * this.guessLen13b(x2.length, y2.length);
      var rbt = this.makeRBT(N2);
      var _2 = this.stub(N2);
      var rws = new Array(N2);
      var rwst = new Array(N2);
      var iwst = new Array(N2);
      var nrws = new Array(N2);
      var nrwst = new Array(N2);
      var niwst = new Array(N2);
      var rmws = out.words;
      rmws.length = N2;
      this.convert13b(x2.words, x2.length, rws, N2);
      this.convert13b(y2.words, y2.length, nrws, N2);
      this.transform(rws, _2, rwst, iwst, N2, rbt);
      this.transform(nrws, _2, nrwst, niwst, N2, rbt);
      for (var i2 = 0; i2 < N2; i2++) {
        var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
        iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2];
        rwst[i2] = rx;
      }
      this.conjugate(rwst, iwst, N2);
      this.transform(rwst, iwst, rmws, _2, N2, rbt);
      this.conjugate(rmws, _2, N2);
      this.normalize13b(rmws, N2);
      out.negative = x2.negative ^ y2.negative;
      out.length = x2.length + y2.length;
      return out.strip();
    };
    BN2.prototype.mul = function mul4(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN2.prototype.mulf = function mulf(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN2.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN2.prototype.imuln = function imuln(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      var carry = 0;
      for (var i2 = 0; i2 < this.length; i2++) {
        var w2 = (this.words[i2] | 0) * num;
        var lo = (w2 & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w2 / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i2] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i2] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN2.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN2.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN2.prototype.pow = function pow(num) {
      var w2 = toBitArray(num);
      if (w2.length === 0)
        return new BN2(1);
      var res = this;
      for (var i2 = 0; i2 < w2.length; i2++, res = res.sqr()) {
        if (w2[i2] !== 0)
          break;
      }
      if (++i2 < w2.length) {
        for (var q2 = res.sqr(); i2 < w2.length; i2++, q2 = q2.sqr()) {
          if (w2[i2] === 0)
            continue;
          res = res.mul(q2);
        }
      }
      return res;
    };
    BN2.prototype.iushln = function iushln(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
      var i2;
      if (r2 !== 0) {
        var carry = 0;
        for (i2 = 0; i2 < this.length; i2++) {
          var newCarry = this.words[i2] & carryMask;
          var c2 = (this.words[i2] | 0) - newCarry << r2;
          this.words[i2] = c2 | carry;
          carry = newCarry >>> 26 - r2;
        }
        if (carry) {
          this.words[i2] = carry;
          this.length++;
        }
      }
      if (s2 !== 0) {
        for (i2 = this.length - 1; i2 >= 0; i2--) {
          this.words[i2 + s2] = this.words[i2];
        }
        for (i2 = 0; i2 < s2; i2++) {
          this.words[i2] = 0;
        }
        this.length += s2;
      }
      return this.strip();
    };
    BN2.prototype.ishln = function ishln(bits) {
      assert2(this.negative === 0);
      return this.iushln(bits);
    };
    BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert2(typeof bits === "number" && bits >= 0);
      var h2;
      if (hint) {
        h2 = (hint - hint % 26) / 26;
      } else {
        h2 = 0;
      }
      var r2 = bits % 26;
      var s2 = Math.min((bits - r2) / 26, this.length);
      var mask = 67108863 ^ 67108863 >>> r2 << r2;
      var maskedWords = extended;
      h2 -= s2;
      h2 = Math.max(0, h2);
      if (maskedWords) {
        for (var i2 = 0; i2 < s2; i2++) {
          maskedWords.words[i2] = this.words[i2];
        }
        maskedWords.length = s2;
      }
      if (s2 === 0)
        ;
      else if (this.length > s2) {
        this.length -= s2;
        for (i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = this.words[i2 + s2];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h2); i2--) {
        var word = this.words[i2] | 0;
        this.words[i2] = carry << 26 - r2 | word >>> r2;
        carry = word & mask;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this.strip();
    };
    BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert2(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN2.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN2.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN2.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN2.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN2.prototype.testn = function testn(bit) {
      assert2(typeof bit === "number" && bit >= 0);
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q2 = 1 << r2;
      if (this.length <= s2)
        return false;
      var w2 = this.words[s2];
      return !!(w2 & q2);
    };
    BN2.prototype.imaskn = function imaskn(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      assert2(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s2) {
        return this;
      }
      if (r2 !== 0) {
        s2++;
      }
      this.length = Math.min(s2, this.length);
      if (r2 !== 0) {
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        this.words[this.length - 1] &= mask;
      }
      return this.strip();
    };
    BN2.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN2.prototype.iaddn = function iaddn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) < num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN2.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
        this.words[i2] -= 67108864;
        if (i2 === this.length - 1) {
          this.words[i2 + 1] = 1;
        } else {
          this.words[i2 + 1]++;
        }
      }
      this.length = Math.max(this.length, i2 + 1);
      return this;
    };
    BN2.prototype.isubn = function isubn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
          this.words[i2] += 67108864;
          this.words[i2 + 1] -= 1;
        }
      }
      return this.strip();
    };
    BN2.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN2.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN2.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN2.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul4, shift2) {
      var len = num.length + shift2;
      var i2;
      this._expand(len);
      var w2;
      var carry = 0;
      for (i2 = 0; i2 < num.length; i2++) {
        w2 = (this.words[i2 + shift2] | 0) + carry;
        var right = (num.words[i2] | 0) * mul4;
        w2 -= right & 67108863;
        carry = (w2 >> 26) - (right / 67108864 | 0);
        this.words[i2 + shift2] = w2 & 67108863;
      }
      for (; i2 < this.length - shift2; i2++) {
        w2 = (this.words[i2 + shift2] | 0) + carry;
        carry = w2 >> 26;
        this.words[i2 + shift2] = w2 & 67108863;
      }
      if (carry === 0)
        return this.strip();
      assert2(carry === -1);
      carry = 0;
      for (i2 = 0; i2 < this.length; i2++) {
        w2 = -(this.words[i2] | 0) + carry;
        carry = w2 >> 26;
        this.words[i2] = w2 & 67108863;
      }
      this.negative = 1;
      return this.strip();
    };
    BN2.prototype._wordDiv = function _wordDiv(num, mode2) {
      var shift2 = this.length - num.length;
      var a2 = this.clone();
      var b2 = num;
      var bhi = b2.words[b2.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift2 = 26 - bhiBits;
      if (shift2 !== 0) {
        b2 = b2.ushln(shift2);
        a2.iushln(shift2);
        bhi = b2.words[b2.length - 1] | 0;
      }
      var m2 = a2.length - b2.length;
      var q2;
      if (mode2 !== "mod") {
        q2 = new BN2(null);
        q2.length = m2 + 1;
        q2.words = new Array(q2.length);
        for (var i2 = 0; i2 < q2.length; i2++) {
          q2.words[i2] = 0;
        }
      }
      var diff = a2.clone()._ishlnsubmul(b2, 1, m2);
      if (diff.negative === 0) {
        a2 = diff;
        if (q2) {
          q2.words[m2] = 1;
        }
      }
      for (var j2 = m2 - 1; j2 >= 0; j2--) {
        var qj = (a2.words[b2.length + j2] | 0) * 67108864 + (a2.words[b2.length + j2 - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a2._ishlnsubmul(b2, qj, j2);
        while (a2.negative !== 0) {
          qj--;
          a2.negative = 0;
          a2._ishlnsubmul(b2, 1, j2);
          if (!a2.isZero()) {
            a2.negative ^= 1;
          }
        }
        if (q2) {
          q2.words[j2] = qj;
        }
      }
      if (q2) {
        q2.strip();
      }
      a2.strip();
      if (mode2 !== "div" && shift2 !== 0) {
        a2.iushrn(shift2);
      }
      return {
        div: q2 || null,
        mod: a2
      };
    };
    BN2.prototype.divmod = function divmod(num, mode2, positive) {
      assert2(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN2(0),
          mod: new BN2(0)
        };
      }
      var div, mod, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode2);
        if (mode2 !== "mod") {
          div = res.div.neg();
        }
        if (mode2 !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }
        return {
          div,
          mod
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode2);
        if (mode2 !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode2);
        if (mode2 !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }
        return {
          div: res.div,
          mod
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN2(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode2 === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode2 === "mod") {
          return {
            div: null,
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN2(this.modn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode2);
    };
    BN2.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN2.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN2.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN2.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN2.prototype.modn = function modn(num) {
      assert2(num <= 67108863);
      var p2 = (1 << 26) % num;
      var acc = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        acc = (p2 * acc + (this.words[i2] | 0)) % num;
      }
      return acc;
    };
    BN2.prototype.idivn = function idivn(num) {
      assert2(num <= 67108863);
      var carry = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        var w2 = (this.words[i2] | 0) + carry * 67108864;
        this.words[i2] = w2 / num | 0;
        carry = w2 % num;
      }
      return this.strip();
    };
    BN2.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN2.prototype.egcd = function egcd(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var x2 = this;
      var y2 = p2.clone();
      if (x2.negative !== 0) {
        x2 = x2.umod(p2);
      } else {
        x2 = x2.clone();
      }
      var A2 = new BN2(1);
      var B2 = new BN2(0);
      var C2 = new BN2(0);
      var D2 = new BN2(1);
      var g2 = 0;
      while (x2.isEven() && y2.isEven()) {
        x2.iushrn(1);
        y2.iushrn(1);
        ++g2;
      }
      var yp = y2.clone();
      var xp = x2.clone();
      while (!x2.isZero()) {
        for (var i2 = 0, im = 1; (x2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
          ;
        if (i2 > 0) {
          x2.iushrn(i2);
          while (i2-- > 0) {
            if (A2.isOdd() || B2.isOdd()) {
              A2.iadd(yp);
              B2.isub(xp);
            }
            A2.iushrn(1);
            B2.iushrn(1);
          }
        }
        for (var j2 = 0, jm = 1; (y2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
          ;
        if (j2 > 0) {
          y2.iushrn(j2);
          while (j2-- > 0) {
            if (C2.isOdd() || D2.isOdd()) {
              C2.iadd(yp);
              D2.isub(xp);
            }
            C2.iushrn(1);
            D2.iushrn(1);
          }
        }
        if (x2.cmp(y2) >= 0) {
          x2.isub(y2);
          A2.isub(C2);
          B2.isub(D2);
        } else {
          y2.isub(x2);
          C2.isub(A2);
          D2.isub(B2);
        }
      }
      return {
        a: C2,
        b: D2,
        gcd: y2.iushln(g2)
      };
    };
    BN2.prototype._invmp = function _invmp(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var a2 = this;
      var b2 = p2.clone();
      if (a2.negative !== 0) {
        a2 = a2.umod(p2);
      } else {
        a2 = a2.clone();
      }
      var x1 = new BN2(1);
      var x2 = new BN2(0);
      var delta = b2.clone();
      while (a2.cmpn(1) > 0 && b2.cmpn(1) > 0) {
        for (var i2 = 0, im = 1; (a2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
          ;
        if (i2 > 0) {
          a2.iushrn(i2);
          while (i2-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j2 = 0, jm = 1; (b2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
          ;
        if (j2 > 0) {
          b2.iushrn(j2);
          while (j2-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a2.cmp(b2) >= 0) {
          a2.isub(b2);
          x1.isub(x2);
        } else {
          b2.isub(a2);
          x2.isub(x1);
        }
      }
      var res;
      if (a2.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p2);
      }
      return res;
    };
    BN2.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a2 = this.clone();
      var b2 = num.clone();
      a2.negative = 0;
      b2.negative = 0;
      for (var shift2 = 0; a2.isEven() && b2.isEven(); shift2++) {
        a2.iushrn(1);
        b2.iushrn(1);
      }
      do {
        while (a2.isEven()) {
          a2.iushrn(1);
        }
        while (b2.isEven()) {
          b2.iushrn(1);
        }
        var r2 = a2.cmp(b2);
        if (r2 < 0) {
          var t2 = a2;
          a2 = b2;
          b2 = t2;
        } else if (r2 === 0 || b2.cmpn(1) === 0) {
          break;
        }
        a2.isub(b2);
      } while (true);
      return b2.iushln(shift2);
    };
    BN2.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN2.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN2.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN2.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN2.prototype.bincn = function bincn(bit) {
      assert2(typeof bit === "number");
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q2 = 1 << r2;
      if (this.length <= s2) {
        this._expand(s2 + 1);
        this.words[s2] |= q2;
        return this;
      }
      var carry = q2;
      for (var i2 = s2; carry !== 0 && i2 < this.length; i2++) {
        var w2 = this.words[i2] | 0;
        w2 += carry;
        carry = w2 >>> 26;
        w2 &= 67108863;
        this.words[i2] = w2;
      }
      if (carry !== 0) {
        this.words[i2] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN2.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this.strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert2(num <= 67108863, "Number is too big");
        var w2 = this.words[0] | 0;
        res = w2 === num ? 0 : w2 < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        var a2 = this.words[i2] | 0;
        var b2 = num.words[i2] | 0;
        if (a2 === b2)
          continue;
        if (a2 < b2) {
          res = -1;
        } else if (a2 > b2) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN2.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN2.prototype.gt = function gt2(num) {
      return this.cmp(num) === 1;
    };
    BN2.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN2.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN2.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN2.prototype.lt = function lt2(num) {
      return this.cmp(num) === -1;
    };
    BN2.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN2.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN2.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN2.prototype.eq = function eq4(num) {
      return this.cmp(num) === 0;
    };
    BN2.red = function red(num) {
      return new Red(num);
    };
    BN2.prototype.toRed = function toRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      assert2(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN2.prototype.fromRed = function fromRed() {
      assert2(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN2.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN2.prototype.forceRed = function forceRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN2.prototype.redAdd = function redAdd(num) {
      assert2(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN2.prototype.redIAdd = function redIAdd(num) {
      assert2(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN2.prototype.redSub = function redSub(num) {
      assert2(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN2.prototype.redISub = function redISub(num) {
      assert2(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN2.prototype.redShl = function redShl(num) {
      assert2(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN2.prototype.redMul = function redMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN2.prototype.redIMul = function redIMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN2.prototype.redSqr = function redSqr() {
      assert2(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN2.prototype.redISqr = function redISqr() {
      assert2(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN2.prototype.redSqrt = function redSqrt() {
      assert2(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN2.prototype.redInvm = function redInvm() {
      assert2(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN2.prototype.redNeg = function redNeg() {
      assert2(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN2.prototype.redPow = function redPow(num) {
      assert2(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name, p2) {
      this.name = name;
      this.p = new BN2(p2, 16);
      this.n = this.p.bitLength();
      this.k = new BN2(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN2(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r2 = num;
      var rlen;
      do {
        this.split(r2, this.tmp);
        r2 = this.imulK(r2);
        r2 = r2.iadd(this.tmp);
        rlen = r2.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
      if (cmp === 0) {
        r2.words[0] = 0;
        r2.length = 1;
      } else if (cmp > 0) {
        r2.isub(this.p);
      } else {
        r2.strip();
      }
      return r2;
    };
    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits2(K256, MPrime);
    K256.prototype.split = function split(input, output) {
      var mask = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i2 = 0; i2 < outLen; i2++) {
        output.words[i2] = input.words[i2];
      }
      output.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output.words[output.length++] = prev & mask;
      for (i2 = 10; i2 < input.length; i2++) {
        var next = input.words[i2] | 0;
        input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i2 - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i2 = 0; i2 < num.length; i2++) {
        var w2 = num.words[i2] | 0;
        lo += w2 * 977;
        num.words[i2] = lo & 67108863;
        lo = w2 * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits2(P224, MPrime);
    function P192() {
      MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits2(P192, MPrime);
    function P25519() {
      MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits2(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i2 = 0; i2 < num.length; i2++) {
        var hi = (num.words[i2] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i2] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN2._prime = function prime(name) {
      if (primes[name])
        return primes[name];
      var prime2;
      if (name === "k256") {
        prime2 = new K256();
      } else if (name === "p224") {
        prime2 = new P224();
      } else if (name === "p192") {
        prime2 = new P192();
      } else if (name === "p25519") {
        prime2 = new P25519();
      } else {
        throw new Error("Unknown prime " + name);
      }
      primes[name] = prime2;
      return prime2;
    };
    function Red(m2) {
      if (typeof m2 === "string") {
        var prime = BN2._prime(m2);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert2(m2.gtn(1), "modulus must be greater than 1");
        this.m = m2;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a2) {
      assert2(a2.negative === 0, "red works only with positives");
      assert2(a2.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a2, b2) {
      assert2((a2.negative | b2.negative) === 0, "red works only with positives");
      assert2(a2.red && a2.red === b2.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a2) {
      if (this.prime)
        return this.prime.ireduce(a2)._forceRed(this);
      return a2.umod(this.m)._forceRed(this);
    };
    Red.prototype.neg = function neg3(a2) {
      if (a2.isZero()) {
        return a2.clone();
      }
      return this.m.sub(a2)._forceRed(this);
    };
    Red.prototype.add = function add4(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.add(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.iadd(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.sub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.isub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a2, num) {
      this._verify1(a2);
      return this.imod(a2.ushln(num));
    };
    Red.prototype.imul = function imul(a2, b2) {
      this._verify2(a2, b2);
      return this.imod(a2.imul(b2));
    };
    Red.prototype.mul = function mul4(a2, b2) {
      this._verify2(a2, b2);
      return this.imod(a2.mul(b2));
    };
    Red.prototype.isqr = function isqr(a2) {
      return this.imul(a2, a2.clone());
    };
    Red.prototype.sqr = function sqr(a2) {
      return this.mul(a2, a2);
    };
    Red.prototype.sqrt = function sqrt(a2) {
      if (a2.isZero())
        return a2.clone();
      var mod3 = this.m.andln(3);
      assert2(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN2(1)).iushrn(2);
        return this.pow(a2, pow);
      }
      var q2 = this.m.subn(1);
      var s2 = 0;
      while (!q2.isZero() && q2.andln(1) === 0) {
        s2++;
        q2.iushrn(1);
      }
      assert2(!q2.isZero());
      var one = new BN2(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z2 = this.m.bitLength();
      z2 = new BN2(2 * z2 * z2).toRed(this);
      while (this.pow(z2, lpow).cmp(nOne) !== 0) {
        z2.redIAdd(nOne);
      }
      var c2 = this.pow(z2, q2);
      var r2 = this.pow(a2, q2.addn(1).iushrn(1));
      var t2 = this.pow(a2, q2);
      var m2 = s2;
      while (t2.cmp(one) !== 0) {
        var tmp = t2;
        for (var i2 = 0; tmp.cmp(one) !== 0; i2++) {
          tmp = tmp.redSqr();
        }
        assert2(i2 < m2);
        var b2 = this.pow(c2, new BN2(1).iushln(m2 - i2 - 1));
        r2 = r2.redMul(b2);
        c2 = b2.redSqr();
        t2 = t2.redMul(c2);
        m2 = i2;
      }
      return r2;
    };
    Red.prototype.invm = function invm(a2) {
      var inv = a2._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a2, num) {
      if (num.isZero())
        return new BN2(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a2.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN2(1).toRed(this);
      wnd[1] = a2;
      for (var i2 = 2; i2 < wnd.length; i2++) {
        wnd[i2] = this.mul(wnd[i2 - 1], a2);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i2 = num.length - 1; i2 >= 0; i2--) {
        var word = num.words[i2];
        for (var j2 = start - 1; j2 >= 0; j2--) {
          var bit = word >> j2 & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i2 !== 0 || j2 !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r2 = num.umod(this.m);
      return r2 === num ? r2.clone() : r2;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN2.mont = function mont(num) {
      return new Mont(num);
    };
    function Mont(m2) {
      Red.call(this, m2);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN2(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits2(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r2 = this.imod(num.mul(this.rinv));
      r2.red = null;
      return r2;
    };
    Mont.prototype.imul = function imul(a2, b2) {
      if (a2.isZero() || b2.isZero()) {
        a2.words[0] = 0;
        a2.length = 1;
        return a2;
      }
      var t2 = a2.imul(b2);
      var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c2).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul4(a2, b2) {
      if (a2.isZero() || b2.isZero())
        return new BN2(0)._forceRed(this);
      var t2 = a2.mul(b2);
      var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c2).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a2) {
      var res = this.imod(a2._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module, commonjsGlobal);
})(bn);
var BN = bn.exports;
var lookup$1 = [];
var revLookup$1 = [];
var Arr$1 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited = false;
function init3() {
  inited = true;
  var code2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i2 = 0, len = code2.length; i2 < len; ++i2) {
    lookup$1[i2] = code2[i2];
    revLookup$1[code2.charCodeAt(i2)] = i2;
  }
  revLookup$1["-".charCodeAt(0)] = 62;
  revLookup$1["_".charCodeAt(0)] = 63;
}
function toByteArray$1(b64) {
  if (!inited) {
    init3();
  }
  var i2, j2, l2, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr$1(len * 3 / 4 - placeHolders);
  l2 = placeHolders > 0 ? len - 4 : len;
  var L2 = 0;
  for (i2 = 0, j2 = 0; i2 < l2; i2 += 4, j2 += 3) {
    tmp = revLookup$1[b64.charCodeAt(i2)] << 18 | revLookup$1[b64.charCodeAt(i2 + 1)] << 12 | revLookup$1[b64.charCodeAt(i2 + 2)] << 6 | revLookup$1[b64.charCodeAt(i2 + 3)];
    arr[L2++] = tmp >> 16 & 255;
    arr[L2++] = tmp >> 8 & 255;
    arr[L2++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup$1[b64.charCodeAt(i2)] << 2 | revLookup$1[b64.charCodeAt(i2 + 1)] >> 4;
    arr[L2++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup$1[b64.charCodeAt(i2)] << 10 | revLookup$1[b64.charCodeAt(i2 + 1)] << 4 | revLookup$1[b64.charCodeAt(i2 + 2)] >> 2;
    arr[L2++] = tmp >> 8 & 255;
    arr[L2++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64$1(num) {
  return lookup$1[num >> 18 & 63] + lookup$1[num >> 12 & 63] + lookup$1[num >> 6 & 63] + lookup$1[num & 63];
}
function encodeChunk$1(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i2 = start; i2 < end; i2 += 3) {
    tmp = (uint8[i2] << 16) + (uint8[i2 + 1] << 8) + uint8[i2 + 2];
    output.push(tripletToBase64$1(tmp));
  }
  return output.join("");
}
function fromByteArray$1(uint8) {
  if (!inited) {
    init3();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len2 = len - extraBytes; i2 < len2; i2 += maxChunkLength) {
    parts.push(encodeChunk$1(uint8, i2, i2 + maxChunkLength > len2 ? len2 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup$1[tmp >> 2];
    output += lookup$1[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup$1[tmp >> 10];
    output += lookup$1[tmp >> 4 & 63];
    output += lookup$1[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read(buffer2, offset2, isLE, mLen, nBytes) {
  var e2, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer2[offset2 + i2];
  i2 += d2;
  e2 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer2[offset2 + i2], i2 += d2, nBits -= 8) {
  }
  m2 = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset2 + i2], i2 += d2, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
}
function write(buffer2, value, offset2, isLE, mLen, nBytes) {
  var e2, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c2 = Math.pow(2, -e2)) < 1) {
      e2--;
      c2 *= 2;
    }
    if (e2 + eBias >= 1) {
      value += rt2 / c2;
    } else {
      value += rt2 * Math.pow(2, 1 - eBias);
    }
    if (value * c2 >= 2) {
      e2++;
      c2 /= 2;
    }
    if (e2 + eBias >= eMax) {
      m2 = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m2 = (value * c2 - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset2 + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset2 + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
  }
  buffer2[offset2 + i2 - d2] |= s2 * 128;
}
var toString$3 = {}.toString;
var isArray$3 = Array.isArray || function(arr) {
  return toString$3.call(arr) == "[object Array]";
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
var INSPECT_MAX_BYTES = 50;
Buffer$2.TYPED_ARRAY_SUPPORT = globalThis.TYPED_ARRAY_SUPPORT !== void 0 ? globalThis.TYPED_ARRAY_SUPPORT : true;
function kMaxLength() {
  return Buffer$2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer$1(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer$2.prototype;
  } else {
    if (that === null) {
      that = new Buffer$2(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer$2(arg, encodingOrOffset, length) {
  if (!Buffer$2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$2)) {
    return new Buffer$2(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error("If encoding is specified then the first argument must be a string");
    }
    return allocUnsafe$1(this, arg);
  }
  return from$1(this, arg, encodingOrOffset, length);
}
Buffer$2.poolSize = 8192;
Buffer$2._augment = function(arr) {
  arr.__proto__ = Buffer$2.prototype;
  return arr;
};
function from$1(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer$1(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString$1(that, value, encodingOrOffset);
  }
  return fromObject$1(that, value);
}
Buffer$2.from = function(value, encodingOrOffset, length) {
  return from$1(null, value, encodingOrOffset, length);
};
if (Buffer$2.TYPED_ARRAY_SUPPORT) {
  Buffer$2.prototype.__proto__ = Uint8Array.prototype;
  Buffer$2.__proto__ = Uint8Array;
}
function assertSize(size2) {
  if (typeof size2 !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size2 < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size2, fill3, encoding) {
  assertSize(size2);
  if (size2 <= 0) {
    return createBuffer$1(that, size2);
  }
  if (fill3 !== void 0) {
    return typeof encoding === "string" ? createBuffer$1(that, size2).fill(fill3, encoding) : createBuffer$1(that, size2).fill(fill3);
  }
  return createBuffer$1(that, size2);
}
Buffer$2.alloc = function(size2, fill3, encoding) {
  return alloc(null, size2, fill3, encoding);
};
function allocUnsafe$1(that, size2) {
  assertSize(size2);
  that = createBuffer$1(that, size2 < 0 ? 0 : checked$1(size2) | 0);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT) {
    for (var i2 = 0; i2 < size2; ++i2) {
      that[i2] = 0;
    }
  }
  return that;
}
Buffer$2.allocUnsafe = function(size2) {
  return allocUnsafe$1(null, size2);
};
Buffer$2.allocUnsafeSlow = function(size2) {
  return allocUnsafe$1(null, size2);
};
function fromString$1(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer$2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength$2(string, encoding) | 0;
  that = createBuffer$1(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike$1(that, array) {
  var length = array.length < 0 ? 0 : checked$1(array.length) | 0;
  that = createBuffer$1(that, length);
  for (var i2 = 0; i2 < length; i2 += 1) {
    that[i2] = array[i2] & 255;
  }
  return that;
}
function fromArrayBuffer$1(that, array, byteOffset, length) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array);
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer$2.prototype;
  } else {
    that = fromArrayLike$1(that, array);
  }
  return that;
}
function fromObject$1(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked$1(obj.length) | 0;
    that = createBuffer$1(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan$1(obj.length)) {
        return createBuffer$1(that, 0);
      }
      return fromArrayLike$1(that, obj);
    }
    if (obj.type === "Buffer" && isArray$3(obj.data)) {
      return fromArrayLike$1(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked$1(length) {
  if (length >= kMaxLength()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  }
  return length | 0;
}
Buffer$2.isBuffer = isBuffer$1;
function internalIsBuffer(b2) {
  return !!(b2 != null && b2._isBuffer);
}
Buffer$2.compare = function compare(a2, b2) {
  if (!internalIsBuffer(a2) || !internalIsBuffer(b2)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a2 === b2)
    return 0;
  var x2 = a2.length;
  var y2 = b2.length;
  for (var i2 = 0, len = Math.min(x2, y2); i2 < len; ++i2) {
    if (a2[i2] !== b2[i2]) {
      x2 = a2[i2];
      y2 = b2[i2];
      break;
    }
  }
  if (x2 < y2)
    return -1;
  if (y2 < x2)
    return 1;
  return 0;
};
Buffer$2.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
};
Buffer$2.concat = function concat2(list, length) {
  if (!isArray$3(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer$2.alloc(0);
  }
  var i2;
  if (length === void 0) {
    length = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      length += list[i2].length;
    }
  }
  var buffer2 = Buffer$2.allocUnsafe(length);
  var pos = 0;
  for (i2 = 0; i2 < list.length; ++i2) {
    var buf = list[i2];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer2, pos);
    pos += buf.length;
  }
  return buffer2;
};
function byteLength$2(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes$1(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes$1(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$2.byteLength = byteLength$2;
function slowToString(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$2.prototype._isBuffer = true;
function swap(b2, n2, m2) {
  var i2 = b2[n2];
  b2[n2] = b2[m2];
  b2[m2] = i2;
}
Buffer$2.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 2) {
    swap(this, i2, i2 + 1);
  }
  return this;
};
Buffer$2.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 4) {
    swap(this, i2, i2 + 3);
    swap(this, i2 + 1, i2 + 2);
  }
  return this;
};
Buffer$2.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 8) {
    swap(this, i2, i2 + 7);
    swap(this, i2 + 1, i2 + 6);
    swap(this, i2 + 2, i2 + 5);
    swap(this, i2 + 3, i2 + 4);
  }
  return this;
};
Buffer$2.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0)
    return "";
  if (arguments.length === 0)
    return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};
Buffer$2.prototype.equals = function equals(b2) {
  if (!internalIsBuffer(b2))
    throw new TypeError("Argument must be a Buffer");
  if (this === b2)
    return true;
  return Buffer$2.compare(this, b2) === 0;
};
Buffer$2.prototype.inspect = function inspect4() {
  var str = "";
  var max2 = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString("hex", 0, max2).match(/.{2}/g).join(" ");
    if (this.length > max2)
      str += " ... ";
  }
  return "<Buffer " + str + ">";
};
Buffer$2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start === void 0) {
    start = 0;
  }
  if (end === void 0) {
    end = target ? target.length : 0;
  }
  if (thisStart === void 0) {
    thisStart = 0;
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target)
    return 0;
  var x2 = thisEnd - thisStart;
  var y2 = end - start;
  var len = Math.min(x2, y2);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);
  for (var i2 = 0; i2 < len; ++i2) {
    if (thisCopy[i2] !== targetCopy[i2]) {
      x2 = thisCopy[i2];
      y2 = targetCopy[i2];
      break;
    }
  }
  if (x2 < y2)
    return -1;
  if (y2 < x2)
    return 1;
  return 0;
};
function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
  if (buffer2.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer2.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer2.length + byteOffset;
  if (byteOffset >= buffer2.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer2.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer$2.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer$2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i3) {
    if (indexSize === 1) {
      return buf[i3];
    } else {
      return buf.readUInt16BE(i3 * indexSize);
    }
  }
  var i2;
  if (dir) {
    var foundIndex = -1;
    for (i2 = byteOffset; i2 < arrLength; i2++) {
      if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i2;
        if (i2 - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i2 -= i2 - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i2 = byteOffset; i2 >= 0; i2--) {
      var found = true;
      for (var j2 = 0; j2 < valLength; j2++) {
        if (read2(arr, i2 + j2) !== read2(val, j2)) {
          found = false;
          break;
        }
      }
      if (found)
        return i2;
    }
  }
  return -1;
}
Buffer$2.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer$2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer$2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset2, length) {
  offset2 = Number(offset2) || 0;
  var remaining = buf.length - offset2;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i2 = 0; i2 < length; ++i2) {
    var parsed = parseInt(string.substr(i2 * 2, 2), 16);
    if (isNaN(parsed))
      return i2;
    buf[offset2 + i2] = parsed;
  }
  return i2;
}
function utf8Write$1(buf, string, offset2, length) {
  return blitBuffer$1(utf8ToBytes$1(string, buf.length - offset2), buf, offset2, length);
}
function asciiWrite(buf, string, offset2, length) {
  return blitBuffer$1(asciiToBytes(string), buf, offset2, length);
}
function latin1Write(buf, string, offset2, length) {
  return asciiWrite(buf, string, offset2, length);
}
function base64Write(buf, string, offset2, length) {
  return blitBuffer$1(base64ToBytes(string), buf, offset2, length);
}
function ucs2Write(buf, string, offset2, length) {
  return blitBuffer$1(utf16leToBytes(string, buf.length - offset2), buf, offset2, length);
}
Buffer$2.prototype.write = function write2(string, offset2, length, encoding) {
  if (offset2 === void 0) {
    encoding = "utf8";
    length = this.length;
    offset2 = 0;
  } else if (length === void 0 && typeof offset2 === "string") {
    encoding = offset2;
    length = this.length;
    offset2 = 0;
  } else if (isFinite(offset2)) {
    offset2 = offset2 | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === void 0)
        encoding = "utf8";
    } else {
      encoding = length;
      length = void 0;
    }
  } else {
    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
  }
  var remaining = this.length - offset2;
  if (length === void 0 || length > remaining)
    length = remaining;
  if (string.length > 0 && (length < 0 || offset2 < 0) || offset2 > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding)
    encoding = "utf8";
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "hex":
        return hexWrite(this, string, offset2, length);
      case "utf8":
      case "utf-8":
        return utf8Write$1(this, string, offset2, length);
      case "ascii":
        return asciiWrite(this, string, offset2, length);
      case "latin1":
      case "binary":
        return latin1Write(this, string, offset2, length);
      case "base64":
        return base64Write(this, string, offset2, length);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write(this, string, offset2, length);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer$2.prototype.toJSON = function toJSON2() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray$1(buf);
  } else {
    return fromByteArray$1(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i2 = start;
  while (i2 < end) {
    var firstByte = buf[i2];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i2 + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i2 + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i2 + 1];
          thirdByte = buf[i2 + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i2 + 1];
          thirdByte = buf[i2 + 2];
          fourthByte = buf[i2 + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i2 += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i2 = 0;
  while (i2 < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i2 = start; i2 < end; ++i2) {
    ret += String.fromCharCode(buf[i2] & 127);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i2 = start; i2 < end; ++i2) {
    ret += String.fromCharCode(buf[i2]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i2 = start; i2 < end; ++i2) {
    out += toHex(buf[i2]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i2 = 0; i2 < bytes.length; i2 += 2) {
    res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
  }
  return res;
}
Buffer$2.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === void 0 ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0;
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0)
      end = 0;
  } else if (end > len) {
    end = len;
  }
  if (end < start)
    end = start;
  var newBuf;
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer$2.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer$2(sliceLen, void 0);
    for (var i2 = 0; i2 < sliceLen; ++i2) {
      newBuf[i2] = this[i2 + start];
    }
  }
  return newBuf;
};
function checkOffset(offset2, ext, length) {
  if (offset2 % 1 !== 0 || offset2 < 0)
    throw new RangeError("offset is not uint");
  if (offset2 + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
Buffer$2.prototype.readUIntLE = function readUIntLE(offset2, byteLength2, noAssert) {
  offset2 = offset2 | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert)
    checkOffset(offset2, byteLength2, this.length);
  var val = this[offset2];
  var mul4 = 1;
  var i2 = 0;
  while (++i2 < byteLength2 && (mul4 *= 256)) {
    val += this[offset2 + i2] * mul4;
  }
  return val;
};
Buffer$2.prototype.readUIntBE = function readUIntBE(offset2, byteLength2, noAssert) {
  offset2 = offset2 | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    checkOffset(offset2, byteLength2, this.length);
  }
  var val = this[offset2 + --byteLength2];
  var mul4 = 1;
  while (byteLength2 > 0 && (mul4 *= 256)) {
    val += this[offset2 + --byteLength2] * mul4;
  }
  return val;
};
Buffer$2.prototype.readUInt8 = function readUInt8(offset2, noAssert) {
  if (!noAssert)
    checkOffset(offset2, 1, this.length);
  return this[offset2];
};
Buffer$2.prototype.readUInt16LE = function readUInt16LE(offset2, noAssert) {
  if (!noAssert)
    checkOffset(offset2, 2, this.length);
  return this[offset2] | this[offset2 + 1] << 8;
};
Buffer$2.prototype.readUInt16BE = function readUInt16BE(offset2, noAssert) {
  if (!noAssert)
    checkOffset(offset2, 2, this.length);
  return this[offset2] << 8 | this[offset2 + 1];
};
Buffer$2.prototype.readUInt32LE = function readUInt32LE(offset2, noAssert) {
  if (!noAssert)
    checkOffset(offset2, 4, this.length);
  return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
};
Buffer$2.prototype.readUInt32BE = function readUInt32BE(offset2, noAssert) {
  if (!noAssert)
    checkOffset(offset2, 4, this.length);
  return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
};
Buffer$2.prototype.readIntLE = function readIntLE(offset2, byteLength2, noAssert) {
  offset2 = offset2 | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert)
    checkOffset(offset2, byteLength2, this.length);
  var val = this[offset2];
  var mul4 = 1;
  var i2 = 0;
  while (++i2 < byteLength2 && (mul4 *= 256)) {
    val += this[offset2 + i2] * mul4;
  }
  mul4 *= 128;
  if (val >= mul4)
    val -= Math.pow(2, 8 * byteLength2);
  return val;
};
Buffer$2.prototype.readIntBE = function readIntBE(offset2, byteLength2, noAssert) {
  offset2 = offset2 | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert)
    checkOffset(offset2, byteLength2, this.length);
  var i2 = byteLength2;
  var mul4 = 1;
  var val = this[offset2 + --i2];
  while (i2 > 0 && (mul4 *= 256)) {
    val += this[offset2 + --i2] * mul4;
  }
  mul4 *= 128;
  if (val >= mul4)
    val -= Math.pow(2, 8 * byteLength2);
  return val;
};
Buffer$2.prototype.readInt8 = function readInt8(offset2, noAssert) {
  if (!noAssert)
    checkOffset(offset2, 1, this.length);
  if (!(this[offset2] & 128))
    return this[offset2];
  return (255 - this[offset2] + 1) * -1;
};
Buffer$2.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
  if (!noAssert)
    checkOffset(offset2, 2, this.length);
  var val = this[offset2] | this[offset2 + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer$2.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
  if (!noAssert)
    checkOffset(offset2, 2, this.length);
  var val = this[offset2 + 1] | this[offset2] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer$2.prototype.readInt32LE = function readInt32LE(offset2, noAssert) {
  if (!noAssert)
    checkOffset(offset2, 4, this.length);
  return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
};
Buffer$2.prototype.readInt32BE = function readInt32BE(offset2, noAssert) {
  if (!noAssert)
    checkOffset(offset2, 4, this.length);
  return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
};
Buffer$2.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
  if (!noAssert)
    checkOffset(offset2, 4, this.length);
  return read(this, offset2, true, 23, 4);
};
Buffer$2.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
  if (!noAssert)
    checkOffset(offset2, 4, this.length);
  return read(this, offset2, false, 23, 4);
};
Buffer$2.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
  if (!noAssert)
    checkOffset(offset2, 8, this.length);
  return read(this, offset2, true, 52, 8);
};
Buffer$2.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
  if (!noAssert)
    checkOffset(offset2, 8, this.length);
  return read(this, offset2, false, 52, 8);
};
function checkInt(buf, value, offset2, ext, max2, min2) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max2 || value < min2)
    throw new RangeError('"value" argument is out of bounds');
  if (offset2 + ext > buf.length)
    throw new RangeError("Index out of range");
}
Buffer$2.prototype.writeUIntLE = function writeUIntLE(value, offset2, byteLength2, noAssert) {
  value = +value;
  offset2 = offset2 | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
    checkInt(this, value, offset2, byteLength2, maxBytes, 0);
  }
  var mul4 = 1;
  var i2 = 0;
  this[offset2] = value & 255;
  while (++i2 < byteLength2 && (mul4 *= 256)) {
    this[offset2 + i2] = value / mul4 & 255;
  }
  return offset2 + byteLength2;
};
Buffer$2.prototype.writeUIntBE = function writeUIntBE(value, offset2, byteLength2, noAssert) {
  value = +value;
  offset2 = offset2 | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
    checkInt(this, value, offset2, byteLength2, maxBytes, 0);
  }
  var i2 = byteLength2 - 1;
  var mul4 = 1;
  this[offset2 + i2] = value & 255;
  while (--i2 >= 0 && (mul4 *= 256)) {
    this[offset2 + i2] = value / mul4 & 255;
  }
  return offset2 + byteLength2;
};
Buffer$2.prototype.writeUInt8 = function writeUInt8(value, offset2, noAssert) {
  value = +value;
  offset2 = offset2 | 0;
  if (!noAssert)
    checkInt(this, value, offset2, 1, 255, 0);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT)
    value = Math.floor(value);
  this[offset2] = value & 255;
  return offset2 + 1;
};
function objectWriteUInt16(buf, value, offset2, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i2 = 0, j2 = Math.min(buf.length - offset2, 2); i2 < j2; ++i2) {
    buf[offset2 + i2] = (value & 255 << 8 * (littleEndian ? i2 : 1 - i2)) >>> (littleEndian ? i2 : 1 - i2) * 8;
  }
}
Buffer$2.prototype.writeUInt16LE = function writeUInt16LE(value, offset2, noAssert) {
  value = +value;
  offset2 = offset2 | 0;
  if (!noAssert)
    checkInt(this, value, offset2, 2, 65535, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset2, true);
  }
  return offset2 + 2;
};
Buffer$2.prototype.writeUInt16BE = function writeUInt16BE(value, offset2, noAssert) {
  value = +value;
  offset2 = offset2 | 0;
  if (!noAssert)
    checkInt(this, value, offset2, 2, 65535, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value >>> 8;
    this[offset2 + 1] = value & 255;
  } else {
    objectWriteUInt16(this, value, offset2, false);
  }
  return offset2 + 2;
};
function objectWriteUInt32(buf, value, offset2, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i2 = 0, j2 = Math.min(buf.length - offset2, 4); i2 < j2; ++i2) {
    buf[offset2 + i2] = value >>> (littleEndian ? i2 : 3 - i2) * 8 & 255;
  }
}
Buffer$2.prototype.writeUInt32LE = function writeUInt32LE(value, offset2, noAssert) {
  value = +value;
  offset2 = offset2 | 0;
  if (!noAssert)
    checkInt(this, value, offset2, 4, 4294967295, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2 + 3] = value >>> 24;
    this[offset2 + 2] = value >>> 16;
    this[offset2 + 1] = value >>> 8;
    this[offset2] = value & 255;
  } else {
    objectWriteUInt32(this, value, offset2, true);
  }
  return offset2 + 4;
};
Buffer$2.prototype.writeUInt32BE = function writeUInt32BE(value, offset2, noAssert) {
  value = +value;
  offset2 = offset2 | 0;
  if (!noAssert)
    checkInt(this, value, offset2, 4, 4294967295, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value >>> 24;
    this[offset2 + 1] = value >>> 16;
    this[offset2 + 2] = value >>> 8;
    this[offset2 + 3] = value & 255;
  } else {
    objectWriteUInt32(this, value, offset2, false);
  }
  return offset2 + 4;
};
Buffer$2.prototype.writeIntLE = function writeIntLE(value, offset2, byteLength2, noAssert) {
  value = +value;
  offset2 = offset2 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength2 - 1);
    checkInt(this, value, offset2, byteLength2, limit - 1, -limit);
  }
  var i2 = 0;
  var mul4 = 1;
  var sub = 0;
  this[offset2] = value & 255;
  while (++i2 < byteLength2 && (mul4 *= 256)) {
    if (value < 0 && sub === 0 && this[offset2 + i2 - 1] !== 0) {
      sub = 1;
    }
    this[offset2 + i2] = (value / mul4 >> 0) - sub & 255;
  }
  return offset2 + byteLength2;
};
Buffer$2.prototype.writeIntBE = function writeIntBE(value, offset2, byteLength2, noAssert) {
  value = +value;
  offset2 = offset2 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength2 - 1);
    checkInt(this, value, offset2, byteLength2, limit - 1, -limit);
  }
  var i2 = byteLength2 - 1;
  var mul4 = 1;
  var sub = 0;
  this[offset2 + i2] = value & 255;
  while (--i2 >= 0 && (mul4 *= 256)) {
    if (value < 0 && sub === 0 && this[offset2 + i2 + 1] !== 0) {
      sub = 1;
    }
    this[offset2 + i2] = (value / mul4 >> 0) - sub & 255;
  }
  return offset2 + byteLength2;
};
Buffer$2.prototype.writeInt8 = function writeInt8(value, offset2, noAssert) {
  value = +value;
  offset2 = offset2 | 0;
  if (!noAssert)
    checkInt(this, value, offset2, 1, 127, -128);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT)
    value = Math.floor(value);
  if (value < 0)
    value = 255 + value + 1;
  this[offset2] = value & 255;
  return offset2 + 1;
};
Buffer$2.prototype.writeInt16LE = function writeInt16LE(value, offset2, noAssert) {
  value = +value;
  offset2 = offset2 | 0;
  if (!noAssert)
    checkInt(this, value, offset2, 2, 32767, -32768);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset2, true);
  }
  return offset2 + 2;
};
Buffer$2.prototype.writeInt16BE = function writeInt16BE(value, offset2, noAssert) {
  value = +value;
  offset2 = offset2 | 0;
  if (!noAssert)
    checkInt(this, value, offset2, 2, 32767, -32768);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value >>> 8;
    this[offset2 + 1] = value & 255;
  } else {
    objectWriteUInt16(this, value, offset2, false);
  }
  return offset2 + 2;
};
Buffer$2.prototype.writeInt32LE = function writeInt32LE(value, offset2, noAssert) {
  value = +value;
  offset2 = offset2 | 0;
  if (!noAssert)
    checkInt(this, value, offset2, 4, 2147483647, -2147483648);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    this[offset2 + 2] = value >>> 16;
    this[offset2 + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset2, true);
  }
  return offset2 + 4;
};
Buffer$2.prototype.writeInt32BE = function writeInt32BE(value, offset2, noAssert) {
  value = +value;
  offset2 = offset2 | 0;
  if (!noAssert)
    checkInt(this, value, offset2, 4, 2147483647, -2147483648);
  if (value < 0)
    value = 4294967295 + value + 1;
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value >>> 24;
    this[offset2 + 1] = value >>> 16;
    this[offset2 + 2] = value >>> 8;
    this[offset2 + 3] = value & 255;
  } else {
    objectWriteUInt32(this, value, offset2, false);
  }
  return offset2 + 4;
};
function checkIEEE754(buf, value, offset2, ext, max2, min2) {
  if (offset2 + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset2 < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset2, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset2, 4);
  }
  write(buf, value, offset2, littleEndian, 23, 4);
  return offset2 + 4;
}
Buffer$2.prototype.writeFloatLE = function writeFloatLE(value, offset2, noAssert) {
  return writeFloat(this, value, offset2, true, noAssert);
};
Buffer$2.prototype.writeFloatBE = function writeFloatBE(value, offset2, noAssert) {
  return writeFloat(this, value, offset2, false, noAssert);
};
function writeDouble(buf, value, offset2, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset2, 8);
  }
  write(buf, value, offset2, littleEndian, 52, 8);
  return offset2 + 8;
}
Buffer$2.prototype.writeDoubleLE = function writeDoubleLE(value, offset2, noAssert) {
  return writeDouble(this, value, offset2, true, noAssert);
};
Buffer$2.prototype.writeDoubleBE = function writeDoubleBE(value, offset2, noAssert) {
  return writeDouble(this, value, offset2, false, noAssert);
};
Buffer$2.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start)
    start = 0;
  if (!end && end !== 0)
    end = this.length;
  if (targetStart >= target.length)
    targetStart = target.length;
  if (!targetStart)
    targetStart = 0;
  if (end > 0 && end < start)
    end = start;
  if (end === start)
    return 0;
  if (target.length === 0 || this.length === 0)
    return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start < 0 || start >= this.length)
    throw new RangeError("sourceStart out of bounds");
  if (end < 0)
    throw new RangeError("sourceEnd out of bounds");
  if (end > this.length)
    end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }
  var len = end - start;
  var i2;
  if (this === target && start < targetStart && targetStart < end) {
    for (i2 = len - 1; i2 >= 0; --i2) {
      target[i2 + targetStart] = this[i2 + start];
    }
  } else if (len < 1e3 || !Buffer$2.TYPED_ARRAY_SUPPORT) {
    for (i2 = 0; i2 < len; ++i2) {
      target[i2 + targetStart] = this[i2 + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }
  return len;
};
Buffer$2.prototype.fill = function fill(val, start, end, encoding) {
  if (typeof val === "string") {
    if (typeof start === "string") {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === "string") {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code2 = val.charCodeAt(0);
      if (code2 < 256) {
        val = code2;
      }
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer$2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError("Out of range index");
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === void 0 ? this.length : end >>> 0;
  if (!val)
    val = 0;
  var i2;
  if (typeof val === "number") {
    for (i2 = start; i2 < end; ++i2) {
      this[i2] = val;
    }
  } else {
    var bytes = internalIsBuffer(val) ? val : utf8ToBytes$1(new Buffer$2(val, encoding).toString());
    var len = bytes.length;
    for (i2 = 0; i2 < end - start; ++i2) {
      this[i2 + start] = bytes[i2 % len];
    }
  }
  return this;
};
var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
function base64clean(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex(n2) {
  if (n2 < 16)
    return "0" + n2.toString(16);
  return n2.toString(16);
}
function utf8ToBytes$1(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i2 = 0; i2 < length; ++i2) {
    codePoint = string.charCodeAt(i2);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i2 + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i2 = 0; i2 < str.length; ++i2) {
    byteArray.push(str.charCodeAt(i2) & 255);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c2, hi, lo;
  var byteArray = [];
  for (var i2 = 0; i2 < str.length; ++i2) {
    if ((units -= 2) < 0)
      break;
    c2 = str.charCodeAt(i2);
    hi = c2 >> 8;
    lo = c2 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray$1(base64clean(str));
}
function blitBuffer$1(src, dst, offset2, length) {
  for (var i2 = 0; i2 < length; ++i2) {
    if (i2 + offset2 >= dst.length || i2 >= src.length)
      break;
    dst[i2 + offset2] = src[i2];
  }
  return i2;
}
function isnan$1(val) {
  return val !== val;
}
function isBuffer$1(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
var isTypedarray = isTypedArray$1;
isTypedArray$1.strict = isStrictTypedArray;
isTypedArray$1.loose = isLooseTypedArray;
var toString$2 = Object.prototype.toString;
var names = {
  "[object Int8Array]": true,
  "[object Int16Array]": true,
  "[object Int32Array]": true,
  "[object Uint8Array]": true,
  "[object Uint8ClampedArray]": true,
  "[object Uint16Array]": true,
  "[object Uint32Array]": true,
  "[object Float32Array]": true,
  "[object Float64Array]": true
};
function isTypedArray$1(arr) {
  return isStrictTypedArray(arr) || isLooseTypedArray(arr);
}
function isStrictTypedArray(arr) {
  return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
}
function isLooseTypedArray(arr) {
  return names[toString$2.call(arr)];
}
var isTypedArray = isTypedarray.strict;
var typedarrayToBuffer = function typedarrayToBuffer2(arr) {
  if (isTypedArray(arr)) {
    var buf = Buffer$2.from(arr.buffer);
    if (arr.byteLength !== arr.buffer.byteLength) {
      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
    }
    return buf;
  } else {
    return Buffer$2.from(arr);
  }
};
const ENC_HEX = "hex";
const ENC_UTF8 = "utf8";
const STRING_ZERO = "0";
function bufferToArray(buf) {
  return new Uint8Array(buf);
}
function bufferToHex(buf, prefixed = false) {
  const hex = buf.toString(ENC_HEX);
  return prefixed ? addHexPrefix(hex) : hex;
}
function bufferToUtf8(buf) {
  return buf.toString(ENC_UTF8);
}
function arrayToBuffer(arr) {
  return typedarrayToBuffer(arr);
}
function arrayToHex(arr, prefixed = false) {
  return bufferToHex(arrayToBuffer(arr), prefixed);
}
function arrayToUtf8(arr) {
  return bufferToUtf8(arrayToBuffer(arr));
}
function hexToBuffer(hex) {
  return Buffer$2.from(removeHexPrefix(hex), ENC_HEX);
}
function hexToArray(hex) {
  return bufferToArray(hexToBuffer(hex));
}
function utf8ToBuffer(utf8) {
  return Buffer$2.from(utf8, ENC_UTF8);
}
function utf8ToArray(utf8) {
  return bufferToArray(utf8ToBuffer(utf8));
}
function utf8ToHex(utf8, prefixed = false) {
  return bufferToHex(utf8ToBuffer(utf8), prefixed);
}
function isHexString$1(str, length) {
  if (typeof str !== "string" || !str.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && str.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
function concatArrays(...args) {
  let result = [];
  args.forEach((arg) => result = result.concat(Array.from(arg)));
  return new Uint8Array([...result]);
}
function calcByteLength(length, byteSize = 8) {
  const remainder = length % byteSize;
  return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;
}
function sanitizeBytes(str, byteSize = 8, padding2 = STRING_ZERO) {
  return padLeft(str, calcByteLength(str.length, byteSize), padding2);
}
function padLeft(str, length, padding2 = STRING_ZERO) {
  return padString(str, length, true, padding2);
}
function removeHexPrefix(hex) {
  return hex.replace(/^0x/, "");
}
function addHexPrefix(hex) {
  return hex.startsWith("0x") ? hex : `0x${hex}`;
}
function sanitizeHex$1(hex) {
  hex = removeHexPrefix(hex);
  hex = sanitizeBytes(hex, 2);
  if (hex) {
    hex = addHexPrefix(hex);
  }
  return hex;
}
function removeHexLeadingZeros$1(hex) {
  const prefixed = hex.startsWith("0x");
  hex = removeHexPrefix(hex);
  hex = hex.startsWith(STRING_ZERO) ? hex.substring(1) : hex;
  return prefixed ? addHexPrefix(hex) : hex;
}
function padString(str, length, left, padding2 = STRING_ZERO) {
  const diff = length - str.length;
  let result = str;
  if (diff > 0) {
    const pad2 = padding2.repeat(diff);
    result = left ? pad2 + str : str + pad2;
  }
  return result;
}
function convertArrayBufferToBuffer(arrBuf) {
  return arrayToBuffer(new Uint8Array(arrBuf));
}
function convertArrayBufferToHex(arrBuf, noPrefix) {
  return arrayToHex(new Uint8Array(arrBuf), !noPrefix);
}
function convertBufferToArrayBuffer(buf) {
  return bufferToArray(buf).buffer;
}
function convertUtf8ToBuffer(utf8) {
  return utf8ToBuffer(utf8);
}
function convertUtf8ToHex(utf8, noPrefix) {
  return utf8ToHex(utf8, !noPrefix);
}
function convertHexToArrayBuffer(hex) {
  return hexToArray(hex).buffer;
}
function convertNumberToHex(num, noPrefix) {
  const hex = removeHexPrefix(sanitizeHex$1(new BN(num).toString(16)));
  return noPrefix ? hex : addHexPrefix(hex);
}
var cjs$1 = {};
var crypto = {};
Object.defineProperty(crypto, "__esModule", { value: true });
crypto.isBrowserCryptoAvailable = crypto.getSubtleCrypto = crypto.getBrowerCrypto = void 0;
function getBrowerCrypto() {
  return (globalThis === null || globalThis === void 0 ? void 0 : globalThis.crypto) || (globalThis === null || globalThis === void 0 ? void 0 : globalThis.msCrypto) || {};
}
crypto.getBrowerCrypto = getBrowerCrypto;
function getSubtleCrypto() {
  const browserCrypto = getBrowerCrypto();
  return browserCrypto.subtle || browserCrypto.webkitSubtle;
}
crypto.getSubtleCrypto = getSubtleCrypto;
function isBrowserCryptoAvailable() {
  return !!getBrowerCrypto() && !!getSubtleCrypto();
}
crypto.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
var env = {};
Object.defineProperty(env, "__esModule", { value: true });
env.isBrowser = env.isNode = env.isReactNative = void 0;
function isReactNative() {
  return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
}
env.isReactNative = isReactNative;
function isNode$2() {
  return typeof browser$1$1 !== "undefined" && typeof browser$1$1.versions !== "undefined" && typeof browser$1$1.versions.node !== "undefined";
}
env.isNode = isNode$2;
function isBrowser() {
  return !isReactNative() && !isNode$2();
}
env.isBrowser = isBrowser;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m2[k2];
    } });
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !exports2.hasOwnProperty(p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(crypto, exports);
  __exportStar(env, exports);
})(cjs$1);
function payloadId$1() {
  const date = Date.now() * Math.pow(10, 3);
  const extra = Math.floor(Math.random() * Math.pow(10, 3));
  return date + extra;
}
function sanitizeHex(hex) {
  return sanitizeHex$1(hex);
}
function removeHexLeadingZeros(hex) {
  return removeHexLeadingZeros$1(addHexPrefix(hex));
}
const payloadId = payloadId$1;
function uuid() {
  const result = ((a2, b2) => {
    for (b2 = a2 = ""; a2++ < 36; b2 += a2 * 51 & 52 ? (a2 ^ 15 ? 8 ^ Math.random() * (a2 ^ 20 ? 16 : 4) : 4).toString(16) : "-") {
    }
    return b2;
  })();
  return result;
}
function isEmptyString(value) {
  return value === "" || typeof value === "string" && value.trim() === "";
}
function isEmptyArray(array) {
  return !(array && array.length);
}
function isHexString(value, length) {
  return isHexString$1(value, length);
}
function isJsonRpcRequest(object) {
  return typeof object.method !== "undefined";
}
function isJsonRpcResponseSuccess(object) {
  return typeof object.result !== "undefined";
}
function isJsonRpcResponseError(object) {
  return typeof object.error !== "undefined";
}
function isInternalEvent(object) {
  return typeof object.event !== "undefined";
}
function isReservedEvent(event) {
  return reservedEvents.includes(event) || event.startsWith("wc_");
}
function isSilentPayload(request2) {
  if (request2.method.startsWith("wc_")) {
    return true;
  }
  if (signingMethods.includes(request2.method)) {
    return false;
  }
  return true;
}
function toChecksumAddress(address) {
  address = removeHexPrefix(address.toLowerCase());
  const hash2 = removeHexPrefix(sha3$1.exports.keccak_256(convertUtf8ToBuffer(address)));
  let checksum = "";
  for (let i2 = 0; i2 < address.length; i2++) {
    if (parseInt(hash2[i2], 16) > 7) {
      checksum += address[i2].toUpperCase();
    } else {
      checksum += address[i2];
    }
  }
  return addHexPrefix(checksum);
}
const isValidAddress = (address) => {
  if (!address) {
    return false;
  } else if (address.toLowerCase().substring(0, 2) !== "0x") {
    return false;
  } else if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
    return false;
  } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
    return true;
  } else {
    return address === toChecksumAddress(address);
  }
};
function parsePersonalSign(params) {
  if (!isEmptyArray(params) && !isHexString(params[0])) {
    params[0] = convertUtf8ToHex(params[0]);
  }
  return params;
}
function parseTransactionData(txData) {
  if (typeof txData.type !== "undefined" && txData.type !== "0")
    return txData;
  if (typeof txData.from === "undefined" || !isValidAddress(txData.from)) {
    throw new Error(`Transaction object must include a valid 'from' value.`);
  }
  function parseHexValues(value) {
    let result = value;
    if (typeof value === "number" || typeof value === "string" && !isEmptyString(value)) {
      if (!isHexString(value)) {
        result = convertNumberToHex(value);
      } else if (typeof value === "string") {
        result = sanitizeHex(value);
      }
    }
    if (typeof result === "string") {
      result = removeHexLeadingZeros(result);
    }
    return result;
  }
  const txDataRPC = {
    from: sanitizeHex(txData.from),
    to: typeof txData.to === "undefined" ? "" : sanitizeHex(txData.to),
    gasPrice: typeof txData.gasPrice === "undefined" ? "" : parseHexValues(txData.gasPrice),
    gas: typeof txData.gas === "undefined" ? typeof txData.gasLimit === "undefined" ? "" : parseHexValues(txData.gasLimit) : parseHexValues(txData.gas),
    value: typeof txData.value === "undefined" ? "" : parseHexValues(txData.value),
    nonce: typeof txData.nonce === "undefined" ? "" : parseHexValues(txData.nonce),
    data: typeof txData.data === "undefined" ? "" : sanitizeHex(txData.data) || "0x"
  };
  const prunable = ["gasPrice", "gas", "value", "nonce"];
  Object.keys(txDataRPC).forEach((key2) => {
    if (!txDataRPC[key2].trim().length && prunable.includes(key2)) {
      delete txDataRPC[key2];
    }
  });
  return txDataRPC;
}
function formatRpcError(error) {
  const message = error.message || "Failed or Rejected Request";
  let code2 = -32e3;
  if (error && !error.code) {
    switch (message) {
      case "Parse error":
        code2 = -32700;
        break;
      case "Invalid request":
        code2 = -32600;
        break;
      case "Method not found":
        code2 = -32601;
        break;
      case "Invalid params":
        code2 = -32602;
        break;
      case "Internal error":
        code2 = -32603;
        break;
      default:
        code2 = -32e3;
        break;
    }
  }
  const result = {
    code: code2,
    message
  };
  return result;
}
var queryString = {};
var strictUriEncode = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x2) => `%${x2.charCodeAt(0).toString(16).toUpperCase()}`);
var token = "%[a-f0-9]{2}";
var singleMatcher = new RegExp(token, "gi");
var multiMatcher = new RegExp("(" + token + ")+", "gi");
function decodeComponents(components, split) {
  try {
    return decodeURIComponent(components.join(""));
  } catch (err) {
  }
  if (components.length === 1) {
    return components;
  }
  split = split || 1;
  var left = components.slice(0, split);
  var right = components.slice(split);
  return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}
function decode(input) {
  try {
    return decodeURIComponent(input);
  } catch (err) {
    var tokens = input.match(singleMatcher);
    for (var i2 = 1; i2 < tokens.length; i2++) {
      input = decodeComponents(tokens, i2).join("");
      tokens = input.match(singleMatcher);
    }
    return input;
  }
}
function customDecodeURIComponent(input) {
  var replaceMap = {
    "%FE%FF": "\uFFFD\uFFFD",
    "%FF%FE": "\uFFFD\uFFFD"
  };
  var match = multiMatcher.exec(input);
  while (match) {
    try {
      replaceMap[match[0]] = decodeURIComponent(match[0]);
    } catch (err) {
      var result = decode(match[0]);
      if (result !== match[0]) {
        replaceMap[match[0]] = result;
      }
    }
    match = multiMatcher.exec(input);
  }
  replaceMap["%C2"] = "\uFFFD";
  var entries = Object.keys(replaceMap);
  for (var i2 = 0; i2 < entries.length; i2++) {
    var key2 = entries[i2];
    input = input.replace(new RegExp(key2, "g"), replaceMap[key2]);
  }
  return input;
}
var decodeUriComponent = function(encodedURI) {
  if (typeof encodedURI !== "string") {
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
  }
  try {
    encodedURI = encodedURI.replace(/\+/g, " ");
    return decodeURIComponent(encodedURI);
  } catch (err) {
    return customDecodeURIComponent(encodedURI);
  }
};
var splitOnFirst = (string, separator) => {
  if (!(typeof string === "string" && typeof separator === "string")) {
    throw new TypeError("Expected the arguments to be of type `string`");
  }
  if (separator === "") {
    return [string];
  }
  const separatorIndex = string.indexOf(separator);
  if (separatorIndex === -1) {
    return [string];
  }
  return [
    string.slice(0, separatorIndex),
    string.slice(separatorIndex + separator.length)
  ];
};
(function(exports) {
  const strictUriEncode$1 = strictUriEncode;
  const decodeComponent = decodeUriComponent;
  const splitOnFirst$1 = splitOnFirst;
  const isNullOrUndefined = (value) => value === null || value === void 0;
  function encoderForArrayFormat(options) {
    switch (options.arrayFormat) {
      case "index":
        return (key2) => (result, value) => {
          const index2 = result.length;
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode4(key2, options), "[", index2, "]"].join("")];
          }
          return [
            ...result,
            [encode4(key2, options), "[", encode4(index2, options), "]=", encode4(value, options)].join("")
          ];
        };
      case "bracket":
        return (key2) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode4(key2, options), "[]"].join("")];
          }
          return [...result, [encode4(key2, options), "[]=", encode4(value, options)].join("")];
        };
      case "comma":
      case "separator":
        return (key2) => (result, value) => {
          if (value === null || value === void 0 || value.length === 0) {
            return result;
          }
          if (result.length === 0) {
            return [[encode4(key2, options), "=", encode4(value, options)].join("")];
          }
          return [[result, encode4(value, options)].join(options.arrayFormatSeparator)];
        };
      default:
        return (key2) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, encode4(key2, options)];
          }
          return [...result, [encode4(key2, options), "=", encode4(value, options)].join("")];
        };
    }
  }
  function parserForArrayFormat(options) {
    let result;
    switch (options.arrayFormat) {
      case "index":
        return (key2, value, accumulator) => {
          result = /\[(\d*)\]$/.exec(key2);
          key2 = key2.replace(/\[\d*\]$/, "");
          if (!result) {
            accumulator[key2] = value;
            return;
          }
          if (accumulator[key2] === void 0) {
            accumulator[key2] = {};
          }
          accumulator[key2][result[1]] = value;
        };
      case "bracket":
        return (key2, value, accumulator) => {
          result = /(\[\])$/.exec(key2);
          key2 = key2.replace(/\[\]$/, "");
          if (!result) {
            accumulator[key2] = value;
            return;
          }
          if (accumulator[key2] === void 0) {
            accumulator[key2] = [value];
            return;
          }
          accumulator[key2] = [].concat(accumulator[key2], value);
        };
      case "comma":
      case "separator":
        return (key2, value, accumulator) => {
          const isArray2 = typeof value === "string" && value.split("").indexOf(options.arrayFormatSeparator) > -1;
          const newValue = isArray2 ? value.split(options.arrayFormatSeparator).map((item) => decode2(item, options)) : value === null ? value : decode2(value, options);
          accumulator[key2] = newValue;
        };
      default:
        return (key2, value, accumulator) => {
          if (accumulator[key2] === void 0) {
            accumulator[key2] = value;
            return;
          }
          accumulator[key2] = [].concat(accumulator[key2], value);
        };
    }
  }
  function validateArrayFormatSeparator(value) {
    if (typeof value !== "string" || value.length !== 1) {
      throw new TypeError("arrayFormatSeparator must be single character string");
    }
  }
  function encode4(value, options) {
    if (options.encode) {
      return options.strict ? strictUriEncode$1(value) : encodeURIComponent(value);
    }
    return value;
  }
  function decode2(value, options) {
    if (options.decode) {
      return decodeComponent(value);
    }
    return value;
  }
  function keysSorter(input) {
    if (Array.isArray(input)) {
      return input.sort();
    }
    if (typeof input === "object") {
      return keysSorter(Object.keys(input)).sort((a2, b2) => Number(a2) - Number(b2)).map((key2) => input[key2]);
    }
    return input;
  }
  function removeHash(input) {
    const hashStart = input.indexOf("#");
    if (hashStart !== -1) {
      input = input.slice(0, hashStart);
    }
    return input;
  }
  function getHash(url) {
    let hash2 = "";
    const hashStart = url.indexOf("#");
    if (hashStart !== -1) {
      hash2 = url.slice(hashStart);
    }
    return hash2;
  }
  function extract(input) {
    input = removeHash(input);
    const queryStart = input.indexOf("?");
    if (queryStart === -1) {
      return "";
    }
    return input.slice(queryStart + 1);
  }
  function parseValue(value, options) {
    if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
      value = Number(value);
    } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
      value = value.toLowerCase() === "true";
    }
    return value;
  }
  function parse2(input, options) {
    options = Object.assign({
      decode: true,
      sort: true,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: false,
      parseBooleans: false
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const formatter = parserForArrayFormat(options);
    const ret = /* @__PURE__ */ Object.create(null);
    if (typeof input !== "string") {
      return ret;
    }
    input = input.trim().replace(/^[?#&]/, "");
    if (!input) {
      return ret;
    }
    for (const param of input.split("&")) {
      let [key2, value] = splitOnFirst$1(options.decode ? param.replace(/\+/g, " ") : param, "=");
      value = value === void 0 ? null : ["comma", "separator"].includes(options.arrayFormat) ? value : decode2(value, options);
      formatter(decode2(key2, options), value, ret);
    }
    for (const key2 of Object.keys(ret)) {
      const value = ret[key2];
      if (typeof value === "object" && value !== null) {
        for (const k2 of Object.keys(value)) {
          value[k2] = parseValue(value[k2], options);
        }
      } else {
        ret[key2] = parseValue(value, options);
      }
    }
    if (options.sort === false) {
      return ret;
    }
    return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key2) => {
      const value = ret[key2];
      if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
        result[key2] = keysSorter(value);
      } else {
        result[key2] = value;
      }
      return result;
    }, /* @__PURE__ */ Object.create(null));
  }
  exports.extract = extract;
  exports.parse = parse2;
  exports.stringify = (object, options) => {
    if (!object) {
      return "";
    }
    options = Object.assign({
      encode: true,
      strict: true,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const shouldFilter = (key2) => options.skipNull && isNullOrUndefined(object[key2]) || options.skipEmptyString && object[key2] === "";
    const formatter = encoderForArrayFormat(options);
    const objectCopy = {};
    for (const key2 of Object.keys(object)) {
      if (!shouldFilter(key2)) {
        objectCopy[key2] = object[key2];
      }
    }
    const keys = Object.keys(objectCopy);
    if (options.sort !== false) {
      keys.sort(options.sort);
    }
    return keys.map((key2) => {
      const value = object[key2];
      if (value === void 0) {
        return "";
      }
      if (value === null) {
        return encode4(key2, options);
      }
      if (Array.isArray(value)) {
        return value.reduce(formatter(key2), []).join("&");
      }
      return encode4(key2, options) + "=" + encode4(value, options);
    }).filter((x2) => x2.length > 0).join("&");
  };
  exports.parseUrl = (input, options) => {
    options = Object.assign({
      decode: true
    }, options);
    const [url, hash2] = splitOnFirst$1(input, "#");
    return Object.assign({
      url: url.split("?")[0] || "",
      query: parse2(extract(input), options)
    }, options && options.parseFragmentIdentifier && hash2 ? { fragmentIdentifier: decode2(hash2, options) } : {});
  };
  exports.stringifyUrl = (input, options) => {
    options = Object.assign({
      encode: true,
      strict: true
    }, options);
    const url = removeHash(input.url).split("?")[0] || "";
    const queryFromUrl = exports.extract(input.url);
    const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
    const query = Object.assign(parsedQueryFromUrl, input.query);
    let queryString2 = exports.stringify(query, options);
    if (queryString2) {
      queryString2 = `?${queryString2}`;
    }
    let hash2 = getHash(input.url);
    if (input.fragmentIdentifier) {
      hash2 = `#${encode4(input.fragmentIdentifier, options)}`;
    }
    return `${url}${queryString2}${hash2}`;
  };
})(queryString);
function getQueryString(url) {
  const pathEnd = url.indexOf("?") !== -1 ? url.indexOf("?") : void 0;
  const queryString2 = typeof pathEnd !== "undefined" ? url.substr(pathEnd) : "";
  return queryString2;
}
function appendToQueryString(queryString2, newQueryParams) {
  let queryParams = parseQueryString(queryString2);
  queryParams = Object.assign(Object.assign({}, queryParams), newQueryParams);
  queryString2 = formatQueryString(queryParams);
  return queryString2;
}
function parseQueryString(queryString$1) {
  return queryString.parse(queryString$1);
}
function formatQueryString(queryParams) {
  return queryString.stringify(queryParams);
}
function isWalletConnectSession(object) {
  return typeof object.bridge !== "undefined";
}
function parseWalletConnectUri(str) {
  const pathStart = str.indexOf(":");
  const pathEnd = str.indexOf("?") !== -1 ? str.indexOf("?") : void 0;
  const protocol = str.substring(0, pathStart);
  const path = str.substring(pathStart + 1, pathEnd);
  function parseRequiredParams(path2) {
    const separator = "@";
    const values = path2.split(separator);
    const requiredParams2 = {
      handshakeTopic: values[0],
      version: parseInt(values[1], 10)
    };
    return requiredParams2;
  }
  const requiredParams = parseRequiredParams(path);
  const queryString2 = typeof pathEnd !== "undefined" ? str.substr(pathEnd) : "";
  function parseQueryParams(queryString3) {
    const result2 = parseQueryString(queryString3);
    const parameters = {
      key: result2.key || "",
      bridge: result2.bridge || ""
    };
    return parameters;
  }
  const queryParams = parseQueryParams(queryString2);
  const result = Object.assign(Object.assign({ protocol }, requiredParams), queryParams);
  return result;
}
var browser$1 = function() {
  throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object");
};
class NetworkMonitor {
  constructor() {
    this._eventEmitters = [];
    if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined") {
      window.addEventListener("online", () => this.trigger("online"));
      window.addEventListener("offline", () => this.trigger("offline"));
    }
  }
  on(event, callback) {
    this._eventEmitters.push({
      event,
      callback
    });
  }
  trigger(event) {
    let eventEmitters = [];
    if (event) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
    }
    eventEmitters.forEach((eventEmitter) => {
      eventEmitter.callback();
    });
  }
}
const WS = typeof globalThis.WebSocket !== "undefined" ? globalThis.WebSocket : browser$1;
class SocketTransport {
  constructor(opts) {
    this.opts = opts;
    this._queue = [];
    this._events = [];
    this._subscriptions = [];
    this._protocol = opts.protocol;
    this._version = opts.version;
    this._url = "";
    this._netMonitor = null;
    this._socket = null;
    this._nextSocket = null;
    this._subscriptions = opts.subscriptions || [];
    this._netMonitor = opts.netMonitor || new NetworkMonitor();
    if (!opts.url || typeof opts.url !== "string") {
      throw new Error("Missing or invalid WebSocket url");
    }
    this._url = opts.url;
    this._netMonitor.on("online", () => this._socketCreate());
  }
  set readyState(value) {
  }
  get readyState() {
    return this._socket ? this._socket.readyState : -1;
  }
  set connecting(value) {
  }
  get connecting() {
    return this.readyState === 0;
  }
  set connected(value) {
  }
  get connected() {
    return this.readyState === 1;
  }
  set closing(value) {
  }
  get closing() {
    return this.readyState === 2;
  }
  set closed(value) {
  }
  get closed() {
    return this.readyState === 3;
  }
  open() {
    this._socketCreate();
  }
  close() {
    this._socketClose();
  }
  send(message, topic, silent) {
    if (!topic || typeof topic !== "string") {
      throw new Error("Missing or invalid topic field");
    }
    this._socketSend({
      topic,
      type: "pub",
      payload: message,
      silent: !!silent
    });
  }
  subscribe(topic) {
    this._socketSend({
      topic,
      type: "sub",
      payload: "",
      silent: true
    });
  }
  on(event, callback) {
    this._events.push({ event, callback });
  }
  _socketCreate() {
    if (this._nextSocket) {
      return;
    }
    const url = getWebSocketUrl(this._url, this._protocol, this._version);
    this._nextSocket = new WS(url);
    if (!this._nextSocket) {
      throw new Error("Failed to create socket");
    }
    this._nextSocket.onmessage = (event) => this._socketReceive(event);
    this._nextSocket.onopen = () => this._socketOpen();
    this._nextSocket.onerror = (event) => this._socketError(event);
    this._nextSocket.onclose = () => {
      setTimeout(() => {
        this._nextSocket = null;
        this._socketCreate();
      }, 1e3);
    };
  }
  _socketOpen() {
    this._socketClose();
    this._socket = this._nextSocket;
    this._nextSocket = null;
    this._queueSubscriptions();
    this._pushQueue();
  }
  _socketClose() {
    if (this._socket) {
      this._socket.onclose = () => {
      };
      this._socket.close();
    }
  }
  _socketSend(socketMessage) {
    const message = JSON.stringify(socketMessage);
    if (this._socket && this._socket.readyState === 1) {
      this._socket.send(message);
    } else {
      this._setToQueue(socketMessage);
      this._socketCreate();
    }
  }
  async _socketReceive(event) {
    let socketMessage;
    try {
      socketMessage = JSON.parse(event.data);
    } catch (error) {
      return;
    }
    this._socketSend({
      topic: socketMessage.topic,
      type: "ack",
      payload: "",
      silent: true
    });
    if (this._socket && this._socket.readyState === 1) {
      const events2 = this._events.filter((event2) => event2.event === "message");
      if (events2 && events2.length) {
        events2.forEach((event2) => event2.callback(socketMessage));
      }
    }
  }
  _socketError(e2) {
    const events2 = this._events.filter((event) => event.event === "error");
    if (events2 && events2.length) {
      events2.forEach((event) => event.callback(e2));
    }
  }
  _queueSubscriptions() {
    const subscriptions = this._subscriptions;
    subscriptions.forEach((topic) => this._queue.push({
      topic,
      type: "sub",
      payload: "",
      silent: true
    }));
    this._subscriptions = this.opts.subscriptions || [];
  }
  _setToQueue(socketMessage) {
    this._queue.push(socketMessage);
  }
  _pushQueue() {
    const queue2 = this._queue;
    queue2.forEach((socketMessage) => this._socketSend(socketMessage));
    this._queue = [];
  }
}
function getWebSocketUrl(_url, protocol, version2) {
  var _a, _b;
  const url = _url.startsWith("https") ? _url.replace("https", "wss") : _url.startsWith("http") ? _url.replace("http", "ws") : _url;
  const splitUrl = url.split("?");
  const params = isBrowser$1() ? {
    protocol,
    version: version2,
    env: "browser",
    host: ((_a = getLocation()) === null || _a === void 0 ? void 0 : _a.host) || ""
  } : {
    protocol,
    version: version2,
    env: ((_b = detectEnv()) === null || _b === void 0 ? void 0 : _b.name) || ""
  };
  const queryString2 = appendToQueryString(getQueryString(splitUrl[1] || ""), params);
  return splitUrl[0] + "?" + queryString2;
}
const ERROR_SESSION_CONNECTED = "Session currently connected";
const ERROR_SESSION_DISCONNECTED = "Session currently disconnected";
const ERROR_SESSION_REJECTED = "Session Rejected";
const ERROR_MISSING_JSON_RPC = "Missing JSON RPC response";
const ERROR_MISSING_RESULT = `JSON-RPC success response must include "result" field`;
const ERROR_MISSING_ERROR = `JSON-RPC error response must include "error" field`;
const ERROR_MISSING_METHOD = `JSON RPC request must have valid "method" value`;
const ERROR_MISSING_ID = `JSON RPC request must have valid "id" value`;
const ERROR_MISSING_REQUIRED = "Missing one of the required parameters: bridge / uri / session";
const ERROR_INVALID_RESPONSE = "JSON RPC response format is invalid";
const ERROR_INVALID_URI = "URI format is invalid";
const ERROR_QRCODE_MODAL_NOT_PROVIDED = "QRCode Modal not provided";
const ERROR_QRCODE_MODAL_USER_CLOSED = "User close QRCode Modal";
class EventManager {
  constructor() {
    this._eventEmitters = [];
  }
  subscribe(eventEmitter) {
    this._eventEmitters.push(eventEmitter);
  }
  unsubscribe(event) {
    this._eventEmitters = this._eventEmitters.filter((x2) => x2.event !== event);
  }
  trigger(payload) {
    let eventEmitters = [];
    let event;
    if (isJsonRpcRequest(payload)) {
      event = payload.method;
    } else if (isJsonRpcResponseSuccess(payload) || isJsonRpcResponseError(payload)) {
      event = `response:${payload.id}`;
    } else if (isInternalEvent(payload)) {
      event = payload.event;
    } else {
      event = "";
    }
    if (event) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
    }
    if ((!eventEmitters || !eventEmitters.length) && !isReservedEvent(event) && !isInternalEvent(event)) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === "call_request");
    }
    eventEmitters.forEach((eventEmitter) => {
      if (isJsonRpcResponseError(payload)) {
        const error = new Error(payload.error.message);
        eventEmitter.callback(error, null);
      } else {
        eventEmitter.callback(null, payload);
      }
    });
  }
}
class SessionStorage {
  constructor(storageId = "walletconnect") {
    this.storageId = storageId;
  }
  getSession() {
    let session = null;
    const json = getLocal(this.storageId);
    if (json && isWalletConnectSession(json)) {
      session = json;
    }
    return session;
  }
  setSession(session) {
    setLocal(this.storageId, session);
    return session;
  }
  removeSession() {
    removeLocal(this.storageId);
  }
}
const domain = "walletconnect.org";
const alphanumerical = "abcdefghijklmnopqrstuvwxyz0123456789";
const bridges = alphanumerical.split("").map((char) => `https://${char}.bridge.walletconnect.org`);
function extractHostname(url) {
  let hostname = url.indexOf("//") > -1 ? url.split("/")[2] : url.split("/")[0];
  hostname = hostname.split(":")[0];
  hostname = hostname.split("?")[0];
  return hostname;
}
function extractRootDomain(url) {
  return extractHostname(url).split(".").slice(-2).join(".");
}
function randomBridgeIndex() {
  return Math.floor(Math.random() * bridges.length);
}
function selectRandomBridgeUrl() {
  return bridges[randomBridgeIndex()];
}
function shouldSelectRandomly(url) {
  return extractRootDomain(url) === domain;
}
function getBridgeUrl(url) {
  if (shouldSelectRandomly(url)) {
    return selectRandomBridgeUrl();
  }
  return url;
}
class Connector {
  constructor(opts) {
    this.protocol = "wc";
    this.version = 1;
    this._bridge = "";
    this._key = null;
    this._clientId = "";
    this._clientMeta = null;
    this._peerId = "";
    this._peerMeta = null;
    this._handshakeId = 0;
    this._handshakeTopic = "";
    this._connected = false;
    this._accounts = [];
    this._chainId = 0;
    this._networkId = 0;
    this._rpcUrl = "";
    this._eventManager = new EventManager();
    this._clientMeta = getClientMeta() || opts.connectorOpts.clientMeta || null;
    this._cryptoLib = opts.cryptoLib;
    this._sessionStorage = opts.sessionStorage || new SessionStorage(opts.connectorOpts.storageId);
    this._qrcodeModal = opts.connectorOpts.qrcodeModal;
    this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;
    this._signingMethods = [...signingMethods, ...opts.connectorOpts.signingMethods || []];
    if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {
      throw new Error(ERROR_MISSING_REQUIRED);
    }
    if (opts.connectorOpts.bridge) {
      this.bridge = getBridgeUrl(opts.connectorOpts.bridge);
    }
    if (opts.connectorOpts.uri) {
      this.uri = opts.connectorOpts.uri;
    }
    const session = opts.connectorOpts.session || this._getStorageSession();
    if (session) {
      this.session = session;
    }
    if (this.handshakeId) {
      this._subscribeToSessionResponse(this.handshakeId, "Session request rejected");
    }
    this._transport = opts.transport || new SocketTransport({
      protocol: this.protocol,
      version: this.version,
      url: this.bridge,
      subscriptions: [this.clientId]
    });
    this._subscribeToInternalEvents();
    this._initTransport();
    if (opts.connectorOpts.uri) {
      this._subscribeToSessionRequest();
    }
    if (opts.pushServerOpts) {
      this._registerPushServer(opts.pushServerOpts);
    }
  }
  set bridge(value) {
    if (!value) {
      return;
    }
    this._bridge = value;
  }
  get bridge() {
    return this._bridge;
  }
  set key(value) {
    if (!value) {
      return;
    }
    const key2 = convertHexToArrayBuffer(value);
    this._key = key2;
  }
  get key() {
    if (this._key) {
      const key2 = convertArrayBufferToHex(this._key, true);
      return key2;
    }
    return "";
  }
  set clientId(value) {
    if (!value) {
      return;
    }
    this._clientId = value;
  }
  get clientId() {
    let clientId = this._clientId;
    if (!clientId) {
      clientId = this._clientId = uuid();
    }
    return this._clientId;
  }
  set peerId(value) {
    if (!value) {
      return;
    }
    this._peerId = value;
  }
  get peerId() {
    return this._peerId;
  }
  set clientMeta(value) {
  }
  get clientMeta() {
    let clientMeta = this._clientMeta;
    if (!clientMeta) {
      clientMeta = this._clientMeta = getClientMeta();
    }
    return clientMeta;
  }
  set peerMeta(value) {
    this._peerMeta = value;
  }
  get peerMeta() {
    const peerMeta = this._peerMeta;
    return peerMeta;
  }
  set handshakeTopic(value) {
    if (!value) {
      return;
    }
    this._handshakeTopic = value;
  }
  get handshakeTopic() {
    return this._handshakeTopic;
  }
  set handshakeId(value) {
    if (!value) {
      return;
    }
    this._handshakeId = value;
  }
  get handshakeId() {
    return this._handshakeId;
  }
  get uri() {
    const _uri = this._formatUri();
    return _uri;
  }
  set uri(value) {
    if (!value) {
      return;
    }
    const { handshakeTopic, bridge, key: key2 } = this._parseUri(value);
    this.handshakeTopic = handshakeTopic;
    this.bridge = bridge;
    this.key = key2;
  }
  set chainId(value) {
    this._chainId = value;
  }
  get chainId() {
    const chainId = this._chainId;
    return chainId;
  }
  set networkId(value) {
    this._networkId = value;
  }
  get networkId() {
    const networkId = this._networkId;
    return networkId;
  }
  set accounts(value) {
    this._accounts = value;
  }
  get accounts() {
    const accounts = this._accounts;
    return accounts;
  }
  set rpcUrl(value) {
    this._rpcUrl = value;
  }
  get rpcUrl() {
    const rpcUrl = this._rpcUrl;
    return rpcUrl;
  }
  set connected(value) {
  }
  get connected() {
    return this._connected;
  }
  set pending(value) {
  }
  get pending() {
    return !!this._handshakeTopic;
  }
  get session() {
    return {
      connected: this.connected,
      accounts: this.accounts,
      chainId: this.chainId,
      bridge: this.bridge,
      key: this.key,
      clientId: this.clientId,
      clientMeta: this.clientMeta,
      peerId: this.peerId,
      peerMeta: this.peerMeta,
      handshakeId: this.handshakeId,
      handshakeTopic: this.handshakeTopic
    };
  }
  set session(value) {
    if (!value) {
      return;
    }
    this._connected = value.connected;
    this.accounts = value.accounts;
    this.chainId = value.chainId;
    this.bridge = value.bridge;
    this.key = value.key;
    this.clientId = value.clientId;
    this.clientMeta = value.clientMeta;
    this.peerId = value.peerId;
    this.peerMeta = value.peerMeta;
    this.handshakeId = value.handshakeId;
    this.handshakeTopic = value.handshakeTopic;
  }
  on(event, callback) {
    const eventEmitter = {
      event,
      callback
    };
    this._eventManager.subscribe(eventEmitter);
  }
  off(event) {
    this._eventManager.unsubscribe(event);
  }
  async createInstantRequest(instantRequest) {
    this._key = await this._generateKey();
    const request2 = this._formatRequest({
      method: "wc_instantRequest",
      params: [
        {
          peerId: this.clientId,
          peerMeta: this.clientMeta,
          request: this._formatRequest(instantRequest)
        }
      ]
    });
    this.handshakeId = request2.id;
    this.handshakeTopic = uuid();
    this._eventManager.trigger({
      event: "display_uri",
      params: [this.uri]
    });
    this.on("modal_closed", () => {
      throw new Error(ERROR_QRCODE_MODAL_USER_CLOSED);
    });
    const endInstantRequest = () => {
      this.killSession();
    };
    try {
      const result = await this._sendCallRequest(request2);
      if (result) {
        endInstantRequest();
      }
      return result;
    } catch (error) {
      endInstantRequest();
      throw error;
    }
  }
  async connect(opts) {
    if (!this._qrcodeModal) {
      throw new Error(ERROR_QRCODE_MODAL_NOT_PROVIDED);
    }
    if (this.connected) {
      return {
        chainId: this.chainId,
        accounts: this.accounts
      };
    }
    await this.createSession(opts);
    return new Promise(async (resolve2, reject) => {
      this.on("modal_closed", () => reject(new Error(ERROR_QRCODE_MODAL_USER_CLOSED)));
      this.on("connect", (error, payload) => {
        if (error) {
          return reject(error);
        }
        resolve2(payload.params[0]);
      });
    });
  }
  async createSession(opts) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    if (this.pending) {
      return;
    }
    this._key = await this._generateKey();
    const request2 = this._formatRequest({
      method: "wc_sessionRequest",
      params: [
        {
          peerId: this.clientId,
          peerMeta: this.clientMeta,
          chainId: opts && opts.chainId ? opts.chainId : null
        }
      ]
    });
    this.handshakeId = request2.id;
    this.handshakeTopic = uuid();
    this._sendSessionRequest(request2, "Session update rejected", {
      topic: this.handshakeTopic
    });
    this._eventManager.trigger({
      event: "display_uri",
      params: [this.uri]
    });
  }
  approveSession(sessionStatus) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    this.chainId = sessionStatus.chainId;
    this.accounts = sessionStatus.accounts;
    this.networkId = sessionStatus.networkId || 0;
    this.rpcUrl = sessionStatus.rpcUrl || "";
    const sessionParams = {
      approved: true,
      chainId: this.chainId,
      networkId: this.networkId,
      accounts: this.accounts,
      rpcUrl: this.rpcUrl,
      peerId: this.clientId,
      peerMeta: this.clientMeta
    };
    const response = {
      id: this.handshakeId,
      jsonrpc: "2.0",
      result: sessionParams
    };
    this._sendResponse(response);
    this._connected = true;
    this._setStorageSession();
    this._eventManager.trigger({
      event: "connect",
      params: [
        {
          peerId: this.peerId,
          peerMeta: this.peerMeta,
          chainId: this.chainId,
          accounts: this.accounts
        }
      ]
    });
  }
  rejectSession(sessionError) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    const message = sessionError && sessionError.message ? sessionError.message : ERROR_SESSION_REJECTED;
    const response = this._formatResponse({
      id: this.handshakeId,
      error: { message }
    });
    this._sendResponse(response);
    this._connected = false;
    this._eventManager.trigger({
      event: "disconnect",
      params: [{ message }]
    });
    this._removeStorageSession();
  }
  updateSession(sessionStatus) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    this.chainId = sessionStatus.chainId;
    this.accounts = sessionStatus.accounts;
    this.networkId = sessionStatus.networkId || 0;
    this.rpcUrl = sessionStatus.rpcUrl || "";
    const sessionParams = {
      approved: true,
      chainId: this.chainId,
      networkId: this.networkId,
      accounts: this.accounts,
      rpcUrl: this.rpcUrl
    };
    const request2 = this._formatRequest({
      method: "wc_sessionUpdate",
      params: [sessionParams]
    });
    this._sendSessionRequest(request2, "Session update rejected");
    this._eventManager.trigger({
      event: "session_update",
      params: [
        {
          chainId: this.chainId,
          accounts: this.accounts
        }
      ]
    });
    this._manageStorageSession();
  }
  async killSession(sessionError) {
    const message = sessionError ? sessionError.message : "Session Disconnected";
    const sessionParams = {
      approved: false,
      chainId: null,
      networkId: null,
      accounts: null
    };
    const request2 = this._formatRequest({
      method: "wc_sessionUpdate",
      params: [sessionParams]
    });
    await this._sendRequest(request2);
    this._handleSessionDisconnect(message);
  }
  async sendTransaction(tx) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const parsedTx = parseTransactionData(tx);
    const request2 = this._formatRequest({
      method: "eth_sendTransaction",
      params: [parsedTx]
    });
    const result = await this._sendCallRequest(request2);
    return result;
  }
  async signTransaction(tx) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const parsedTx = parseTransactionData(tx);
    const request2 = this._formatRequest({
      method: "eth_signTransaction",
      params: [parsedTx]
    });
    const result = await this._sendCallRequest(request2);
    return result;
  }
  async signMessage(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const request2 = this._formatRequest({
      method: "eth_sign",
      params
    });
    const result = await this._sendCallRequest(request2);
    return result;
  }
  async signPersonalMessage(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    params = parsePersonalSign(params);
    const request2 = this._formatRequest({
      method: "personal_sign",
      params
    });
    const result = await this._sendCallRequest(request2);
    return result;
  }
  async signTypedData(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const request2 = this._formatRequest({
      method: "eth_signTypedData",
      params
    });
    const result = await this._sendCallRequest(request2);
    return result;
  }
  async updateChain(chainParams) {
    if (!this._connected) {
      throw new Error("Session currently disconnected");
    }
    const request2 = this._formatRequest({
      method: "wallet_updateChain",
      params: [chainParams]
    });
    const result = await this._sendCallRequest(request2);
    return result;
  }
  unsafeSend(request2, options) {
    this._sendRequest(request2, options);
    this._eventManager.trigger({
      event: "call_request_sent",
      params: [{ request: request2, options }]
    });
    return new Promise((resolve2, reject) => {
      this._subscribeToResponse(request2.id, (error, payload) => {
        if (error) {
          reject(error);
          return;
        }
        if (!payload) {
          throw new Error(ERROR_MISSING_JSON_RPC);
        }
        resolve2(payload);
      });
    });
  }
  async sendCustomRequest(request2, options) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    switch (request2.method) {
      case "eth_accounts":
        return this.accounts;
      case "eth_chainId":
        return convertNumberToHex(this.chainId);
      case "eth_sendTransaction":
      case "eth_signTransaction":
        if (request2.params) {
          request2.params[0] = parseTransactionData(request2.params[0]);
        }
        break;
      case "personal_sign":
        if (request2.params) {
          request2.params = parsePersonalSign(request2.params);
        }
        break;
    }
    const formattedRequest = this._formatRequest(request2);
    const result = await this._sendCallRequest(formattedRequest, options);
    return result;
  }
  approveRequest(response) {
    if (isJsonRpcResponseSuccess(response)) {
      const formattedResponse = this._formatResponse(response);
      this._sendResponse(formattedResponse);
    } else {
      throw new Error(ERROR_MISSING_RESULT);
    }
  }
  rejectRequest(response) {
    if (isJsonRpcResponseError(response)) {
      const formattedResponse = this._formatResponse(response);
      this._sendResponse(formattedResponse);
    } else {
      throw new Error(ERROR_MISSING_ERROR);
    }
  }
  transportClose() {
    this._transport.close();
  }
  async _sendRequest(request2, options) {
    const callRequest = this._formatRequest(request2);
    const encryptionPayload = await this._encrypt(callRequest);
    const topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== "undefined" ? options.topic : this.peerId;
    const payload = JSON.stringify(encryptionPayload);
    const silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== "undefined" ? !options.forcePushNotification : isSilentPayload(callRequest);
    this._transport.send(payload, topic, silent);
  }
  async _sendResponse(response) {
    const encryptionPayload = await this._encrypt(response);
    const topic = this.peerId;
    const payload = JSON.stringify(encryptionPayload);
    const silent = true;
    this._transport.send(payload, topic, silent);
  }
  async _sendSessionRequest(request2, errorMsg, options) {
    this._sendRequest(request2, options);
    this._subscribeToSessionResponse(request2.id, errorMsg);
  }
  _sendCallRequest(request2, options) {
    this._sendRequest(request2, options);
    this._eventManager.trigger({
      event: "call_request_sent",
      params: [{ request: request2, options }]
    });
    return this._subscribeToCallResponse(request2.id);
  }
  _formatRequest(request2) {
    if (typeof request2.method === "undefined") {
      throw new Error(ERROR_MISSING_METHOD);
    }
    const formattedRequest = {
      id: typeof request2.id === "undefined" ? payloadId() : request2.id,
      jsonrpc: "2.0",
      method: request2.method,
      params: typeof request2.params === "undefined" ? [] : request2.params
    };
    return formattedRequest;
  }
  _formatResponse(response) {
    if (typeof response.id === "undefined") {
      throw new Error(ERROR_MISSING_ID);
    }
    const baseResponse = { id: response.id, jsonrpc: "2.0" };
    if (isJsonRpcResponseError(response)) {
      const error = formatRpcError(response.error);
      const errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), { error });
      return errorResponse;
    } else if (isJsonRpcResponseSuccess(response)) {
      const successResponse = Object.assign(Object.assign({}, baseResponse), response);
      return successResponse;
    }
    throw new Error(ERROR_INVALID_RESPONSE);
  }
  _handleSessionDisconnect(errorMsg) {
    const message = errorMsg || "Session Disconnected";
    if (!this._connected) {
      if (this._qrcodeModal) {
        this._qrcodeModal.close();
      }
      removeLocal(mobileLinkChoiceKey);
    }
    if (this._connected) {
      this._connected = false;
    }
    if (this._handshakeId) {
      this._handshakeId = 0;
    }
    if (this._handshakeTopic) {
      this._handshakeTopic = "";
    }
    if (this._peerId) {
      this._peerId = "";
    }
    this._eventManager.trigger({
      event: "disconnect",
      params: [{ message }]
    });
    this._removeStorageSession();
    this.transportClose();
  }
  _handleSessionResponse(errorMsg, sessionParams) {
    if (sessionParams) {
      if (sessionParams.approved) {
        if (!this._connected) {
          this._connected = true;
          if (sessionParams.chainId) {
            this.chainId = sessionParams.chainId;
          }
          if (sessionParams.accounts) {
            this.accounts = sessionParams.accounts;
          }
          if (sessionParams.peerId && !this.peerId) {
            this.peerId = sessionParams.peerId;
          }
          if (sessionParams.peerMeta && !this.peerMeta) {
            this.peerMeta = sessionParams.peerMeta;
          }
          this._eventManager.trigger({
            event: "connect",
            params: [
              {
                peerId: this.peerId,
                peerMeta: this.peerMeta,
                chainId: this.chainId,
                accounts: this.accounts
              }
            ]
          });
        } else {
          if (sessionParams.chainId) {
            this.chainId = sessionParams.chainId;
          }
          if (sessionParams.accounts) {
            this.accounts = sessionParams.accounts;
          }
          this._eventManager.trigger({
            event: "session_update",
            params: [
              {
                chainId: this.chainId,
                accounts: this.accounts
              }
            ]
          });
        }
        this._manageStorageSession();
      } else {
        this._handleSessionDisconnect(errorMsg);
      }
    } else {
      this._handleSessionDisconnect(errorMsg);
    }
  }
  async _handleIncomingMessages(socketMessage) {
    const activeTopics = [this.clientId, this.handshakeTopic];
    if (!activeTopics.includes(socketMessage.topic)) {
      return;
    }
    let encryptionPayload;
    try {
      encryptionPayload = JSON.parse(socketMessage.payload);
    } catch (error) {
      return;
    }
    const payload = await this._decrypt(encryptionPayload);
    if (payload) {
      this._eventManager.trigger(payload);
    }
  }
  _subscribeToSessionRequest() {
    this._transport.subscribe(this.handshakeTopic);
  }
  _subscribeToResponse(id2, callback) {
    this.on(`response:${id2}`, callback);
  }
  _subscribeToSessionResponse(id2, errorMsg) {
    this._subscribeToResponse(id2, (error, payload) => {
      if (error) {
        this._handleSessionResponse(error.message);
        return;
      }
      if (payload.result) {
        this._handleSessionResponse(errorMsg, payload.result);
      } else if (payload.error && payload.error.message) {
        this._handleSessionResponse(payload.error.message);
      } else {
        this._handleSessionResponse(errorMsg);
      }
    });
  }
  _subscribeToCallResponse(id2) {
    return new Promise((resolve2, reject) => {
      this._subscribeToResponse(id2, (error, payload) => {
        if (error) {
          reject(error);
          return;
        }
        if (payload.result) {
          resolve2(payload.result);
        } else if (payload.error && payload.error.message) {
          reject(new Error(payload.error.message));
        } else {
          reject(new Error(ERROR_INVALID_RESPONSE));
        }
      });
    });
  }
  _subscribeToInternalEvents() {
    this.on("display_uri", () => {
      if (this._qrcodeModal) {
        this._qrcodeModal.open(this.uri, () => {
          this._eventManager.trigger({
            event: "modal_closed",
            params: []
          });
        }, this._qrcodeModalOptions);
      }
    });
    this.on("connect", () => {
      if (this._qrcodeModal) {
        this._qrcodeModal.close();
      }
    });
    this.on("call_request_sent", (error, payload) => {
      const { request: request2 } = payload.params[0];
      if (isMobile() && this._signingMethods.includes(request2.method)) {
        const mobileLinkUrl = getLocal(mobileLinkChoiceKey);
        if (mobileLinkUrl) {
          window.location.href = mobileLinkUrl.href;
        }
      }
    });
    this.on("wc_sessionRequest", (error, payload) => {
      if (error) {
        this._eventManager.trigger({
          event: "error",
          params: [
            {
              code: "SESSION_REQUEST_ERROR",
              message: error.toString()
            }
          ]
        });
      }
      this.handshakeId = payload.id;
      this.peerId = payload.params[0].peerId;
      this.peerMeta = payload.params[0].peerMeta;
      const internalPayload = Object.assign(Object.assign({}, payload), { method: "session_request" });
      this._eventManager.trigger(internalPayload);
    });
    this.on("wc_sessionUpdate", (error, payload) => {
      if (error) {
        this._handleSessionResponse(error.message);
      }
      this._handleSessionResponse("Session disconnected", payload.params[0]);
    });
  }
  _initTransport() {
    this._transport.on("message", (socketMessage) => this._handleIncomingMessages(socketMessage));
    this._transport.on("open", () => this._eventManager.trigger({ event: "transport_open", params: [] }));
    this._transport.on("close", () => this._eventManager.trigger({ event: "transport_close", params: [] }));
    this._transport.on("error", () => this._eventManager.trigger({
      event: "transport_error",
      params: ["Websocket connection failed"]
    }));
    this._transport.open();
  }
  _formatUri() {
    const protocol = this.protocol;
    const handshakeTopic = this.handshakeTopic;
    const version2 = this.version;
    const bridge = encodeURIComponent(this.bridge);
    const key2 = this.key;
    const uri = `${protocol}:${handshakeTopic}@${version2}?bridge=${bridge}&key=${key2}`;
    return uri;
  }
  _parseUri(uri) {
    const result = parseWalletConnectUri(uri);
    if (result.protocol === this.protocol) {
      if (!result.handshakeTopic) {
        throw Error("Invalid or missing handshakeTopic parameter value");
      }
      const handshakeTopic = result.handshakeTopic;
      if (!result.bridge) {
        throw Error("Invalid or missing bridge url parameter value");
      }
      const bridge = decodeURIComponent(result.bridge);
      if (!result.key) {
        throw Error("Invalid or missing key parameter value");
      }
      const key2 = result.key;
      return { handshakeTopic, bridge, key: key2 };
    } else {
      throw new Error(ERROR_INVALID_URI);
    }
  }
  async _generateKey() {
    if (this._cryptoLib) {
      const result = await this._cryptoLib.generateKey();
      return result;
    }
    return null;
  }
  async _encrypt(data2) {
    const key2 = this._key;
    if (this._cryptoLib && key2) {
      const result = await this._cryptoLib.encrypt(data2, key2);
      return result;
    }
    return null;
  }
  async _decrypt(payload) {
    const key2 = this._key;
    if (this._cryptoLib && key2) {
      const result = await this._cryptoLib.decrypt(payload, key2);
      return result;
    }
    return null;
  }
  _getStorageSession() {
    let result = null;
    if (this._sessionStorage) {
      result = this._sessionStorage.getSession();
    }
    return result;
  }
  _setStorageSession() {
    if (this._sessionStorage) {
      this._sessionStorage.setSession(this.session);
    }
  }
  _removeStorageSession() {
    if (this._sessionStorage) {
      this._sessionStorage.removeSession();
    }
  }
  _manageStorageSession() {
    if (this._connected) {
      this._setStorageSession();
    } else {
      this._removeStorageSession();
    }
  }
  _registerPushServer(pushServerOpts) {
    if (!pushServerOpts.url || typeof pushServerOpts.url !== "string") {
      throw Error("Invalid or missing pushServerOpts.url parameter value");
    }
    if (!pushServerOpts.type || typeof pushServerOpts.type !== "string") {
      throw Error("Invalid or missing pushServerOpts.type parameter value");
    }
    if (!pushServerOpts.token || typeof pushServerOpts.token !== "string") {
      throw Error("Invalid or missing pushServerOpts.token parameter value");
    }
    const pushSubscription = {
      bridge: this.bridge,
      topic: this.clientId,
      type: pushServerOpts.type,
      token: pushServerOpts.token,
      peerName: "",
      language: pushServerOpts.language || ""
    };
    this.on("connect", async (error, payload) => {
      if (error) {
        throw error;
      }
      if (pushServerOpts.peerMeta) {
        const peerName = payload.params[0].peerMeta.name;
        pushSubscription.peerName = peerName;
      }
      try {
        const response = await fetch(`${pushServerOpts.url}/new`, {
          method: "POST",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json"
          },
          body: JSON.stringify(pushSubscription)
        });
        const json = await response.json();
        if (!json.success) {
          throw Error("Failed to register in Push Server");
        }
      } catch (error2) {
        throw Error("Failed to register in Push Server");
      }
    });
  }
}
function randomBytes(length) {
  const browserCrypto = cjs$1.getBrowerCrypto();
  return browserCrypto.getRandomValues(new Uint8Array(length));
}
const LENGTH_256 = 256;
const AES_LENGTH = LENGTH_256;
const HMAC_LENGTH = LENGTH_256;
const AES_BROWSER_ALGO = "AES-CBC";
const HMAC_BROWSER_ALGO = `SHA-${AES_LENGTH}`;
const HMAC_BROWSER = "HMAC";
const ENCRYPT_OP = "encrypt";
const DECRYPT_OP = "decrypt";
const SIGN_OP = "sign";
const VERIFY_OP = "verify";
function getAlgo(type) {
  return type === AES_BROWSER_ALGO ? { length: AES_LENGTH, name: AES_BROWSER_ALGO } : {
    hash: { name: HMAC_BROWSER_ALGO },
    name: HMAC_BROWSER
  };
}
function getOps(type) {
  return type === AES_BROWSER_ALGO ? [ENCRYPT_OP, DECRYPT_OP] : [SIGN_OP, VERIFY_OP];
}
async function browserImportKey(buffer2, type = AES_BROWSER_ALGO) {
  return cjs$1.getSubtleCrypto().importKey("raw", buffer2, getAlgo(type), true, getOps(type));
}
async function browserAesEncrypt(iv, key2, data2) {
  const subtle = cjs$1.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key2, AES_BROWSER_ALGO);
  const result = await subtle.encrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data2);
  return new Uint8Array(result);
}
async function browserAesDecrypt(iv, key2, data2) {
  const subtle = cjs$1.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key2, AES_BROWSER_ALGO);
  const result = await subtle.decrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data2);
  return new Uint8Array(result);
}
async function browserHmacSha256Sign(key2, data2) {
  const subtle = cjs$1.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key2, HMAC_BROWSER);
  const signature2 = await subtle.sign({
    length: HMAC_LENGTH,
    name: HMAC_BROWSER
  }, cryptoKey, data2);
  return new Uint8Array(signature2);
}
function aesCbcEncrypt(iv, key2, data2) {
  return browserAesEncrypt(iv, key2, data2);
}
function aesCbcDecrypt(iv, key2, data2) {
  return browserAesDecrypt(iv, key2, data2);
}
async function hmacSha256Sign(key2, msg) {
  const result = await browserHmacSha256Sign(key2, msg);
  return result;
}
async function generateKey(length) {
  const _length = (length || 256) / 8;
  const bytes = randomBytes(_length);
  const result = convertBufferToArrayBuffer(arrayToBuffer(bytes));
  return result;
}
async function verifyHmac(payload, key2) {
  const cipherText = hexToArray(payload.data);
  const iv = hexToArray(payload.iv);
  const hmac3 = hexToArray(payload.hmac);
  const hmacHex = arrayToHex(hmac3, false);
  const unsigned = concatArrays(cipherText, iv);
  const chmac = await hmacSha256Sign(key2, unsigned);
  const chmacHex = arrayToHex(chmac, false);
  if (removeHexPrefix(hmacHex) === removeHexPrefix(chmacHex)) {
    return true;
  }
  return false;
}
async function encrypt(data2, key2, providedIv) {
  const _key = bufferToArray(convertArrayBufferToBuffer(key2));
  const ivArrayBuffer = providedIv || await generateKey(128);
  const iv = bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));
  const ivHex = arrayToHex(iv, false);
  const contentString = JSON.stringify(data2);
  const content = utf8ToArray(contentString);
  const cipherText = await aesCbcEncrypt(iv, _key, content);
  const cipherTextHex = arrayToHex(cipherText, false);
  const unsigned = concatArrays(cipherText, iv);
  const hmac3 = await hmacSha256Sign(_key, unsigned);
  const hmacHex = arrayToHex(hmac3, false);
  return {
    data: cipherTextHex,
    hmac: hmacHex,
    iv: ivHex
  };
}
async function decrypt(payload, key2) {
  const _key = bufferToArray(convertArrayBufferToBuffer(key2));
  if (!_key) {
    throw new Error("Missing key: required for decryption");
  }
  const verified = await verifyHmac(payload, _key);
  if (!verified) {
    return null;
  }
  const cipherText = hexToArray(payload.data);
  const iv = hexToArray(payload.iv);
  const buffer2 = await aesCbcDecrypt(iv, _key, cipherText);
  const utf8 = arrayToUtf8(buffer2);
  let data2;
  try {
    data2 = JSON.parse(utf8);
  } catch (error) {
    return null;
  }
  return data2;
}
var cryptoLib = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  generateKey,
  verifyHmac,
  encrypt,
  decrypt
}, Symbol.toStringTag, { value: "Module" }));
class WalletConnect extends Connector {
  constructor(connectorOpts, pushServerOpts) {
    super({
      cryptoLib,
      connectorOpts,
      pushServerOpts
    });
  }
}
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(esm);
var browser = {};
var canPromise$1 = function() {
  return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
};
var qrcode = {};
var typedarrayBuffer = {};
var toString$1 = {}.toString;
var isarray = Array.isArray || function(arr) {
  return toString$1.call(arr) == "[object Array]";
};
var isArray$2 = isarray;
function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
      return 42;
    } };
    return arr.foo() === 42;
  } catch (e2) {
    return false;
  }
}
Buffer$1.TYPED_ARRAY_SUPPORT = typedArraySupport();
var K_MAX_LENGTH = Buffer$1.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
function Buffer$1(arg, offset2, length) {
  if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
    return new Buffer$1(arg, offset2, length);
  }
  if (typeof arg === "number") {
    return allocUnsafe(this, arg);
  }
  return from(this, arg, offset2, length);
}
if (Buffer$1.TYPED_ARRAY_SUPPORT) {
  Buffer$1.prototype.__proto__ = Uint8Array.prototype;
  Buffer$1.__proto__ = Uint8Array;
  if (typeof Symbol !== "undefined" && Symbol.species && Buffer$1[Symbol.species] === Buffer$1) {
    Object.defineProperty(Buffer$1, Symbol.species, {
      value: null,
      configurable: true,
      enumerable: false,
      writable: false
    });
  }
}
function checked(length) {
  if (length >= K_MAX_LENGTH) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
  }
  return length | 0;
}
function isnan(val) {
  return val !== val;
}
function createBuffer(that, length) {
  var buf;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    buf = new Uint8Array(length);
    buf.__proto__ = Buffer$1.prototype;
  } else {
    buf = that;
    if (buf === null) {
      buf = new Buffer$1(length);
    }
    buf.length = length;
  }
  return buf;
}
function allocUnsafe(that, size2) {
  var buf = createBuffer(that, size2 < 0 ? 0 : checked(size2) | 0);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
    for (var i2 = 0; i2 < size2; ++i2) {
      buf[i2] = 0;
    }
  }
  return buf;
}
function fromString(that, string) {
  var length = byteLength$1(string) | 0;
  var buf = createBuffer(that, length);
  var actual = buf.write(string);
  if (actual !== length) {
    buf = buf.slice(0, actual);
  }
  return buf;
}
function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  var buf = createBuffer(that, length);
  for (var i2 = 0; i2 < length; i2 += 1) {
    buf[i2] = array[i2] & 255;
  }
  return buf;
}
function fromArrayBuffer(that, array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  var buf;
  if (byteOffset === void 0 && length === void 0) {
    buf = new Uint8Array(array);
  } else if (length === void 0) {
    buf = new Uint8Array(array, byteOffset);
  } else {
    buf = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    buf.__proto__ = Buffer$1.prototype;
  } else {
    buf = fromArrayLike(that, buf);
  }
  return buf;
}
function fromObject(that, obj) {
  if (Buffer$1.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    var buf = createBuffer(that, len);
    if (buf.length === 0) {
      return buf;
    }
    obj.copy(buf, 0, 0, len);
    return buf;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i2 = 0; i2 < length; ++i2) {
    codePoint = string.charCodeAt(i2);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i2 + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function byteLength$1(string) {
  if (Buffer$1.isBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  return utf8ToBytes(string).length;
}
function blitBuffer(src, dst, offset2, length) {
  for (var i2 = 0; i2 < length; ++i2) {
    if (i2 + offset2 >= dst.length || i2 >= src.length)
      break;
    dst[i2 + offset2] = src[i2];
  }
  return i2;
}
function utf8Write(buf, string, offset2, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset2), buf, offset2, length);
}
function from(that, value, offset2, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, offset2, length);
  }
  if (typeof value === "string") {
    return fromString(that, value);
  }
  return fromObject(that, value);
}
Buffer$1.prototype.write = function write3(string, offset2, length) {
  if (offset2 === void 0) {
    length = this.length;
    offset2 = 0;
  } else if (length === void 0 && typeof offset2 === "string") {
    length = this.length;
    offset2 = 0;
  } else if (isFinite(offset2)) {
    offset2 = offset2 | 0;
    if (isFinite(length)) {
      length = length | 0;
    } else {
      length = void 0;
    }
  }
  var remaining = this.length - offset2;
  if (length === void 0 || length > remaining)
    length = remaining;
  if (string.length > 0 && (length < 0 || offset2 < 0) || offset2 > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  return utf8Write(this, string, offset2, length);
};
Buffer$1.prototype.slice = function slice2(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === void 0 ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0;
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0)
      end = 0;
  } else if (end > len) {
    end = len;
  }
  if (end < start)
    end = start;
  var newBuf;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer$1.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer$1(sliceLen, void 0);
    for (var i2 = 0; i2 < sliceLen; ++i2) {
      newBuf[i2] = this[i2 + start];
    }
  }
  return newBuf;
};
Buffer$1.prototype.copy = function copy2(target, targetStart, start, end) {
  if (!start)
    start = 0;
  if (!end && end !== 0)
    end = this.length;
  if (targetStart >= target.length)
    targetStart = target.length;
  if (!targetStart)
    targetStart = 0;
  if (end > 0 && end < start)
    end = start;
  if (end === start)
    return 0;
  if (target.length === 0 || this.length === 0)
    return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start < 0 || start >= this.length)
    throw new RangeError("sourceStart out of bounds");
  if (end < 0)
    throw new RangeError("sourceEnd out of bounds");
  if (end > this.length)
    end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }
  var len = end - start;
  var i2;
  if (this === target && start < targetStart && targetStart < end) {
    for (i2 = len - 1; i2 >= 0; --i2) {
      target[i2 + targetStart] = this[i2 + start];
    }
  } else if (len < 1e3 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
    for (i2 = 0; i2 < len; ++i2) {
      target[i2 + targetStart] = this[i2 + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }
  return len;
};
Buffer$1.prototype.fill = function fill2(val, start, end) {
  if (typeof val === "string") {
    if (typeof start === "string") {
      start = 0;
      end = this.length;
    } else if (typeof end === "string") {
      end = this.length;
    }
    if (val.length === 1) {
      var code2 = val.charCodeAt(0);
      if (code2 < 256) {
        val = code2;
      }
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError("Out of range index");
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === void 0 ? this.length : end >>> 0;
  if (!val)
    val = 0;
  var i2;
  if (typeof val === "number") {
    for (i2 = start; i2 < end; ++i2) {
      this[i2] = val;
    }
  } else {
    var bytes = Buffer$1.isBuffer(val) ? val : new Buffer$1(val);
    var len = bytes.length;
    for (i2 = 0; i2 < end - start; ++i2) {
      this[i2 + start] = bytes[i2 % len];
    }
  }
  return this;
};
Buffer$1.concat = function concat3(list, length) {
  if (!isArray$2(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return createBuffer(null, 0);
  }
  var i2;
  if (length === void 0) {
    length = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      length += list[i2].length;
    }
  }
  var buffer2 = allocUnsafe(null, length);
  var pos = 0;
  for (i2 = 0; i2 < list.length; ++i2) {
    var buf = list[i2];
    if (!Buffer$1.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer2, pos);
    pos += buf.length;
  }
  return buffer2;
};
Buffer$1.byteLength = byteLength$1;
Buffer$1.prototype._isBuffer = true;
Buffer$1.isBuffer = function isBuffer(b2) {
  return !!(b2 != null && b2._isBuffer);
};
typedarrayBuffer.alloc = function(size2) {
  var buffer2 = new Buffer$1(size2);
  buffer2.fill(0);
  return buffer2;
};
typedarrayBuffer.from = function(data2) {
  return new Buffer$1(data2);
};
var utils$g = {};
var toSJISFunction;
var CODEWORDS_COUNT = [
  0,
  26,
  44,
  70,
  100,
  134,
  172,
  196,
  242,
  292,
  346,
  404,
  466,
  532,
  581,
  655,
  733,
  815,
  901,
  991,
  1085,
  1156,
  1258,
  1364,
  1474,
  1588,
  1706,
  1828,
  1921,
  2051,
  2185,
  2323,
  2465,
  2611,
  2761,
  2876,
  3034,
  3196,
  3362,
  3532,
  3706
];
utils$g.getSymbolSize = function getSymbolSize(version2) {
  if (!version2)
    throw new Error('"version" cannot be null or undefined');
  if (version2 < 1 || version2 > 40)
    throw new Error('"version" should be in range from 1 to 40');
  return version2 * 4 + 17;
};
utils$g.getSymbolTotalCodewords = function getSymbolTotalCodewords(version2) {
  return CODEWORDS_COUNT[version2];
};
utils$g.getBCHDigit = function(data2) {
  var digit = 0;
  while (data2 !== 0) {
    digit++;
    data2 >>>= 1;
  }
  return digit;
};
utils$g.setToSJISFunction = function setToSJISFunction(f2) {
  if (typeof f2 !== "function") {
    throw new Error('"toSJISFunc" is not a valid function.');
  }
  toSJISFunction = f2;
};
utils$g.isKanjiModeEnabled = function() {
  return typeof toSJISFunction !== "undefined";
};
utils$g.toSJIS = function toSJIS(kanji2) {
  return toSJISFunction(kanji2);
};
var errorCorrectionLevel = {};
(function(exports) {
  exports.L = { bit: 1 };
  exports.M = { bit: 0 };
  exports.Q = { bit: 3 };
  exports.H = { bit: 2 };
  function fromString2(string) {
    if (typeof string !== "string") {
      throw new Error("Param is not a string");
    }
    var lcStr = string.toLowerCase();
    switch (lcStr) {
      case "l":
      case "low":
        return exports.L;
      case "m":
      case "medium":
        return exports.M;
      case "q":
      case "quartile":
        return exports.Q;
      case "h":
      case "high":
        return exports.H;
      default:
        throw new Error("Unknown EC Level: " + string);
    }
  }
  exports.isValid = function isValid2(level) {
    return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
  };
  exports.from = function from2(value, defaultValue) {
    if (exports.isValid(value)) {
      return value;
    }
    try {
      return fromString2(value);
    } catch (e2) {
      return defaultValue;
    }
  };
})(errorCorrectionLevel);
function BitBuffer$1() {
  this.buffer = [];
  this.length = 0;
}
BitBuffer$1.prototype = {
  get: function(index2) {
    var bufIndex = Math.floor(index2 / 8);
    return (this.buffer[bufIndex] >>> 7 - index2 % 8 & 1) === 1;
  },
  put: function(num, length) {
    for (var i2 = 0; i2 < length; i2++) {
      this.putBit((num >>> length - i2 - 1 & 1) === 1);
    }
  },
  getLengthInBits: function() {
    return this.length;
  },
  putBit: function(bit) {
    var bufIndex = Math.floor(this.length / 8);
    if (this.buffer.length <= bufIndex) {
      this.buffer.push(0);
    }
    if (bit) {
      this.buffer[bufIndex] |= 128 >>> this.length % 8;
    }
    this.length++;
  }
};
var bitBuffer = BitBuffer$1;
var BufferUtil$4 = typedarrayBuffer;
function BitMatrix$1(size2) {
  if (!size2 || size2 < 1) {
    throw new Error("BitMatrix size must be defined and greater than 0");
  }
  this.size = size2;
  this.data = BufferUtil$4.alloc(size2 * size2);
  this.reservedBit = BufferUtil$4.alloc(size2 * size2);
}
BitMatrix$1.prototype.set = function(row, col, value, reserved) {
  var index2 = row * this.size + col;
  this.data[index2] = value;
  if (reserved)
    this.reservedBit[index2] = true;
};
BitMatrix$1.prototype.get = function(row, col) {
  return this.data[row * this.size + col];
};
BitMatrix$1.prototype.xor = function(row, col, value) {
  this.data[row * this.size + col] ^= value;
};
BitMatrix$1.prototype.isReserved = function(row, col) {
  return this.reservedBit[row * this.size + col];
};
var bitMatrix = BitMatrix$1;
var alignmentPattern = {};
(function(exports) {
  var getSymbolSize3 = utils$g.getSymbolSize;
  exports.getRowColCoords = function getRowColCoords(version2) {
    if (version2 === 1)
      return [];
    var posCount = Math.floor(version2 / 7) + 2;
    var size2 = getSymbolSize3(version2);
    var intervals = size2 === 145 ? 26 : Math.ceil((size2 - 13) / (2 * posCount - 2)) * 2;
    var positions = [size2 - 7];
    for (var i2 = 1; i2 < posCount - 1; i2++) {
      positions[i2] = positions[i2 - 1] - intervals;
    }
    positions.push(6);
    return positions.reverse();
  };
  exports.getPositions = function getPositions2(version2) {
    var coords = [];
    var pos = exports.getRowColCoords(version2);
    var posLength = pos.length;
    for (var i2 = 0; i2 < posLength; i2++) {
      for (var j2 = 0; j2 < posLength; j2++) {
        if (i2 === 0 && j2 === 0 || i2 === 0 && j2 === posLength - 1 || i2 === posLength - 1 && j2 === 0) {
          continue;
        }
        coords.push([pos[i2], pos[j2]]);
      }
    }
    return coords;
  };
})(alignmentPattern);
var finderPattern = {};
var getSymbolSize2 = utils$g.getSymbolSize;
var FINDER_PATTERN_SIZE = 7;
finderPattern.getPositions = function getPositions(version2) {
  var size2 = getSymbolSize2(version2);
  return [
    [0, 0],
    [size2 - FINDER_PATTERN_SIZE, 0],
    [0, size2 - FINDER_PATTERN_SIZE]
  ];
};
var maskPattern = {};
(function(exports) {
  exports.Patterns = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
  };
  var PenaltyScores = {
    N1: 3,
    N2: 3,
    N3: 40,
    N4: 10
  };
  exports.isValid = function isValid2(mask) {
    return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
  };
  exports.from = function from2(value) {
    return exports.isValid(value) ? parseInt(value, 10) : void 0;
  };
  exports.getPenaltyN1 = function getPenaltyN1(data2) {
    var size2 = data2.size;
    var points = 0;
    var sameCountCol = 0;
    var sameCountRow = 0;
    var lastCol = null;
    var lastRow = null;
    for (var row = 0; row < size2; row++) {
      sameCountCol = sameCountRow = 0;
      lastCol = lastRow = null;
      for (var col = 0; col < size2; col++) {
        var module = data2.get(row, col);
        if (module === lastCol) {
          sameCountCol++;
        } else {
          if (sameCountCol >= 5)
            points += PenaltyScores.N1 + (sameCountCol - 5);
          lastCol = module;
          sameCountCol = 1;
        }
        module = data2.get(col, row);
        if (module === lastRow) {
          sameCountRow++;
        } else {
          if (sameCountRow >= 5)
            points += PenaltyScores.N1 + (sameCountRow - 5);
          lastRow = module;
          sameCountRow = 1;
        }
      }
      if (sameCountCol >= 5)
        points += PenaltyScores.N1 + (sameCountCol - 5);
      if (sameCountRow >= 5)
        points += PenaltyScores.N1 + (sameCountRow - 5);
    }
    return points;
  };
  exports.getPenaltyN2 = function getPenaltyN2(data2) {
    var size2 = data2.size;
    var points = 0;
    for (var row = 0; row < size2 - 1; row++) {
      for (var col = 0; col < size2 - 1; col++) {
        var last = data2.get(row, col) + data2.get(row, col + 1) + data2.get(row + 1, col) + data2.get(row + 1, col + 1);
        if (last === 4 || last === 0)
          points++;
      }
    }
    return points * PenaltyScores.N2;
  };
  exports.getPenaltyN3 = function getPenaltyN3(data2) {
    var size2 = data2.size;
    var points = 0;
    var bitsCol = 0;
    var bitsRow = 0;
    for (var row = 0; row < size2; row++) {
      bitsCol = bitsRow = 0;
      for (var col = 0; col < size2; col++) {
        bitsCol = bitsCol << 1 & 2047 | data2.get(row, col);
        if (col >= 10 && (bitsCol === 1488 || bitsCol === 93))
          points++;
        bitsRow = bitsRow << 1 & 2047 | data2.get(col, row);
        if (col >= 10 && (bitsRow === 1488 || bitsRow === 93))
          points++;
      }
    }
    return points * PenaltyScores.N3;
  };
  exports.getPenaltyN4 = function getPenaltyN4(data2) {
    var darkCount = 0;
    var modulesCount = data2.data.length;
    for (var i2 = 0; i2 < modulesCount; i2++)
      darkCount += data2.data[i2];
    var k2 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
    return k2 * PenaltyScores.N4;
  };
  function getMaskAt(maskPattern2, i2, j2) {
    switch (maskPattern2) {
      case exports.Patterns.PATTERN000:
        return (i2 + j2) % 2 === 0;
      case exports.Patterns.PATTERN001:
        return i2 % 2 === 0;
      case exports.Patterns.PATTERN010:
        return j2 % 3 === 0;
      case exports.Patterns.PATTERN011:
        return (i2 + j2) % 3 === 0;
      case exports.Patterns.PATTERN100:
        return (Math.floor(i2 / 2) + Math.floor(j2 / 3)) % 2 === 0;
      case exports.Patterns.PATTERN101:
        return i2 * j2 % 2 + i2 * j2 % 3 === 0;
      case exports.Patterns.PATTERN110:
        return (i2 * j2 % 2 + i2 * j2 % 3) % 2 === 0;
      case exports.Patterns.PATTERN111:
        return (i2 * j2 % 3 + (i2 + j2) % 2) % 2 === 0;
      default:
        throw new Error("bad maskPattern:" + maskPattern2);
    }
  }
  exports.applyMask = function applyMask(pattern, data2) {
    var size2 = data2.size;
    for (var col = 0; col < size2; col++) {
      for (var row = 0; row < size2; row++) {
        if (data2.isReserved(row, col))
          continue;
        data2.xor(row, col, getMaskAt(pattern, row, col));
      }
    }
  };
  exports.getBestMask = function getBestMask(data2, setupFormatFunc) {
    var numPatterns = Object.keys(exports.Patterns).length;
    var bestPattern = 0;
    var lowerPenalty = Infinity;
    for (var p2 = 0; p2 < numPatterns; p2++) {
      setupFormatFunc(p2);
      exports.applyMask(p2, data2);
      var penalty = exports.getPenaltyN1(data2) + exports.getPenaltyN2(data2) + exports.getPenaltyN3(data2) + exports.getPenaltyN4(data2);
      exports.applyMask(p2, data2);
      if (penalty < lowerPenalty) {
        lowerPenalty = penalty;
        bestPattern = p2;
      }
    }
    return bestPattern;
  };
})(maskPattern);
var errorCorrectionCode = {};
var ECLevel$1 = errorCorrectionLevel;
var EC_BLOCKS_TABLE = [
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  1,
  2,
  2,
  4,
  1,
  2,
  4,
  4,
  2,
  4,
  4,
  4,
  2,
  4,
  6,
  5,
  2,
  4,
  6,
  6,
  2,
  5,
  8,
  8,
  4,
  5,
  8,
  8,
  4,
  5,
  8,
  11,
  4,
  8,
  10,
  11,
  4,
  9,
  12,
  16,
  4,
  9,
  16,
  16,
  6,
  10,
  12,
  18,
  6,
  10,
  17,
  16,
  6,
  11,
  16,
  19,
  6,
  13,
  18,
  21,
  7,
  14,
  21,
  25,
  8,
  16,
  20,
  25,
  8,
  17,
  23,
  25,
  9,
  17,
  23,
  34,
  9,
  18,
  25,
  30,
  10,
  20,
  27,
  32,
  12,
  21,
  29,
  35,
  12,
  23,
  34,
  37,
  12,
  25,
  34,
  40,
  13,
  26,
  35,
  42,
  14,
  28,
  38,
  45,
  15,
  29,
  40,
  48,
  16,
  31,
  43,
  51,
  17,
  33,
  45,
  54,
  18,
  35,
  48,
  57,
  19,
  37,
  51,
  60,
  19,
  38,
  53,
  63,
  20,
  40,
  56,
  66,
  21,
  43,
  59,
  70,
  22,
  45,
  62,
  74,
  24,
  47,
  65,
  77,
  25,
  49,
  68,
  81
];
var EC_CODEWORDS_TABLE = [
  7,
  10,
  13,
  17,
  10,
  16,
  22,
  28,
  15,
  26,
  36,
  44,
  20,
  36,
  52,
  64,
  26,
  48,
  72,
  88,
  36,
  64,
  96,
  112,
  40,
  72,
  108,
  130,
  48,
  88,
  132,
  156,
  60,
  110,
  160,
  192,
  72,
  130,
  192,
  224,
  80,
  150,
  224,
  264,
  96,
  176,
  260,
  308,
  104,
  198,
  288,
  352,
  120,
  216,
  320,
  384,
  132,
  240,
  360,
  432,
  144,
  280,
  408,
  480,
  168,
  308,
  448,
  532,
  180,
  338,
  504,
  588,
  196,
  364,
  546,
  650,
  224,
  416,
  600,
  700,
  224,
  442,
  644,
  750,
  252,
  476,
  690,
  816,
  270,
  504,
  750,
  900,
  300,
  560,
  810,
  960,
  312,
  588,
  870,
  1050,
  336,
  644,
  952,
  1110,
  360,
  700,
  1020,
  1200,
  390,
  728,
  1050,
  1260,
  420,
  784,
  1140,
  1350,
  450,
  812,
  1200,
  1440,
  480,
  868,
  1290,
  1530,
  510,
  924,
  1350,
  1620,
  540,
  980,
  1440,
  1710,
  570,
  1036,
  1530,
  1800,
  570,
  1064,
  1590,
  1890,
  600,
  1120,
  1680,
  1980,
  630,
  1204,
  1770,
  2100,
  660,
  1260,
  1860,
  2220,
  720,
  1316,
  1950,
  2310,
  750,
  1372,
  2040,
  2430
];
errorCorrectionCode.getBlocksCount = function getBlocksCount(version2, errorCorrectionLevel2) {
  switch (errorCorrectionLevel2) {
    case ECLevel$1.L:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 0];
    case ECLevel$1.M:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 1];
    case ECLevel$1.Q:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 2];
    case ECLevel$1.H:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 3];
    default:
      return void 0;
  }
};
errorCorrectionCode.getTotalCodewordsCount = function getTotalCodewordsCount(version2, errorCorrectionLevel2) {
  switch (errorCorrectionLevel2) {
    case ECLevel$1.L:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 0];
    case ECLevel$1.M:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 1];
    case ECLevel$1.Q:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 2];
    case ECLevel$1.H:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 3];
    default:
      return void 0;
  }
};
var polynomial = {};
var galoisField = {};
var BufferUtil$3 = typedarrayBuffer;
var EXP_TABLE = BufferUtil$3.alloc(512);
var LOG_TABLE = BufferUtil$3.alloc(256);
(function initTables() {
  var x2 = 1;
  for (var i2 = 0; i2 < 255; i2++) {
    EXP_TABLE[i2] = x2;
    LOG_TABLE[x2] = i2;
    x2 <<= 1;
    if (x2 & 256) {
      x2 ^= 285;
    }
  }
  for (i2 = 255; i2 < 512; i2++) {
    EXP_TABLE[i2] = EXP_TABLE[i2 - 255];
  }
})();
galoisField.log = function log(n2) {
  if (n2 < 1)
    throw new Error("log(" + n2 + ")");
  return LOG_TABLE[n2];
};
galoisField.exp = function exp(n2) {
  return EXP_TABLE[n2];
};
galoisField.mul = function mul3(x2, y2) {
  if (x2 === 0 || y2 === 0)
    return 0;
  return EXP_TABLE[LOG_TABLE[x2] + LOG_TABLE[y2]];
};
(function(exports) {
  var BufferUtil2 = typedarrayBuffer;
  var GF = galoisField;
  exports.mul = function mul4(p1, p2) {
    var coeff = BufferUtil2.alloc(p1.length + p2.length - 1);
    for (var i2 = 0; i2 < p1.length; i2++) {
      for (var j2 = 0; j2 < p2.length; j2++) {
        coeff[i2 + j2] ^= GF.mul(p1[i2], p2[j2]);
      }
    }
    return coeff;
  };
  exports.mod = function mod(divident, divisor) {
    var result = BufferUtil2.from(divident);
    while (result.length - divisor.length >= 0) {
      var coeff = result[0];
      for (var i2 = 0; i2 < divisor.length; i2++) {
        result[i2] ^= GF.mul(divisor[i2], coeff);
      }
      var offset2 = 0;
      while (offset2 < result.length && result[offset2] === 0)
        offset2++;
      result = result.slice(offset2);
    }
    return result;
  };
  exports.generateECPolynomial = function generateECPolynomial(degree) {
    var poly = BufferUtil2.from([1]);
    for (var i2 = 0; i2 < degree; i2++) {
      poly = exports.mul(poly, [1, GF.exp(i2)]);
    }
    return poly;
  };
})(polynomial);
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$2 = 0, len = code.length; i$2 < len; ++i$2) {
  lookup[i$2] = code[i$2];
  revLookup[code.charCodeAt(i$2)] = i$2;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i2;
  for (i2 = 0; i2 < len; i2 += 4) {
    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i2 = start; i2 < end; i2 += 3) {
    tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len2 = len - extraBytes; i2 < len2; i2 += maxChunkLength) {
    parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len2 ? len2 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset2, isLE, mLen, nBytes) {
  var e2, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer2[offset2 + i2];
  i2 += d2;
  e2 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer2[offset2 + i2], i2 += d2, nBits -= 8) {
  }
  m2 = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset2 + i2], i2 += d2, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
};
ieee754.write = function(buffer2, value, offset2, isLE, mLen, nBytes) {
  var e2, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c2 = Math.pow(2, -e2)) < 1) {
      e2--;
      c2 *= 2;
    }
    if (e2 + eBias >= 1) {
      value += rt2 / c2;
    } else {
      value += rt2 * Math.pow(2, 1 - eBias);
    }
    if (value * c2 >= 2) {
      e2++;
      c2 /= 2;
    }
    if (e2 + eBias >= eMax) {
      m2 = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m2 = (value * c2 - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset2 + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset2 + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
  }
  buffer2[offset2 + i2 - d2] |= s2 * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports) {
  var base64 = base64Js;
  var ieee754$1 = ieee754;
  var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer3;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  var K_MAX_LENGTH2 = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH2;
  Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport2();
  if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport2() {
    try {
      var arr = new Uint8Array(1);
      var proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e2) {
      return false;
    }
  }
  Object.defineProperty(Buffer3.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer3.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer2(length) {
    if (length > K_MAX_LENGTH2) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function Buffer3(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe2(arg);
    }
    return from2(arg, encodingOrOffset, length);
  }
  Buffer3.poolSize = 8192;
  function from2(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString2(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer2(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer2(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer3.from(valueOf, encodingOrOffset, length);
    }
    var b2 = fromObject2(value);
    if (b2)
      return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }
  Buffer3.from = function(value, encodingOrOffset, length) {
    return from2(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer3, Uint8Array);
  function assertSize2(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size2 < 0) {
      throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
    }
  }
  function alloc2(size2, fill3, encoding) {
    assertSize2(size2);
    if (size2 <= 0) {
      return createBuffer2(size2);
    }
    if (fill3 !== void 0) {
      return typeof encoding === "string" ? createBuffer2(size2).fill(fill3, encoding) : createBuffer2(size2).fill(fill3);
    }
    return createBuffer2(size2);
  }
  Buffer3.alloc = function(size2, fill3, encoding) {
    return alloc2(size2, fill3, encoding);
  };
  function allocUnsafe2(size2) {
    assertSize2(size2);
    return createBuffer2(size2 < 0 ? 0 : checked2(size2) | 0);
  }
  Buffer3.allocUnsafe = function(size2) {
    return allocUnsafe2(size2);
  };
  Buffer3.allocUnsafeSlow = function(size2) {
    return allocUnsafe2(size2);
  };
  function fromString2(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer3.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    var length = byteLength2(string, encoding) | 0;
    var buf = createBuffer2(length);
    var actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike2(array) {
    var length = array.length < 0 ? 0 : checked2(array.length) | 0;
    var buf = createBuffer2(length);
    for (var i2 = 0; i2 < length; i2 += 1) {
      buf[i2] = array[i2] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      var copy4 = new Uint8Array(arrayView);
      return fromArrayBuffer2(copy4.buffer, copy4.byteOffset, copy4.byteLength);
    }
    return fromArrayLike2(arrayView);
  }
  function fromArrayBuffer2(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    var buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function fromObject2(obj) {
    if (Buffer3.isBuffer(obj)) {
      var len = checked2(obj.length) | 0;
      var buf = createBuffer2(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer2(0);
      }
      return fromArrayLike2(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike2(obj.data);
    }
  }
  function checked2(length) {
    if (length >= K_MAX_LENGTH2) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH2.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer3.alloc(+length);
  }
  Buffer3.isBuffer = function isBuffer3(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer3.prototype;
  };
  Buffer3.compare = function compare3(a2, b2) {
    if (isInstance(a2, Uint8Array))
      a2 = Buffer3.from(a2, a2.offset, a2.byteLength);
    if (isInstance(b2, Uint8Array))
      b2 = Buffer3.from(b2, b2.offset, b2.byteLength);
    if (!Buffer3.isBuffer(a2) || !Buffer3.isBuffer(b2)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a2 === b2)
      return 0;
    var x2 = a2.length;
    var y2 = b2.length;
    for (var i2 = 0, len = Math.min(x2, y2); i2 < len; ++i2) {
      if (a2[i2] !== b2[i2]) {
        x2 = a2[i2];
        y2 = b2[i2];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  Buffer3.isEncoding = function isEncoding2(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer3.concat = function concat4(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer3.alloc(0);
    }
    var i2;
    if (length === void 0) {
      length = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        length += list[i2].length;
      }
    }
    var buffer2 = Buffer3.allocUnsafe(length);
    var pos = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      var buf = list[i2];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          Buffer3.from(buf).copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(buffer2, buf, pos);
        }
      } else if (!Buffer3.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string, encoding) {
    if (Buffer3.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    }
    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes2(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes2(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes2(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.byteLength = byteLength2;
  function slowToString2(encoding, start, end) {
    var loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice2(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice2(this, start, end);
        case "ascii":
          return asciiSlice2(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice2(this, start, end);
        case "base64":
          return base64Slice2(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice2(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.prototype._isBuffer = true;
  function swap2(b2, n2, m2) {
    var i2 = b2[n2];
    b2[n2] = b2[m2];
    b2[m2] = i2;
  }
  Buffer3.prototype.swap16 = function swap162() {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (var i2 = 0; i2 < len; i2 += 2) {
      swap2(this, i2, i2 + 1);
    }
    return this;
  };
  Buffer3.prototype.swap32 = function swap322() {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (var i2 = 0; i2 < len; i2 += 4) {
      swap2(this, i2, i2 + 3);
      swap2(this, i2 + 1, i2 + 2);
    }
    return this;
  };
  Buffer3.prototype.swap64 = function swap642() {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (var i2 = 0; i2 < len; i2 += 8) {
      swap2(this, i2, i2 + 7);
      swap2(this, i2 + 1, i2 + 6);
      swap2(this, i2 + 2, i2 + 5);
      swap2(this, i2 + 3, i2 + 4);
    }
    return this;
  };
  Buffer3.prototype.toString = function toString4() {
    var length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice2(this, 0, length);
    return slowToString2.apply(this, arguments);
  };
  Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
  Buffer3.prototype.equals = function equals2(b2) {
    if (!Buffer3.isBuffer(b2))
      throw new TypeError("Argument must be a Buffer");
    if (this === b2)
      return true;
    return Buffer3.compare(this, b2) === 0;
  };
  Buffer3.prototype.inspect = function inspect5() {
    var str = "";
    var max2 = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max2)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
  }
  Buffer3.prototype.compare = function compare3(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer3.from(target, target.offset, target.byteLength);
    }
    if (!Buffer3.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    var x2 = thisEnd - thisStart;
    var y2 = end - start;
    var len = Math.min(x2, y2);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for (var i2 = 0; i2 < len; ++i2) {
      if (thisCopy[i2] !== targetCopy[i2]) {
        x2 = thisCopy[i2];
        y2 = targetCopy[i2];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf2(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer3.from(val, encoding);
    }
    if (Buffer3.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf2(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf2(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf2(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i3) {
      if (indexSize === 1) {
        return buf[i3];
      } else {
        return buf.readUInt16BE(i3 * indexSize);
      }
    }
    var i2;
    if (dir) {
      var foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) {
        if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i2;
          if (i2 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i2 -= i2 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i2 = byteOffset; i2 >= 0; i2--) {
        var found = true;
        for (var j2 = 0; j2 < valLength; j2++) {
          if (read2(arr, i2 + j2) !== read2(val, j2)) {
            found = false;
            break;
          }
        }
        if (found)
          return i2;
      }
    }
    return -1;
  }
  Buffer3.prototype.includes = function includes2(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer3.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
    return bidirectionalIndexOf2(this, val, byteOffset, encoding, true);
  };
  Buffer3.prototype.lastIndexOf = function lastIndexOf2(val, byteOffset, encoding) {
    return bidirectionalIndexOf2(this, val, byteOffset, encoding, false);
  };
  function hexWrite2(buf, string, offset2, length) {
    offset2 = Number(offset2) || 0;
    var remaining = buf.length - offset2;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i2 = 0; i2 < length; ++i2) {
      var parsed = parseInt(string.substr(i2 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i2;
      buf[offset2 + i2] = parsed;
    }
    return i2;
  }
  function utf8Write2(buf, string, offset2, length) {
    return blitBuffer2(utf8ToBytes2(string, buf.length - offset2), buf, offset2, length);
  }
  function asciiWrite2(buf, string, offset2, length) {
    return blitBuffer2(asciiToBytes2(string), buf, offset2, length);
  }
  function base64Write2(buf, string, offset2, length) {
    return blitBuffer2(base64ToBytes2(string), buf, offset2, length);
  }
  function ucs2Write2(buf, string, offset2, length) {
    return blitBuffer2(utf16leToBytes2(string, buf.length - offset2), buf, offset2, length);
  }
  Buffer3.prototype.write = function write6(string, offset2, length, encoding) {
    if (offset2 === void 0) {
      encoding = "utf8";
      length = this.length;
      offset2 = 0;
    } else if (length === void 0 && typeof offset2 === "string") {
      encoding = offset2;
      length = this.length;
      offset2 = 0;
    } else if (isFinite(offset2)) {
      offset2 = offset2 >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    var remaining = this.length - offset2;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset2 < 0) || offset2 > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite2(this, string, offset2, length);
        case "utf8":
        case "utf-8":
          return utf8Write2(this, string, offset2, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite2(this, string, offset2, length);
        case "base64":
          return base64Write2(this, string, offset2, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write2(this, string, offset2, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer3.prototype.toJSON = function toJSON3() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice2(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice2(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i2 = start;
    while (i2 < end) {
      var firstByte = buf[i2];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            fourthByte = buf[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray2(res);
  }
  var MAX_ARGUMENTS_LENGTH2 = 4096;
  function decodeCodePointsArray2(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH2) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i2 = 0;
    while (i2 < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH2));
    }
    return res;
  }
  function asciiSlice2(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2] & 127);
    }
    return ret;
  }
  function latin1Slice2(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2]);
    }
    return ret;
  }
  function hexSlice2(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    var out = "";
    for (var i2 = start; i2 < end; ++i2) {
      out += hexSliceLookupTable[buf[i2]];
    }
    return out;
  }
  function utf16leSlice2(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = "";
    for (var i2 = 0; i2 < bytes.length - 1; i2 += 2) {
      res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
    }
    return res;
  }
  Buffer3.prototype.slice = function slice3(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    var newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer3.prototype);
    return newBuf;
  };
  function checkOffset2(offset2, ext, length) {
    if (offset2 % 1 !== 0 || offset2 < 0)
      throw new RangeError("offset is not uint");
    if (offset2 + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE2(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset2(offset2, byteLength3, this.length);
    var val = this[offset2];
    var mul4 = 1;
    var i2 = 0;
    while (++i2 < byteLength3 && (mul4 *= 256)) {
      val += this[offset2 + i2] * mul4;
    }
    return val;
  };
  Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE2(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset2(offset2, byteLength3, this.length);
    }
    var val = this[offset2 + --byteLength3];
    var mul4 = 1;
    while (byteLength3 > 0 && (mul4 *= 256)) {
      val += this[offset2 + --byteLength3] * mul4;
    }
    return val;
  };
  Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt82(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset2(offset2, 1, this.length);
    return this[offset2];
  };
  Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE2(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset2(offset2, 2, this.length);
    return this[offset2] | this[offset2 + 1] << 8;
  };
  Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE2(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset2(offset2, 2, this.length);
    return this[offset2] << 8 | this[offset2 + 1];
  };
  Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE2(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset2(offset2, 4, this.length);
    return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
  };
  Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE2(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset2(offset2, 4, this.length);
    return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
  };
  Buffer3.prototype.readIntLE = function readIntLE2(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset2(offset2, byteLength3, this.length);
    var val = this[offset2];
    var mul4 = 1;
    var i2 = 0;
    while (++i2 < byteLength3 && (mul4 *= 256)) {
      val += this[offset2 + i2] * mul4;
    }
    mul4 *= 128;
    if (val >= mul4)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer3.prototype.readIntBE = function readIntBE2(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset2(offset2, byteLength3, this.length);
    var i2 = byteLength3;
    var mul4 = 1;
    var val = this[offset2 + --i2];
    while (i2 > 0 && (mul4 *= 256)) {
      val += this[offset2 + --i2] * mul4;
    }
    mul4 *= 128;
    if (val >= mul4)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer3.prototype.readInt8 = function readInt82(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset2(offset2, 1, this.length);
    if (!(this[offset2] & 128))
      return this[offset2];
    return (255 - this[offset2] + 1) * -1;
  };
  Buffer3.prototype.readInt16LE = function readInt16LE2(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset2(offset2, 2, this.length);
    var val = this[offset2] | this[offset2 + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt16BE = function readInt16BE2(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset2(offset2, 2, this.length);
    var val = this[offset2 + 1] | this[offset2] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt32LE = function readInt32LE2(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset2(offset2, 4, this.length);
    return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
  };
  Buffer3.prototype.readInt32BE = function readInt32BE2(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset2(offset2, 4, this.length);
    return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
  };
  Buffer3.prototype.readFloatLE = function readFloatLE2(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset2(offset2, 4, this.length);
    return ieee754$1.read(this, offset2, true, 23, 4);
  };
  Buffer3.prototype.readFloatBE = function readFloatBE2(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset2(offset2, 4, this.length);
    return ieee754$1.read(this, offset2, false, 23, 4);
  };
  Buffer3.prototype.readDoubleLE = function readDoubleLE2(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset2(offset2, 8, this.length);
    return ieee754$1.read(this, offset2, true, 52, 8);
  };
  Buffer3.prototype.readDoubleBE = function readDoubleBE2(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset2(offset2, 8, this.length);
    return ieee754$1.read(this, offset2, false, 52, 8);
  };
  function checkInt2(buf, value, offset2, ext, max2, min2) {
    if (!Buffer3.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max2 || value < min2)
      throw new RangeError('"value" argument is out of bounds');
    if (offset2 + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE2(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt2(this, value, offset2, byteLength3, maxBytes, 0);
    }
    var mul4 = 1;
    var i2 = 0;
    this[offset2] = value & 255;
    while (++i2 < byteLength3 && (mul4 *= 256)) {
      this[offset2 + i2] = value / mul4 & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE2(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt2(this, value, offset2, byteLength3, maxBytes, 0);
    }
    var i2 = byteLength3 - 1;
    var mul4 = 1;
    this[offset2 + i2] = value & 255;
    while (--i2 >= 0 && (mul4 *= 256)) {
      this[offset2 + i2] = value / mul4 & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt82(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt2(this, value, offset2, 1, 255, 0);
    this[offset2] = value & 255;
    return offset2 + 1;
  };
  Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE2(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt2(this, value, offset2, 2, 65535, 0);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    return offset2 + 2;
  };
  Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE2(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt2(this, value, offset2, 2, 65535, 0);
    this[offset2] = value >>> 8;
    this[offset2 + 1] = value & 255;
    return offset2 + 2;
  };
  Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE2(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt2(this, value, offset2, 4, 4294967295, 0);
    this[offset2 + 3] = value >>> 24;
    this[offset2 + 2] = value >>> 16;
    this[offset2 + 1] = value >>> 8;
    this[offset2] = value & 255;
    return offset2 + 4;
  };
  Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE2(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt2(this, value, offset2, 4, 4294967295, 0);
    this[offset2] = value >>> 24;
    this[offset2 + 1] = value >>> 16;
    this[offset2 + 2] = value >>> 8;
    this[offset2 + 3] = value & 255;
    return offset2 + 4;
  };
  Buffer3.prototype.writeIntLE = function writeIntLE2(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt2(this, value, offset2, byteLength3, limit - 1, -limit);
    }
    var i2 = 0;
    var mul4 = 1;
    var sub = 0;
    this[offset2] = value & 255;
    while (++i2 < byteLength3 && (mul4 *= 256)) {
      if (value < 0 && sub === 0 && this[offset2 + i2 - 1] !== 0) {
        sub = 1;
      }
      this[offset2 + i2] = (value / mul4 >> 0) - sub & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer3.prototype.writeIntBE = function writeIntBE2(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt2(this, value, offset2, byteLength3, limit - 1, -limit);
    }
    var i2 = byteLength3 - 1;
    var mul4 = 1;
    var sub = 0;
    this[offset2 + i2] = value & 255;
    while (--i2 >= 0 && (mul4 *= 256)) {
      if (value < 0 && sub === 0 && this[offset2 + i2 + 1] !== 0) {
        sub = 1;
      }
      this[offset2 + i2] = (value / mul4 >> 0) - sub & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer3.prototype.writeInt8 = function writeInt82(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt2(this, value, offset2, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset2] = value & 255;
    return offset2 + 1;
  };
  Buffer3.prototype.writeInt16LE = function writeInt16LE2(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt2(this, value, offset2, 2, 32767, -32768);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    return offset2 + 2;
  };
  Buffer3.prototype.writeInt16BE = function writeInt16BE2(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt2(this, value, offset2, 2, 32767, -32768);
    this[offset2] = value >>> 8;
    this[offset2 + 1] = value & 255;
    return offset2 + 2;
  };
  Buffer3.prototype.writeInt32LE = function writeInt32LE2(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt2(this, value, offset2, 4, 2147483647, -2147483648);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    this[offset2 + 2] = value >>> 16;
    this[offset2 + 3] = value >>> 24;
    return offset2 + 4;
  };
  Buffer3.prototype.writeInt32BE = function writeInt32BE2(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt2(this, value, offset2, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset2] = value >>> 24;
    this[offset2 + 1] = value >>> 16;
    this[offset2 + 2] = value >>> 8;
    this[offset2 + 3] = value & 255;
    return offset2 + 4;
  };
  function checkIEEE7542(buf, value, offset2, ext, max2, min2) {
    if (offset2 + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset2 < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat2(buf, value, offset2, littleEndian, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      checkIEEE7542(buf, value, offset2, 4);
    }
    ieee754$1.write(buf, value, offset2, littleEndian, 23, 4);
    return offset2 + 4;
  }
  Buffer3.prototype.writeFloatLE = function writeFloatLE2(value, offset2, noAssert) {
    return writeFloat2(this, value, offset2, true, noAssert);
  };
  Buffer3.prototype.writeFloatBE = function writeFloatBE2(value, offset2, noAssert) {
    return writeFloat2(this, value, offset2, false, noAssert);
  };
  function writeDouble2(buf, value, offset2, littleEndian, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      checkIEEE7542(buf, value, offset2, 8);
    }
    ieee754$1.write(buf, value, offset2, littleEndian, 52, 8);
    return offset2 + 8;
  }
  Buffer3.prototype.writeDoubleLE = function writeDoubleLE2(value, offset2, noAssert) {
    return writeDouble2(this, value, offset2, true, noAssert);
  };
  Buffer3.prototype.writeDoubleBE = function writeDoubleBE2(value, offset2, noAssert) {
    return writeDouble2(this, value, offset2, false, noAssert);
  };
  Buffer3.prototype.copy = function copy4(target, targetStart, start, end) {
    if (!Buffer3.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    var len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
  };
  Buffer3.prototype.fill = function fill3(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        var code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    var i2;
    if (typeof val === "number") {
      for (i2 = start; i2 < end; ++i2) {
        this[i2] = val;
      }
    } else {
      var bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
      var len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i2 = 0; i2 < end - start; ++i2) {
        this[i2 + start] = bytes[i2 % len];
      }
    }
    return this;
  };
  var INVALID_BASE64_RE2 = /[^+/0-9A-Za-z-_]/g;
  function base64clean2(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE2, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes2(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i2 = 0; i2 < length; ++i2) {
      codePoint = string.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes2(str) {
    var byteArray = [];
    for (var i2 = 0; i2 < str.length; ++i2) {
      byteArray.push(str.charCodeAt(i2) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes2(str, units) {
    var c2, hi, lo;
    var byteArray = [];
    for (var i2 = 0; i2 < str.length; ++i2) {
      if ((units -= 2) < 0)
        break;
      c2 = str.charCodeAt(i2);
      hi = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes2(str) {
    return base64.toByteArray(base64clean2(str));
  }
  function blitBuffer2(src, dst, offset2, length) {
    for (var i2 = 0; i2 < length; ++i2) {
      if (i2 + offset2 >= dst.length || i2 >= src.length)
        break;
      dst[i2 + offset2] = src[i2];
    }
    return i2;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  var hexSliceLookupTable = function() {
    var alphabet = "0123456789abcdef";
    var table = new Array(256);
    for (var i2 = 0; i2 < 16; ++i2) {
      var i16 = i2 * 16;
      for (var j2 = 0; j2 < 16; ++j2) {
        table[i16 + j2] = alphabet[i2] + alphabet[j2];
      }
    }
    return table;
  }();
})(buffer);
var BufferUtil$2 = typedarrayBuffer;
var Polynomial = polynomial;
var Buffer2 = buffer.Buffer;
function ReedSolomonEncoder$1(degree) {
  this.genPoly = void 0;
  this.degree = degree;
  if (this.degree)
    this.initialize(this.degree);
}
ReedSolomonEncoder$1.prototype.initialize = function initialize(degree) {
  this.degree = degree;
  this.genPoly = Polynomial.generateECPolynomial(this.degree);
};
ReedSolomonEncoder$1.prototype.encode = function encode2(data2) {
  if (!this.genPoly) {
    throw new Error("Encoder not initialized");
  }
  var pad2 = BufferUtil$2.alloc(this.degree);
  var paddedData = Buffer2.concat([data2, pad2], data2.length + this.degree);
  var remainder = Polynomial.mod(paddedData, this.genPoly);
  var start = this.degree - remainder.length;
  if (start > 0) {
    var buff = BufferUtil$2.alloc(this.degree);
    remainder.copy(buff, start);
    return buff;
  }
  return remainder;
};
var reedSolomonEncoder = ReedSolomonEncoder$1;
var version = {};
var mode = {};
var versionCheck = {};
versionCheck.isValid = function isValid(version2) {
  return !isNaN(version2) && version2 >= 1 && version2 <= 40;
};
var regex = {};
var numeric = "[0-9]+";
var alphanumeric = "[A-Z $%*+\\-./:]+";
var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
kanji = kanji.replace(/u/g, "\\u");
var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
regex.KANJI = new RegExp(kanji, "g");
regex.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
regex.BYTE = new RegExp(byte, "g");
regex.NUMERIC = new RegExp(numeric, "g");
regex.ALPHANUMERIC = new RegExp(alphanumeric, "g");
var TEST_KANJI = new RegExp("^" + kanji + "$");
var TEST_NUMERIC = new RegExp("^" + numeric + "$");
var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
regex.testKanji = function testKanji(str) {
  return TEST_KANJI.test(str);
};
regex.testNumeric = function testNumeric(str) {
  return TEST_NUMERIC.test(str);
};
regex.testAlphanumeric = function testAlphanumeric(str) {
  return TEST_ALPHANUMERIC.test(str);
};
(function(exports) {
  var VersionCheck = versionCheck;
  var Regex = regex;
  exports.NUMERIC = {
    id: "Numeric",
    bit: 1 << 0,
    ccBits: [10, 12, 14]
  };
  exports.ALPHANUMERIC = {
    id: "Alphanumeric",
    bit: 1 << 1,
    ccBits: [9, 11, 13]
  };
  exports.BYTE = {
    id: "Byte",
    bit: 1 << 2,
    ccBits: [8, 16, 16]
  };
  exports.KANJI = {
    id: "Kanji",
    bit: 1 << 3,
    ccBits: [8, 10, 12]
  };
  exports.MIXED = {
    bit: -1
  };
  exports.getCharCountIndicator = function getCharCountIndicator(mode2, version2) {
    if (!mode2.ccBits)
      throw new Error("Invalid mode: " + mode2);
    if (!VersionCheck.isValid(version2)) {
      throw new Error("Invalid version: " + version2);
    }
    if (version2 >= 1 && version2 < 10)
      return mode2.ccBits[0];
    else if (version2 < 27)
      return mode2.ccBits[1];
    return mode2.ccBits[2];
  };
  exports.getBestModeForData = function getBestModeForData(dataStr) {
    if (Regex.testNumeric(dataStr))
      return exports.NUMERIC;
    else if (Regex.testAlphanumeric(dataStr))
      return exports.ALPHANUMERIC;
    else if (Regex.testKanji(dataStr))
      return exports.KANJI;
    else
      return exports.BYTE;
  };
  exports.toString = function toString4(mode2) {
    if (mode2 && mode2.id)
      return mode2.id;
    throw new Error("Invalid mode");
  };
  exports.isValid = function isValid2(mode2) {
    return mode2 && mode2.bit && mode2.ccBits;
  };
  function fromString2(string) {
    if (typeof string !== "string") {
      throw new Error("Param is not a string");
    }
    var lcStr = string.toLowerCase();
    switch (lcStr) {
      case "numeric":
        return exports.NUMERIC;
      case "alphanumeric":
        return exports.ALPHANUMERIC;
      case "kanji":
        return exports.KANJI;
      case "byte":
        return exports.BYTE;
      default:
        throw new Error("Unknown mode: " + string);
    }
  }
  exports.from = function from2(value, defaultValue) {
    if (exports.isValid(value)) {
      return value;
    }
    try {
      return fromString2(value);
    } catch (e2) {
      return defaultValue;
    }
  };
})(mode);
(function(exports) {
  var Utils2 = utils$g;
  var ECCode2 = errorCorrectionCode;
  var ECLevel2 = errorCorrectionLevel;
  var Mode2 = mode;
  var VersionCheck = versionCheck;
  var isArray2 = isarray;
  var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
  var G18_BCH = Utils2.getBCHDigit(G18);
  function getBestVersionForDataLength(mode2, length, errorCorrectionLevel2) {
    for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
      if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel2, mode2)) {
        return currentVersion;
      }
    }
    return void 0;
  }
  function getReservedBitsCount(mode2, version2) {
    return Mode2.getCharCountIndicator(mode2, version2) + 4;
  }
  function getTotalBitsFromDataArray(segments2, version2) {
    var totalBits = 0;
    segments2.forEach(function(data2) {
      var reservedBits = getReservedBitsCount(data2.mode, version2);
      totalBits += reservedBits + data2.getBitsLength();
    });
    return totalBits;
  }
  function getBestVersionForMixedData(segments2, errorCorrectionLevel2) {
    for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
      var length = getTotalBitsFromDataArray(segments2, currentVersion);
      if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel2, Mode2.MIXED)) {
        return currentVersion;
      }
    }
    return void 0;
  }
  exports.from = function from2(value, defaultValue) {
    if (VersionCheck.isValid(value)) {
      return parseInt(value, 10);
    }
    return defaultValue;
  };
  exports.getCapacity = function getCapacity(version2, errorCorrectionLevel2, mode2) {
    if (!VersionCheck.isValid(version2)) {
      throw new Error("Invalid QR Code version");
    }
    if (typeof mode2 === "undefined")
      mode2 = Mode2.BYTE;
    var totalCodewords = Utils2.getSymbolTotalCodewords(version2);
    var ecTotalCodewords = ECCode2.getTotalCodewordsCount(version2, errorCorrectionLevel2);
    var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
    if (mode2 === Mode2.MIXED)
      return dataTotalCodewordsBits;
    var usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode2, version2);
    switch (mode2) {
      case Mode2.NUMERIC:
        return Math.floor(usableBits / 10 * 3);
      case Mode2.ALPHANUMERIC:
        return Math.floor(usableBits / 11 * 2);
      case Mode2.KANJI:
        return Math.floor(usableBits / 13);
      case Mode2.BYTE:
      default:
        return Math.floor(usableBits / 8);
    }
  };
  exports.getBestVersionForData = function getBestVersionForData(data2, errorCorrectionLevel2) {
    var seg;
    var ecl = ECLevel2.from(errorCorrectionLevel2, ECLevel2.M);
    if (isArray2(data2)) {
      if (data2.length > 1) {
        return getBestVersionForMixedData(data2, ecl);
      }
      if (data2.length === 0) {
        return 1;
      }
      seg = data2[0];
    } else {
      seg = data2;
    }
    return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
  };
  exports.getEncodedBits = function getEncodedBits2(version2) {
    if (!VersionCheck.isValid(version2) || version2 < 7) {
      throw new Error("Invalid QR Code version");
    }
    var d2 = version2 << 12;
    while (Utils2.getBCHDigit(d2) - G18_BCH >= 0) {
      d2 ^= G18 << Utils2.getBCHDigit(d2) - G18_BCH;
    }
    return version2 << 12 | d2;
  };
})(version);
var formatInfo = {};
var Utils$3 = utils$g;
var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
var G15_BCH = Utils$3.getBCHDigit(G15);
formatInfo.getEncodedBits = function getEncodedBits(errorCorrectionLevel2, mask) {
  var data2 = errorCorrectionLevel2.bit << 3 | mask;
  var d2 = data2 << 10;
  while (Utils$3.getBCHDigit(d2) - G15_BCH >= 0) {
    d2 ^= G15 << Utils$3.getBCHDigit(d2) - G15_BCH;
  }
  return (data2 << 10 | d2) ^ G15_MASK;
};
var segments = {};
var Mode$4 = mode;
function NumericData(data2) {
  this.mode = Mode$4.NUMERIC;
  this.data = data2.toString();
}
NumericData.getBitsLength = function getBitsLength(length) {
  return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
};
NumericData.prototype.getLength = function getLength2() {
  return this.data.length;
};
NumericData.prototype.getBitsLength = function getBitsLength2() {
  return NumericData.getBitsLength(this.data.length);
};
NumericData.prototype.write = function write4(bitBuffer2) {
  var i2, group, value;
  for (i2 = 0; i2 + 3 <= this.data.length; i2 += 3) {
    group = this.data.substr(i2, 3);
    value = parseInt(group, 10);
    bitBuffer2.put(value, 10);
  }
  var remainingNum = this.data.length - i2;
  if (remainingNum > 0) {
    group = this.data.substr(i2);
    value = parseInt(group, 10);
    bitBuffer2.put(value, remainingNum * 3 + 1);
  }
};
var numericData = NumericData;
var Mode$3 = mode;
var ALPHA_NUM_CHARS = [
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  " ",
  "$",
  "%",
  "*",
  "+",
  "-",
  ".",
  "/",
  ":"
];
function AlphanumericData(data2) {
  this.mode = Mode$3.ALPHANUMERIC;
  this.data = data2;
}
AlphanumericData.getBitsLength = function getBitsLength3(length) {
  return 11 * Math.floor(length / 2) + 6 * (length % 2);
};
AlphanumericData.prototype.getLength = function getLength3() {
  return this.data.length;
};
AlphanumericData.prototype.getBitsLength = function getBitsLength4() {
  return AlphanumericData.getBitsLength(this.data.length);
};
AlphanumericData.prototype.write = function write5(bitBuffer2) {
  var i2;
  for (i2 = 0; i2 + 2 <= this.data.length; i2 += 2) {
    var value = ALPHA_NUM_CHARS.indexOf(this.data[i2]) * 45;
    value += ALPHA_NUM_CHARS.indexOf(this.data[i2 + 1]);
    bitBuffer2.put(value, 11);
  }
  if (this.data.length % 2) {
    bitBuffer2.put(ALPHA_NUM_CHARS.indexOf(this.data[i2]), 6);
  }
};
var alphanumericData = AlphanumericData;
var BufferUtil$1 = typedarrayBuffer;
var Mode$2 = mode;
function ByteData(data2) {
  this.mode = Mode$2.BYTE;
  this.data = BufferUtil$1.from(data2);
}
ByteData.getBitsLength = function getBitsLength5(length) {
  return length * 8;
};
ByteData.prototype.getLength = function getLength4() {
  return this.data.length;
};
ByteData.prototype.getBitsLength = function getBitsLength6() {
  return ByteData.getBitsLength(this.data.length);
};
ByteData.prototype.write = function(bitBuffer2) {
  for (var i2 = 0, l2 = this.data.length; i2 < l2; i2++) {
    bitBuffer2.put(this.data[i2], 8);
  }
};
var byteData = ByteData;
var Mode$1 = mode;
var Utils$2 = utils$g;
function KanjiData(data2) {
  this.mode = Mode$1.KANJI;
  this.data = data2;
}
KanjiData.getBitsLength = function getBitsLength7(length) {
  return length * 13;
};
KanjiData.prototype.getLength = function getLength5() {
  return this.data.length;
};
KanjiData.prototype.getBitsLength = function getBitsLength8() {
  return KanjiData.getBitsLength(this.data.length);
};
KanjiData.prototype.write = function(bitBuffer2) {
  var i2;
  for (i2 = 0; i2 < this.data.length; i2++) {
    var value = Utils$2.toSJIS(this.data[i2]);
    if (value >= 33088 && value <= 40956) {
      value -= 33088;
    } else if (value >= 57408 && value <= 60351) {
      value -= 49472;
    } else {
      throw new Error("Invalid SJIS character: " + this.data[i2] + "\nMake sure your charset is UTF-8");
    }
    value = (value >>> 8 & 255) * 192 + (value & 255);
    bitBuffer2.put(value, 13);
  }
};
var kanjiData = KanjiData;
var dijkstra = { exports: {} };
(function(module) {
  var dijkstra2 = {
    single_source_shortest_paths: function(graph, s2, d2) {
      var predecessors = {};
      var costs = {};
      costs[s2] = 0;
      var open2 = dijkstra2.PriorityQueue.make();
      open2.push(s2, 0);
      var closest, u2, v2, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
      while (!open2.empty()) {
        closest = open2.pop();
        u2 = closest.value;
        cost_of_s_to_u = closest.cost;
        adjacent_nodes = graph[u2] || {};
        for (v2 in adjacent_nodes) {
          if (adjacent_nodes.hasOwnProperty(v2)) {
            cost_of_e = adjacent_nodes[v2];
            cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
            cost_of_s_to_v = costs[v2];
            first_visit = typeof costs[v2] === "undefined";
            if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
              costs[v2] = cost_of_s_to_u_plus_cost_of_e;
              open2.push(v2, cost_of_s_to_u_plus_cost_of_e);
              predecessors[v2] = u2;
            }
          }
        }
      }
      if (typeof d2 !== "undefined" && typeof costs[d2] === "undefined") {
        var msg = ["Could not find a path from ", s2, " to ", d2, "."].join("");
        throw new Error(msg);
      }
      return predecessors;
    },
    extract_shortest_path_from_predecessor_list: function(predecessors, d2) {
      var nodes = [];
      var u2 = d2;
      while (u2) {
        nodes.push(u2);
        u2 = predecessors[u2];
      }
      nodes.reverse();
      return nodes;
    },
    find_path: function(graph, s2, d2) {
      var predecessors = dijkstra2.single_source_shortest_paths(graph, s2, d2);
      return dijkstra2.extract_shortest_path_from_predecessor_list(predecessors, d2);
    },
    PriorityQueue: {
      make: function(opts) {
        var T2 = dijkstra2.PriorityQueue, t2 = {}, key2;
        opts = opts || {};
        for (key2 in T2) {
          if (T2.hasOwnProperty(key2)) {
            t2[key2] = T2[key2];
          }
        }
        t2.queue = [];
        t2.sorter = opts.sorter || T2.default_sorter;
        return t2;
      },
      default_sorter: function(a2, b2) {
        return a2.cost - b2.cost;
      },
      push: function(value, cost) {
        var item = { value, cost };
        this.queue.push(item);
        this.queue.sort(this.sorter);
      },
      pop: function() {
        return this.queue.shift();
      },
      empty: function() {
        return this.queue.length === 0;
      }
    }
  };
  {
    module.exports = dijkstra2;
  }
})(dijkstra);
(function(exports) {
  var Mode2 = mode;
  var NumericData2 = numericData;
  var AlphanumericData2 = alphanumericData;
  var ByteData2 = byteData;
  var KanjiData2 = kanjiData;
  var Regex = regex;
  var Utils2 = utils$g;
  var dijkstra$1 = dijkstra.exports;
  function getStringByteLength(str) {
    return unescape(encodeURIComponent(str)).length;
  }
  function getSegments(regex2, mode2, str) {
    var segments2 = [];
    var result;
    while ((result = regex2.exec(str)) !== null) {
      segments2.push({
        data: result[0],
        index: result.index,
        mode: mode2,
        length: result[0].length
      });
    }
    return segments2;
  }
  function getSegmentsFromString(dataStr) {
    var numSegs = getSegments(Regex.NUMERIC, Mode2.NUMERIC, dataStr);
    var alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode2.ALPHANUMERIC, dataStr);
    var byteSegs;
    var kanjiSegs;
    if (Utils2.isKanjiModeEnabled()) {
      byteSegs = getSegments(Regex.BYTE, Mode2.BYTE, dataStr);
      kanjiSegs = getSegments(Regex.KANJI, Mode2.KANJI, dataStr);
    } else {
      byteSegs = getSegments(Regex.BYTE_KANJI, Mode2.BYTE, dataStr);
      kanjiSegs = [];
    }
    var segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
    return segs.sort(function(s1, s2) {
      return s1.index - s2.index;
    }).map(function(obj) {
      return {
        data: obj.data,
        mode: obj.mode,
        length: obj.length
      };
    });
  }
  function getSegmentBitsLength(length, mode2) {
    switch (mode2) {
      case Mode2.NUMERIC:
        return NumericData2.getBitsLength(length);
      case Mode2.ALPHANUMERIC:
        return AlphanumericData2.getBitsLength(length);
      case Mode2.KANJI:
        return KanjiData2.getBitsLength(length);
      case Mode2.BYTE:
        return ByteData2.getBitsLength(length);
    }
  }
  function mergeSegments(segs) {
    return segs.reduce(function(acc, curr) {
      var prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
      if (prevSeg && prevSeg.mode === curr.mode) {
        acc[acc.length - 1].data += curr.data;
        return acc;
      }
      acc.push(curr);
      return acc;
    }, []);
  }
  function buildNodes(segs) {
    var nodes = [];
    for (var i2 = 0; i2 < segs.length; i2++) {
      var seg = segs[i2];
      switch (seg.mode) {
        case Mode2.NUMERIC:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.ALPHANUMERIC, length: seg.length },
            { data: seg.data, mode: Mode2.BYTE, length: seg.length }
          ]);
          break;
        case Mode2.ALPHANUMERIC:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.BYTE, length: seg.length }
          ]);
          break;
        case Mode2.KANJI:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.BYTE, length: getStringByteLength(seg.data) }
          ]);
          break;
        case Mode2.BYTE:
          nodes.push([
            { data: seg.data, mode: Mode2.BYTE, length: getStringByteLength(seg.data) }
          ]);
      }
    }
    return nodes;
  }
  function buildGraph(nodes, version2) {
    var table = {};
    var graph = { "start": {} };
    var prevNodeIds = ["start"];
    for (var i2 = 0; i2 < nodes.length; i2++) {
      var nodeGroup = nodes[i2];
      var currentNodeIds = [];
      for (var j2 = 0; j2 < nodeGroup.length; j2++) {
        var node = nodeGroup[j2];
        var key2 = "" + i2 + j2;
        currentNodeIds.push(key2);
        table[key2] = { node, lastCount: 0 };
        graph[key2] = {};
        for (var n2 = 0; n2 < prevNodeIds.length; n2++) {
          var prevNodeId = prevNodeIds[n2];
          if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
            graph[prevNodeId][key2] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
            table[prevNodeId].lastCount += node.length;
          } else {
            if (table[prevNodeId])
              table[prevNodeId].lastCount = node.length;
            graph[prevNodeId][key2] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode2.getCharCountIndicator(node.mode, version2);
          }
        }
      }
      prevNodeIds = currentNodeIds;
    }
    for (n2 = 0; n2 < prevNodeIds.length; n2++) {
      graph[prevNodeIds[n2]]["end"] = 0;
    }
    return { map: graph, table };
  }
  function buildSingleSegment(data2, modesHint) {
    var mode2;
    var bestMode = Mode2.getBestModeForData(data2);
    mode2 = Mode2.from(modesHint, bestMode);
    if (mode2 !== Mode2.BYTE && mode2.bit < bestMode.bit) {
      throw new Error('"' + data2 + '" cannot be encoded with mode ' + Mode2.toString(mode2) + ".\n Suggested mode is: " + Mode2.toString(bestMode));
    }
    if (mode2 === Mode2.KANJI && !Utils2.isKanjiModeEnabled()) {
      mode2 = Mode2.BYTE;
    }
    switch (mode2) {
      case Mode2.NUMERIC:
        return new NumericData2(data2);
      case Mode2.ALPHANUMERIC:
        return new AlphanumericData2(data2);
      case Mode2.KANJI:
        return new KanjiData2(data2);
      case Mode2.BYTE:
        return new ByteData2(data2);
    }
  }
  exports.fromArray = function fromArray(array) {
    return array.reduce(function(acc, seg) {
      if (typeof seg === "string") {
        acc.push(buildSingleSegment(seg, null));
      } else if (seg.data) {
        acc.push(buildSingleSegment(seg.data, seg.mode));
      }
      return acc;
    }, []);
  };
  exports.fromString = function fromString2(data2, version2) {
    var segs = getSegmentsFromString(data2, Utils2.isKanjiModeEnabled());
    var nodes = buildNodes(segs);
    var graph = buildGraph(nodes, version2);
    var path = dijkstra$1.find_path(graph.map, "start", "end");
    var optimizedSegs = [];
    for (var i2 = 1; i2 < path.length - 1; i2++) {
      optimizedSegs.push(graph.table[path[i2]].node);
    }
    return exports.fromArray(mergeSegments(optimizedSegs));
  };
  exports.rawSplit = function rawSplit(data2) {
    return exports.fromArray(getSegmentsFromString(data2, Utils2.isKanjiModeEnabled()));
  };
})(segments);
var BufferUtil = typedarrayBuffer;
var Utils$1 = utils$g;
var ECLevel = errorCorrectionLevel;
var BitBuffer = bitBuffer;
var BitMatrix = bitMatrix;
var AlignmentPattern = alignmentPattern;
var FinderPattern = finderPattern;
var MaskPattern = maskPattern;
var ECCode = errorCorrectionCode;
var ReedSolomonEncoder = reedSolomonEncoder;
var Version = version;
var FormatInfo = formatInfo;
var Mode = mode;
var Segments = segments;
var isArray$1 = isarray;
function setupFinderPattern(matrix, version2) {
  var size2 = matrix.size;
  var pos = FinderPattern.getPositions(version2);
  for (var i2 = 0; i2 < pos.length; i2++) {
    var row = pos[i2][0];
    var col = pos[i2][1];
    for (var r2 = -1; r2 <= 7; r2++) {
      if (row + r2 <= -1 || size2 <= row + r2)
        continue;
      for (var c2 = -1; c2 <= 7; c2++) {
        if (col + c2 <= -1 || size2 <= col + c2)
          continue;
        if (r2 >= 0 && r2 <= 6 && (c2 === 0 || c2 === 6) || c2 >= 0 && c2 <= 6 && (r2 === 0 || r2 === 6) || r2 >= 2 && r2 <= 4 && c2 >= 2 && c2 <= 4) {
          matrix.set(row + r2, col + c2, true, true);
        } else {
          matrix.set(row + r2, col + c2, false, true);
        }
      }
    }
  }
}
function setupTimingPattern(matrix) {
  var size2 = matrix.size;
  for (var r2 = 8; r2 < size2 - 8; r2++) {
    var value = r2 % 2 === 0;
    matrix.set(r2, 6, value, true);
    matrix.set(6, r2, value, true);
  }
}
function setupAlignmentPattern(matrix, version2) {
  var pos = AlignmentPattern.getPositions(version2);
  for (var i2 = 0; i2 < pos.length; i2++) {
    var row = pos[i2][0];
    var col = pos[i2][1];
    for (var r2 = -2; r2 <= 2; r2++) {
      for (var c2 = -2; c2 <= 2; c2++) {
        if (r2 === -2 || r2 === 2 || c2 === -2 || c2 === 2 || r2 === 0 && c2 === 0) {
          matrix.set(row + r2, col + c2, true, true);
        } else {
          matrix.set(row + r2, col + c2, false, true);
        }
      }
    }
  }
}
function setupVersionInfo(matrix, version2) {
  var size2 = matrix.size;
  var bits = Version.getEncodedBits(version2);
  var row, col, mod;
  for (var i2 = 0; i2 < 18; i2++) {
    row = Math.floor(i2 / 3);
    col = i2 % 3 + size2 - 8 - 3;
    mod = (bits >> i2 & 1) === 1;
    matrix.set(row, col, mod, true);
    matrix.set(col, row, mod, true);
  }
}
function setupFormatInfo(matrix, errorCorrectionLevel2, maskPattern2) {
  var size2 = matrix.size;
  var bits = FormatInfo.getEncodedBits(errorCorrectionLevel2, maskPattern2);
  var i2, mod;
  for (i2 = 0; i2 < 15; i2++) {
    mod = (bits >> i2 & 1) === 1;
    if (i2 < 6) {
      matrix.set(i2, 8, mod, true);
    } else if (i2 < 8) {
      matrix.set(i2 + 1, 8, mod, true);
    } else {
      matrix.set(size2 - 15 + i2, 8, mod, true);
    }
    if (i2 < 8) {
      matrix.set(8, size2 - i2 - 1, mod, true);
    } else if (i2 < 9) {
      matrix.set(8, 15 - i2 - 1 + 1, mod, true);
    } else {
      matrix.set(8, 15 - i2 - 1, mod, true);
    }
  }
  matrix.set(size2 - 8, 8, 1, true);
}
function setupData(matrix, data2) {
  var size2 = matrix.size;
  var inc = -1;
  var row = size2 - 1;
  var bitIndex = 7;
  var byteIndex = 0;
  for (var col = size2 - 1; col > 0; col -= 2) {
    if (col === 6)
      col--;
    while (true) {
      for (var c2 = 0; c2 < 2; c2++) {
        if (!matrix.isReserved(row, col - c2)) {
          var dark = false;
          if (byteIndex < data2.length) {
            dark = (data2[byteIndex] >>> bitIndex & 1) === 1;
          }
          matrix.set(row, col - c2, dark);
          bitIndex--;
          if (bitIndex === -1) {
            byteIndex++;
            bitIndex = 7;
          }
        }
      }
      row += inc;
      if (row < 0 || size2 <= row) {
        row -= inc;
        inc = -inc;
        break;
      }
    }
  }
}
function createData(version2, errorCorrectionLevel2, segments2) {
  var buffer2 = new BitBuffer();
  segments2.forEach(function(data2) {
    buffer2.put(data2.mode.bit, 4);
    buffer2.put(data2.getLength(), Mode.getCharCountIndicator(data2.mode, version2));
    data2.write(buffer2);
  });
  var totalCodewords = Utils$1.getSymbolTotalCodewords(version2);
  var ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
  var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
  if (buffer2.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
    buffer2.put(0, 4);
  }
  while (buffer2.getLengthInBits() % 8 !== 0) {
    buffer2.putBit(0);
  }
  var remainingByte = (dataTotalCodewordsBits - buffer2.getLengthInBits()) / 8;
  for (var i2 = 0; i2 < remainingByte; i2++) {
    buffer2.put(i2 % 2 ? 17 : 236, 8);
  }
  return createCodewords(buffer2, version2, errorCorrectionLevel2);
}
function createCodewords(bitBuffer2, version2, errorCorrectionLevel2) {
  var totalCodewords = Utils$1.getSymbolTotalCodewords(version2);
  var ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
  var dataTotalCodewords = totalCodewords - ecTotalCodewords;
  var ecTotalBlocks = ECCode.getBlocksCount(version2, errorCorrectionLevel2);
  var blocksInGroup2 = totalCodewords % ecTotalBlocks;
  var blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
  var totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
  var dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
  var dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
  var ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
  var rs = new ReedSolomonEncoder(ecCount);
  var offset2 = 0;
  var dcData = new Array(ecTotalBlocks);
  var ecData = new Array(ecTotalBlocks);
  var maxDataSize = 0;
  var buffer2 = BufferUtil.from(bitBuffer2.buffer);
  for (var b2 = 0; b2 < ecTotalBlocks; b2++) {
    var dataSize = b2 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
    dcData[b2] = buffer2.slice(offset2, offset2 + dataSize);
    ecData[b2] = rs.encode(dcData[b2]);
    offset2 += dataSize;
    maxDataSize = Math.max(maxDataSize, dataSize);
  }
  var data2 = BufferUtil.alloc(totalCodewords);
  var index2 = 0;
  var i2, r2;
  for (i2 = 0; i2 < maxDataSize; i2++) {
    for (r2 = 0; r2 < ecTotalBlocks; r2++) {
      if (i2 < dcData[r2].length) {
        data2[index2++] = dcData[r2][i2];
      }
    }
  }
  for (i2 = 0; i2 < ecCount; i2++) {
    for (r2 = 0; r2 < ecTotalBlocks; r2++) {
      data2[index2++] = ecData[r2][i2];
    }
  }
  return data2;
}
function createSymbol(data2, version2, errorCorrectionLevel2, maskPattern2) {
  var segments2;
  if (isArray$1(data2)) {
    segments2 = Segments.fromArray(data2);
  } else if (typeof data2 === "string") {
    var estimatedVersion = version2;
    if (!estimatedVersion) {
      var rawSegments = Segments.rawSplit(data2);
      estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel2);
    }
    segments2 = Segments.fromString(data2, estimatedVersion || 40);
  } else {
    throw new Error("Invalid data");
  }
  var bestVersion = Version.getBestVersionForData(segments2, errorCorrectionLevel2);
  if (!bestVersion) {
    throw new Error("The amount of data is too big to be stored in a QR Code");
  }
  if (!version2) {
    version2 = bestVersion;
  } else if (version2 < bestVersion) {
    throw new Error("\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n");
  }
  var dataBits = createData(version2, errorCorrectionLevel2, segments2);
  var moduleCount = Utils$1.getSymbolSize(version2);
  var modules = new BitMatrix(moduleCount);
  setupFinderPattern(modules, version2);
  setupTimingPattern(modules);
  setupAlignmentPattern(modules, version2);
  setupFormatInfo(modules, errorCorrectionLevel2, 0);
  if (version2 >= 7) {
    setupVersionInfo(modules, version2);
  }
  setupData(modules, dataBits);
  if (isNaN(maskPattern2)) {
    maskPattern2 = MaskPattern.getBestMask(modules, setupFormatInfo.bind(null, modules, errorCorrectionLevel2));
  }
  MaskPattern.applyMask(maskPattern2, modules);
  setupFormatInfo(modules, errorCorrectionLevel2, maskPattern2);
  return {
    modules,
    version: version2,
    errorCorrectionLevel: errorCorrectionLevel2,
    maskPattern: maskPattern2,
    segments: segments2
  };
}
qrcode.create = function create(data2, options) {
  if (typeof data2 === "undefined" || data2 === "") {
    throw new Error("No input text");
  }
  var errorCorrectionLevel2 = ECLevel.M;
  var version2;
  var mask;
  if (typeof options !== "undefined") {
    errorCorrectionLevel2 = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
    version2 = Version.from(options.version);
    mask = MaskPattern.from(options.maskPattern);
    if (options.toSJISFunc) {
      Utils$1.setToSJISFunction(options.toSJISFunc);
    }
  }
  return createSymbol(data2, version2, errorCorrectionLevel2, mask);
};
var canvas = {};
var utils$f = {};
(function(exports) {
  function hex2rgba(hex) {
    if (typeof hex === "number") {
      hex = hex.toString();
    }
    if (typeof hex !== "string") {
      throw new Error("Color should be defined as hex string");
    }
    var hexCode = hex.slice().replace("#", "").split("");
    if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
      throw new Error("Invalid hex color: " + hex);
    }
    if (hexCode.length === 3 || hexCode.length === 4) {
      hexCode = Array.prototype.concat.apply([], hexCode.map(function(c2) {
        return [c2, c2];
      }));
    }
    if (hexCode.length === 6)
      hexCode.push("F", "F");
    var hexValue2 = parseInt(hexCode.join(""), 16);
    return {
      r: hexValue2 >> 24 & 255,
      g: hexValue2 >> 16 & 255,
      b: hexValue2 >> 8 & 255,
      a: hexValue2 & 255,
      hex: "#" + hexCode.slice(0, 6).join("")
    };
  }
  exports.getOptions = function getOptions2(options) {
    if (!options)
      options = {};
    if (!options.color)
      options.color = {};
    var margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
    var width = options.width && options.width >= 21 ? options.width : void 0;
    var scale = options.scale || 4;
    return {
      width,
      scale: width ? 4 : scale,
      margin,
      color: {
        dark: hex2rgba(options.color.dark || "#000000ff"),
        light: hex2rgba(options.color.light || "#ffffffff")
      },
      type: options.type,
      rendererOpts: options.rendererOpts || {}
    };
  };
  exports.getScale = function getScale(qrSize, opts) {
    return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
  };
  exports.getImageWidth = function getImageWidth(qrSize, opts) {
    var scale = exports.getScale(qrSize, opts);
    return Math.floor((qrSize + opts.margin * 2) * scale);
  };
  exports.qrToImageData = function qrToImageData(imgData, qr2, opts) {
    var size2 = qr2.modules.size;
    var data2 = qr2.modules.data;
    var scale = exports.getScale(size2, opts);
    var symbolSize = Math.floor((size2 + opts.margin * 2) * scale);
    var scaledMargin = opts.margin * scale;
    var palette = [opts.color.light, opts.color.dark];
    for (var i2 = 0; i2 < symbolSize; i2++) {
      for (var j2 = 0; j2 < symbolSize; j2++) {
        var posDst = (i2 * symbolSize + j2) * 4;
        var pxColor = opts.color.light;
        if (i2 >= scaledMargin && j2 >= scaledMargin && i2 < symbolSize - scaledMargin && j2 < symbolSize - scaledMargin) {
          var iSrc = Math.floor((i2 - scaledMargin) / scale);
          var jSrc = Math.floor((j2 - scaledMargin) / scale);
          pxColor = palette[data2[iSrc * size2 + jSrc] ? 1 : 0];
        }
        imgData[posDst++] = pxColor.r;
        imgData[posDst++] = pxColor.g;
        imgData[posDst++] = pxColor.b;
        imgData[posDst] = pxColor.a;
      }
    }
  };
})(utils$f);
(function(exports) {
  var Utils2 = utils$f;
  function clearCanvas(ctx, canvas2, size2) {
    ctx.clearRect(0, 0, canvas2.width, canvas2.height);
    if (!canvas2.style)
      canvas2.style = {};
    canvas2.height = size2;
    canvas2.width = size2;
    canvas2.style.height = size2 + "px";
    canvas2.style.width = size2 + "px";
  }
  function getCanvasElement() {
    try {
      return document.createElement("canvas");
    } catch (e2) {
      throw new Error("You need to specify a canvas element");
    }
  }
  exports.render = function render3(qrData, canvas2, options) {
    var opts = options;
    var canvasEl = canvas2;
    if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
      opts = canvas2;
      canvas2 = void 0;
    }
    if (!canvas2) {
      canvasEl = getCanvasElement();
    }
    opts = Utils2.getOptions(opts);
    var size2 = Utils2.getImageWidth(qrData.modules.size, opts);
    var ctx = canvasEl.getContext("2d");
    var image = ctx.createImageData(size2, size2);
    Utils2.qrToImageData(image.data, qrData, opts);
    clearCanvas(ctx, canvasEl, size2);
    ctx.putImageData(image, 0, 0);
    return canvasEl;
  };
  exports.renderToDataURL = function renderToDataURL(qrData, canvas2, options) {
    var opts = options;
    if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
      opts = canvas2;
      canvas2 = void 0;
    }
    if (!opts)
      opts = {};
    var canvasEl = exports.render(qrData, canvas2, opts);
    var type = opts.type || "image/png";
    var rendererOpts = opts.rendererOpts || {};
    return canvasEl.toDataURL(type, rendererOpts.quality);
  };
})(canvas);
var svgTag = {};
var Utils = utils$f;
function getColorAttrib(color, attrib) {
  var alpha = color.a / 255;
  var str = attrib + '="' + color.hex + '"';
  return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
}
function svgCmd(cmd, x2, y2) {
  var str = cmd + x2;
  if (typeof y2 !== "undefined")
    str += " " + y2;
  return str;
}
function qrToPath(data2, size2, margin) {
  var path = "";
  var moveBy = 0;
  var newRow = false;
  var lineLength = 0;
  for (var i2 = 0; i2 < data2.length; i2++) {
    var col = Math.floor(i2 % size2);
    var row = Math.floor(i2 / size2);
    if (!col && !newRow)
      newRow = true;
    if (data2[i2]) {
      lineLength++;
      if (!(i2 > 0 && col > 0 && data2[i2 - 1])) {
        path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
        moveBy = 0;
        newRow = false;
      }
      if (!(col + 1 < size2 && data2[i2 + 1])) {
        path += svgCmd("h", lineLength);
        lineLength = 0;
      }
    } else {
      moveBy++;
    }
  }
  return path;
}
svgTag.render = function render(qrData, options, cb) {
  var opts = Utils.getOptions(options);
  var size2 = qrData.modules.size;
  var data2 = qrData.modules.data;
  var qrcodesize = size2 + opts.margin * 2;
  var bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
  var path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data2, size2, opts.margin) + '"/>';
  var viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
  var width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
  var svgTag2 = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
  if (typeof cb === "function") {
    cb(null, svgTag2);
  }
  return svgTag2;
};
var canPromise = canPromise$1;
var QRCode$1 = qrcode;
var CanvasRenderer = canvas;
var SvgRenderer = svgTag;
function renderCanvas(renderFunc, canvas2, text, opts, cb) {
  var args = [].slice.call(arguments, 1);
  var argsNum = args.length;
  var isLastArgCb = typeof args[argsNum - 1] === "function";
  if (!isLastArgCb && !canPromise()) {
    throw new Error("Callback required as last argument");
  }
  if (isLastArgCb) {
    if (argsNum < 2) {
      throw new Error("Too few arguments provided");
    }
    if (argsNum === 2) {
      cb = text;
      text = canvas2;
      canvas2 = opts = void 0;
    } else if (argsNum === 3) {
      if (canvas2.getContext && typeof cb === "undefined") {
        cb = opts;
        opts = void 0;
      } else {
        cb = opts;
        opts = text;
        text = canvas2;
        canvas2 = void 0;
      }
    }
  } else {
    if (argsNum < 1) {
      throw new Error("Too few arguments provided");
    }
    if (argsNum === 1) {
      text = canvas2;
      canvas2 = opts = void 0;
    } else if (argsNum === 2 && !canvas2.getContext) {
      opts = text;
      text = canvas2;
      canvas2 = void 0;
    }
    return new Promise(function(resolve2, reject) {
      try {
        var data3 = QRCode$1.create(text, opts);
        resolve2(renderFunc(data3, canvas2, opts));
      } catch (e2) {
        reject(e2);
      }
    });
  }
  try {
    var data2 = QRCode$1.create(text, opts);
    cb(null, renderFunc(data2, canvas2, opts));
  } catch (e2) {
    cb(e2);
  }
}
browser.create = QRCode$1.create;
browser.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
browser.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
browser.toString = renderCanvas.bind(null, function(data2, _2, opts) {
  return SvgRenderer.render(data2, opts);
});
var toggleSelection = function() {
  var selection = document.getSelection();
  if (!selection.rangeCount) {
    return function() {
    };
  }
  var active = document.activeElement;
  var ranges = [];
  for (var i2 = 0; i2 < selection.rangeCount; i2++) {
    ranges.push(selection.getRangeAt(i2));
  }
  switch (active.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      active.blur();
      break;
    default:
      active = null;
      break;
  }
  selection.removeAllRanges();
  return function() {
    selection.type === "Caret" && selection.removeAllRanges();
    if (!selection.rangeCount) {
      ranges.forEach(function(range) {
        selection.addRange(range);
      });
    }
    active && active.focus();
  };
};
var deselectCurrent = toggleSelection;
var clipboardToIE11Formatting = {
  "text/plain": "Text",
  "text/html": "Url",
  "default": "Text"
};
var defaultMessage = "Copy to clipboard: #{key}, Enter";
function format(message) {
  var copyKey = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
  return message.replace(/#{\s*key\s*}/g, copyKey);
}
function copy$1(text, options) {
  var debug, message, reselectPrevious, range, selection, mark, success = false;
  if (!options) {
    options = {};
  }
  debug = options.debug || false;
  try {
    reselectPrevious = deselectCurrent();
    range = document.createRange();
    selection = document.getSelection();
    mark = document.createElement("span");
    mark.textContent = text;
    mark.style.all = "unset";
    mark.style.position = "fixed";
    mark.style.top = 0;
    mark.style.clip = "rect(0, 0, 0, 0)";
    mark.style.whiteSpace = "pre";
    mark.style.webkitUserSelect = "text";
    mark.style.MozUserSelect = "text";
    mark.style.msUserSelect = "text";
    mark.style.userSelect = "text";
    mark.addEventListener("copy", function(e2) {
      e2.stopPropagation();
      if (options.format) {
        e2.preventDefault();
        if (typeof e2.clipboardData === "undefined") {
          debug && console.warn("unable to use e.clipboardData");
          debug && console.warn("trying IE specific stuff");
          window.clipboardData.clearData();
          var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
          window.clipboardData.setData(format2, text);
        } else {
          e2.clipboardData.clearData();
          e2.clipboardData.setData(options.format, text);
        }
      }
      if (options.onCopy) {
        e2.preventDefault();
        options.onCopy(e2.clipboardData);
      }
    });
    document.body.appendChild(mark);
    range.selectNodeContents(mark);
    selection.addRange(range);
    var successful = document.execCommand("copy");
    if (!successful) {
      throw new Error("copy command was unsuccessful");
    }
    success = true;
  } catch (err) {
    debug && console.error("unable to copy using execCommand: ", err);
    debug && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(options.format || "text", text);
      options.onCopy && options.onCopy(window.clipboardData);
      success = true;
    } catch (err2) {
      debug && console.error("unable to copy using clipboardData: ", err2);
      debug && console.error("falling back to prompt");
      message = format("message" in options ? options.message : defaultMessage);
      window.prompt(message, text);
    }
  } finally {
    if (selection) {
      if (typeof selection.removeRange == "function") {
        selection.removeRange(range);
      } else {
        selection.removeAllRanges();
      }
    }
    if (mark) {
      document.body.removeChild(mark);
    }
    reselectPrevious();
  }
  return success;
}
var copyToClipboard = copy$1;
var n, u$1, i$1, t$1, r$1, o$1, f$1, e$1 = {}, c$1 = [], s$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
function a$1(n2, l2) {
  for (var u2 in l2)
    n2[u2] = l2[u2];
  return n2;
}
function v$2(n2) {
  var l2 = n2.parentNode;
  l2 && l2.removeChild(n2);
}
function h$2(n2, l2, u2) {
  var i2, t2 = arguments, r2 = {};
  for (i2 in l2)
    i2 !== "key" && i2 !== "ref" && (r2[i2] = l2[i2]);
  if (arguments.length > 3)
    for (u2 = [u2], i2 = 3; i2 < arguments.length; i2++)
      u2.push(t2[i2]);
  if (u2 != null && (r2.children = u2), typeof n2 == "function" && n2.defaultProps != null)
    for (i2 in n2.defaultProps)
      r2[i2] === void 0 && (r2[i2] = n2.defaultProps[i2]);
  return p$1(n2, r2, l2 && l2.key, l2 && l2.ref, null);
}
function p$1(l2, u2, i2, t2, r2) {
  var o2 = { type: l2, props: u2, key: i2, ref: t2, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: r2 };
  return r2 == null && (o2.__v = o2), n.vnode && n.vnode(o2), o2;
}
function y$1() {
  return {};
}
function d$1(n2) {
  return n2.children;
}
function m$1(n2, l2) {
  this.props = n2, this.context = l2;
}
function w$2(n2, l2) {
  if (l2 == null)
    return n2.__ ? w$2(n2.__, n2.__.__k.indexOf(n2) + 1) : null;
  for (var u2; l2 < n2.__k.length; l2++)
    if ((u2 = n2.__k[l2]) != null && u2.__e != null)
      return u2.__e;
  return typeof n2.type == "function" ? w$2(n2) : null;
}
function k$1(n2) {
  var l2, u2;
  if ((n2 = n2.__) != null && n2.__c != null) {
    for (n2.__e = n2.__c.base = null, l2 = 0; l2 < n2.__k.length; l2++)
      if ((u2 = n2.__k[l2]) != null && u2.__e != null) {
        n2.__e = n2.__c.base = u2.__e;
        break;
      }
    return k$1(n2);
  }
}
function g$1(l2) {
  (!l2.__d && (l2.__d = true) && u$1.push(l2) && !i$1++ || r$1 !== n.debounceRendering) && ((r$1 = n.debounceRendering) || t$1)(_$2);
}
function _$2() {
  for (var n2; i$1 = u$1.length; )
    n2 = u$1.sort(function(n3, l2) {
      return n3.__v.__b - l2.__v.__b;
    }), u$1 = [], n2.some(function(n3) {
      var l2, u2, i2, t2, r2, o2, f2;
      n3.__d && (o2 = (r2 = (l2 = n3).__v).__e, (f2 = l2.__P) && (u2 = [], (i2 = a$1({}, r2)).__v = i2, t2 = A$2(f2, r2, i2, l2.__n, f2.ownerSVGElement !== void 0, null, u2, o2 == null ? w$2(r2) : o2), T$3(u2, r2), t2 != o2 && k$1(r2)));
    });
}
function b(n2, l2, u2, i2, t2, r2, o2, f2, s2) {
  var a2, h2, p2, y2, d2, m2, k2, g2 = u2 && u2.__k || c$1, _2 = g2.length;
  if (f2 == e$1 && (f2 = r2 != null ? r2[0] : _2 ? w$2(u2, 0) : null), a2 = 0, l2.__k = x$2(l2.__k, function(u3) {
    if (u3 != null) {
      if (u3.__ = l2, u3.__b = l2.__b + 1, (p2 = g2[a2]) === null || p2 && u3.key == p2.key && u3.type === p2.type)
        g2[a2] = void 0;
      else
        for (h2 = 0; h2 < _2; h2++) {
          if ((p2 = g2[h2]) && u3.key == p2.key && u3.type === p2.type) {
            g2[h2] = void 0;
            break;
          }
          p2 = null;
        }
      if (y2 = A$2(n2, u3, p2 = p2 || e$1, i2, t2, r2, o2, f2, s2), (h2 = u3.ref) && p2.ref != h2 && (k2 || (k2 = []), p2.ref && k2.push(p2.ref, null, u3), k2.push(h2, u3.__c || y2, u3)), y2 != null) {
        var c2;
        if (m2 == null && (m2 = y2), u3.__d !== void 0)
          c2 = u3.__d, u3.__d = void 0;
        else if (r2 == p2 || y2 != f2 || y2.parentNode == null) {
          n:
            if (f2 == null || f2.parentNode !== n2)
              n2.appendChild(y2), c2 = null;
            else {
              for (d2 = f2, h2 = 0; (d2 = d2.nextSibling) && h2 < _2; h2 += 2)
                if (d2 == y2)
                  break n;
              n2.insertBefore(y2, f2), c2 = f2;
            }
          l2.type == "option" && (n2.value = "");
        }
        f2 = c2 !== void 0 ? c2 : y2.nextSibling, typeof l2.type == "function" && (l2.__d = f2);
      } else
        f2 && p2.__e == f2 && f2.parentNode != n2 && (f2 = w$2(p2));
    }
    return a2++, u3;
  }), l2.__e = m2, r2 != null && typeof l2.type != "function")
    for (a2 = r2.length; a2--; )
      r2[a2] != null && v$2(r2[a2]);
  for (a2 = _2; a2--; )
    g2[a2] != null && D$1(g2[a2], g2[a2]);
  if (k2)
    for (a2 = 0; a2 < k2.length; a2++)
      j$1(k2[a2], k2[++a2], k2[++a2]);
}
function x$2(n2, l2, u2) {
  if (u2 == null && (u2 = []), n2 == null || typeof n2 == "boolean")
    l2 && u2.push(l2(null));
  else if (Array.isArray(n2))
    for (var i2 = 0; i2 < n2.length; i2++)
      x$2(n2[i2], l2, u2);
  else
    u2.push(l2 ? l2(typeof n2 == "string" || typeof n2 == "number" ? p$1(null, n2, null, null, n2) : n2.__e != null || n2.__c != null ? p$1(n2.type, n2.props, n2.key, null, n2.__v) : n2) : n2);
  return u2;
}
function P$2(n2, l2, u2, i2, t2) {
  var r2;
  for (r2 in u2)
    r2 === "children" || r2 === "key" || r2 in l2 || N$1(n2, r2, null, u2[r2], i2);
  for (r2 in l2)
    t2 && typeof l2[r2] != "function" || r2 === "children" || r2 === "key" || r2 === "value" || r2 === "checked" || u2[r2] === l2[r2] || N$1(n2, r2, l2[r2], u2[r2], i2);
}
function C$2(n2, l2, u2) {
  l2[0] === "-" ? n2.setProperty(l2, u2) : n2[l2] = typeof u2 == "number" && s$1.test(l2) === false ? u2 + "px" : u2 == null ? "" : u2;
}
function N$1(n2, l2, u2, i2, t2) {
  var r2, o2, f2, e2, c2;
  if (t2 ? l2 === "className" && (l2 = "class") : l2 === "class" && (l2 = "className"), l2 === "style")
    if (r2 = n2.style, typeof u2 == "string")
      r2.cssText = u2;
    else {
      if (typeof i2 == "string" && (r2.cssText = "", i2 = null), i2)
        for (e2 in i2)
          u2 && e2 in u2 || C$2(r2, e2, "");
      if (u2)
        for (c2 in u2)
          i2 && u2[c2] === i2[c2] || C$2(r2, c2, u2[c2]);
    }
  else
    l2[0] === "o" && l2[1] === "n" ? (o2 = l2 !== (l2 = l2.replace(/Capture$/, "")), f2 = l2.toLowerCase(), l2 = (f2 in n2 ? f2 : l2).slice(2), u2 ? (i2 || n2.addEventListener(l2, z$1, o2), (n2.l || (n2.l = {}))[l2] = u2) : n2.removeEventListener(l2, z$1, o2)) : l2 !== "list" && l2 !== "tagName" && l2 !== "form" && l2 !== "type" && l2 !== "size" && !t2 && l2 in n2 ? n2[l2] = u2 == null ? "" : u2 : typeof u2 != "function" && l2 !== "dangerouslySetInnerHTML" && (l2 !== (l2 = l2.replace(/^xlink:?/, "")) ? u2 == null || u2 === false ? n2.removeAttributeNS("http://www.w3.org/1999/xlink", l2.toLowerCase()) : n2.setAttributeNS("http://www.w3.org/1999/xlink", l2.toLowerCase(), u2) : u2 == null || u2 === false && !/^ar/.test(l2) ? n2.removeAttribute(l2) : n2.setAttribute(l2, u2));
}
function z$1(l2) {
  this.l[l2.type](n.event ? n.event(l2) : l2);
}
function A$2(l2, u2, i2, t2, r2, o2, f2, e2, c2) {
  var s2, v2, h2, p2, y2, w2, k2, g2, _2, x2, P2 = u2.type;
  if (u2.constructor !== void 0)
    return null;
  (s2 = n.__b) && s2(u2);
  try {
    n:
      if (typeof P2 == "function") {
        if (g2 = u2.props, _2 = (s2 = P2.contextType) && t2[s2.__c], x2 = s2 ? _2 ? _2.props.value : s2.__ : t2, i2.__c ? k2 = (v2 = u2.__c = i2.__c).__ = v2.__E : ("prototype" in P2 && P2.prototype.render ? u2.__c = v2 = new P2(g2, x2) : (u2.__c = v2 = new m$1(g2, x2), v2.constructor = P2, v2.render = E$2), _2 && _2.sub(v2), v2.props = g2, v2.state || (v2.state = {}), v2.context = x2, v2.__n = t2, h2 = v2.__d = true, v2.__h = []), v2.__s == null && (v2.__s = v2.state), P2.getDerivedStateFromProps != null && (v2.__s == v2.state && (v2.__s = a$1({}, v2.__s)), a$1(v2.__s, P2.getDerivedStateFromProps(g2, v2.__s))), p2 = v2.props, y2 = v2.state, h2)
          P2.getDerivedStateFromProps == null && v2.componentWillMount != null && v2.componentWillMount(), v2.componentDidMount != null && v2.__h.push(v2.componentDidMount);
        else {
          if (P2.getDerivedStateFromProps == null && g2 !== p2 && v2.componentWillReceiveProps != null && v2.componentWillReceiveProps(g2, x2), !v2.__e && v2.shouldComponentUpdate != null && v2.shouldComponentUpdate(g2, v2.__s, x2) === false || u2.__v === i2.__v && !v2.__) {
            for (v2.props = g2, v2.state = v2.__s, u2.__v !== i2.__v && (v2.__d = false), v2.__v = u2, u2.__e = i2.__e, u2.__k = i2.__k, v2.__h.length && f2.push(v2), s2 = 0; s2 < u2.__k.length; s2++)
              u2.__k[s2] && (u2.__k[s2].__ = u2);
            break n;
          }
          v2.componentWillUpdate != null && v2.componentWillUpdate(g2, v2.__s, x2), v2.componentDidUpdate != null && v2.__h.push(function() {
            v2.componentDidUpdate(p2, y2, w2);
          });
        }
        v2.context = x2, v2.props = g2, v2.state = v2.__s, (s2 = n.__r) && s2(u2), v2.__d = false, v2.__v = u2, v2.__P = l2, s2 = v2.render(v2.props, v2.state, v2.context), u2.__k = s2 != null && s2.type == d$1 && s2.key == null ? s2.props.children : Array.isArray(s2) ? s2 : [s2], v2.getChildContext != null && (t2 = a$1(a$1({}, t2), v2.getChildContext())), h2 || v2.getSnapshotBeforeUpdate == null || (w2 = v2.getSnapshotBeforeUpdate(p2, y2)), b(l2, u2, i2, t2, r2, o2, f2, e2, c2), v2.base = u2.__e, v2.__h.length && f2.push(v2), k2 && (v2.__E = v2.__ = null), v2.__e = false;
      } else
        o2 == null && u2.__v === i2.__v ? (u2.__k = i2.__k, u2.__e = i2.__e) : u2.__e = $$1(i2.__e, u2, i2, t2, r2, o2, f2, c2);
    (s2 = n.diffed) && s2(u2);
  } catch (l3) {
    u2.__v = null, n.__e(l3, u2, i2);
  }
  return u2.__e;
}
function T$3(l2, u2) {
  n.__c && n.__c(u2, l2), l2.some(function(u3) {
    try {
      l2 = u3.__h, u3.__h = [], l2.some(function(n2) {
        n2.call(u3);
      });
    } catch (l3) {
      n.__e(l3, u3.__v);
    }
  });
}
function $$1(n2, l2, u2, i2, t2, r2, o2, f2) {
  var s2, a2, v2, h2, p2, y2 = u2.props, d2 = l2.props;
  if (t2 = l2.type === "svg" || t2, r2 != null) {
    for (s2 = 0; s2 < r2.length; s2++)
      if ((a2 = r2[s2]) != null && ((l2.type === null ? a2.nodeType === 3 : a2.localName === l2.type) || n2 == a2)) {
        n2 = a2, r2[s2] = null;
        break;
      }
  }
  if (n2 == null) {
    if (l2.type === null)
      return document.createTextNode(d2);
    n2 = t2 ? document.createElementNS("http://www.w3.org/2000/svg", l2.type) : document.createElement(l2.type, d2.is && { is: d2.is }), r2 = null, f2 = false;
  }
  if (l2.type === null)
    y2 !== d2 && n2.data != d2 && (n2.data = d2);
  else {
    if (r2 != null && (r2 = c$1.slice.call(n2.childNodes)), v2 = (y2 = u2.props || e$1).dangerouslySetInnerHTML, h2 = d2.dangerouslySetInnerHTML, !f2) {
      if (y2 === e$1)
        for (y2 = {}, p2 = 0; p2 < n2.attributes.length; p2++)
          y2[n2.attributes[p2].name] = n2.attributes[p2].value;
      (h2 || v2) && (h2 && v2 && h2.__html == v2.__html || (n2.innerHTML = h2 && h2.__html || ""));
    }
    P$2(n2, d2, y2, t2, f2), h2 ? l2.__k = [] : (l2.__k = l2.props.children, b(n2, l2, u2, i2, l2.type !== "foreignObject" && t2, r2, o2, e$1, f2)), f2 || ("value" in d2 && (s2 = d2.value) !== void 0 && s2 !== n2.value && N$1(n2, "value", s2, y2.value, false), "checked" in d2 && (s2 = d2.checked) !== void 0 && s2 !== n2.checked && N$1(n2, "checked", s2, y2.checked, false));
  }
  return n2;
}
function j$1(l2, u2, i2) {
  try {
    typeof l2 == "function" ? l2(u2) : l2.current = u2;
  } catch (l3) {
    n.__e(l3, i2);
  }
}
function D$1(l2, u2, i2) {
  var t2, r2, o2;
  if (n.unmount && n.unmount(l2), (t2 = l2.ref) && (t2.current && t2.current !== l2.__e || j$1(t2, null, u2)), i2 || typeof l2.type == "function" || (i2 = (r2 = l2.__e) != null), l2.__e = l2.__d = void 0, (t2 = l2.__c) != null) {
    if (t2.componentWillUnmount)
      try {
        t2.componentWillUnmount();
      } catch (l3) {
        n.__e(l3, u2);
      }
    t2.base = t2.__P = null;
  }
  if (t2 = l2.__k)
    for (o2 = 0; o2 < t2.length; o2++)
      t2[o2] && D$1(t2[o2], u2, i2);
  r2 != null && v$2(r2);
}
function E$2(n2, l2, u2) {
  return this.constructor(n2, u2);
}
function H$1(l2, u2, i2) {
  var t2, r2, f2;
  n.__ && n.__(l2, u2), r2 = (t2 = i2 === o$1) ? null : i2 && i2.__k || u2.__k, l2 = h$2(d$1, null, [l2]), f2 = [], A$2(u2, (t2 ? u2 : i2 || u2).__k = l2, r2 || e$1, e$1, u2.ownerSVGElement !== void 0, i2 && !t2 ? [i2] : r2 ? null : c$1.slice.call(u2.childNodes), f2, i2 || e$1, t2), T$3(f2, l2);
}
function I$2(n2, l2) {
  H$1(n2, l2, o$1);
}
function L$2(n2, l2) {
  var u2, i2;
  for (i2 in l2 = a$1(a$1({}, n2.props), l2), arguments.length > 2 && (l2.children = c$1.slice.call(arguments, 2)), u2 = {}, l2)
    i2 !== "key" && i2 !== "ref" && (u2[i2] = l2[i2]);
  return p$1(n2.type, u2, l2.key || n2.key, l2.ref || n2.ref, null);
}
function M$2(n2) {
  var l2 = {}, u2 = { __c: "__cC" + f$1++, __: n2, Consumer: function(n3, l3) {
    return n3.children(l3);
  }, Provider: function(n3) {
    var i2, t2 = this;
    return this.getChildContext || (i2 = [], this.getChildContext = function() {
      return l2[u2.__c] = t2, l2;
    }, this.shouldComponentUpdate = function(n4) {
      t2.props.value !== n4.value && i2.some(function(l3) {
        l3.context = n4.value, g$1(l3);
      });
    }, this.sub = function(n4) {
      i2.push(n4);
      var l3 = n4.componentWillUnmount;
      n4.componentWillUnmount = function() {
        i2.splice(i2.indexOf(n4), 1), l3 && l3.call(n4);
      };
    }), n3.children;
  } };
  return u2.Consumer.contextType = u2, u2.Provider.__ = u2, u2;
}
n = { __e: function(n2, l2) {
  for (var u2, i2; l2 = l2.__; )
    if ((u2 = l2.__c) && !u2.__)
      try {
        if (u2.constructor && u2.constructor.getDerivedStateFromError != null && (i2 = true, u2.setState(u2.constructor.getDerivedStateFromError(n2))), u2.componentDidCatch != null && (i2 = true, u2.componentDidCatch(n2)), i2)
          return g$1(u2.__E = u2);
      } catch (l3) {
        n2 = l3;
      }
  throw n2;
} }, m$1.prototype.setState = function(n2, l2) {
  var u2;
  u2 = this.__s !== this.state ? this.__s : this.__s = a$1({}, this.state), typeof n2 == "function" && (n2 = n2(u2, this.props)), n2 && a$1(u2, n2), n2 != null && this.__v && (l2 && this.__h.push(l2), g$1(this));
}, m$1.prototype.forceUpdate = function(n2) {
  this.__v && (this.__e = true, n2 && this.__h.push(n2), g$1(this));
}, m$1.prototype.render = d$1, u$1 = [], i$1 = 0, t$1 = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, o$1 = e$1, f$1 = 0;
var t, u, r, i = 0, o = [], c = n.__r, f = n.diffed, e = n.__c, a = n.unmount;
function v$1(t2, r2) {
  n.__h && n.__h(u, t2, i || r2), i = 0;
  var o2 = u.__H || (u.__H = { __: [], __h: [] });
  return t2 >= o2.__.length && o2.__.push({}), o2.__[t2];
}
function m(n2) {
  return i = 1, p(E$1, n2);
}
function p(n2, r2, i2) {
  var o2 = v$1(t++, 2);
  return o2.__c || (o2.__c = u, o2.__ = [i2 ? i2(r2) : E$1(void 0, r2), function(t2) {
    var u2 = n2(o2.__[0], t2);
    o2.__[0] !== u2 && (o2.__[0] = u2, o2.__c.setState({}));
  }]), o2.__;
}
function l(r2, i2) {
  var o2 = v$1(t++, 3);
  !n.__s && x$1(o2.__H, i2) && (o2.__ = r2, o2.__H = i2, u.__H.__h.push(o2));
}
function y(r2, i2) {
  var o2 = v$1(t++, 4);
  !n.__s && x$1(o2.__H, i2) && (o2.__ = r2, o2.__H = i2, u.__h.push(o2));
}
function d(n2) {
  return i = 5, h$1(function() {
    return { current: n2 };
  }, []);
}
function s(n2, t2, u2) {
  i = 6, y(function() {
    typeof n2 == "function" ? n2(t2()) : n2 && (n2.current = t2());
  }, u2 == null ? u2 : u2.concat(n2));
}
function h$1(n2, u2) {
  var r2 = v$1(t++, 7);
  return x$1(r2.__H, u2) ? (r2.__H = u2, r2.__h = n2, r2.__ = n2()) : r2.__;
}
function T$2(n2, t2) {
  return i = 8, h$1(function() {
    return n2;
  }, t2);
}
function w$1(n2) {
  var r2 = u.context[n2.__c], i2 = v$1(t++, 9);
  return i2.__c = n2, r2 ? (i2.__ == null && (i2.__ = true, r2.sub(u)), r2.props.value) : n2.__;
}
function A$1(t2, u2) {
  n.useDebugValue && n.useDebugValue(u2 ? u2(t2) : t2);
}
function F$1(n2) {
  var r2 = v$1(t++, 10), i2 = m();
  return r2.__ = n2, u.componentDidCatch || (u.componentDidCatch = function(n3) {
    r2.__ && r2.__(n3), i2[1](n3);
  }), [i2[0], function() {
    i2[1](void 0);
  }];
}
function _$1() {
  o.some(function(t2) {
    if (t2.__P)
      try {
        t2.__H.__h.forEach(g), t2.__H.__h.forEach(q$1), t2.__H.__h = [];
      } catch (u2) {
        return t2.__H.__h = [], n.__e(u2, t2.__v), true;
      }
  }), o = [];
}
function g(n2) {
  n2.t && n2.t();
}
function q$1(n2) {
  var t2 = n2.__();
  typeof t2 == "function" && (n2.t = t2);
}
function x$1(n2, t2) {
  return !n2 || t2.some(function(t3, u2) {
    return t3 !== n2[u2];
  });
}
function E$1(n2, t2) {
  return typeof t2 == "function" ? t2(n2) : t2;
}
n.__r = function(n2) {
  c && c(n2), t = 0, (u = n2.__c).__H && (u.__H.__h.forEach(g), u.__H.__h.forEach(q$1), u.__H.__h = []);
}, n.diffed = function(t2) {
  f && f(t2);
  var u2 = t2.__c;
  if (u2) {
    var i2 = u2.__H;
    i2 && i2.__h.length && (o.push(u2) !== 1 && r === n.requestAnimationFrame || ((r = n.requestAnimationFrame) || function(n2) {
      var t3, u3 = function() {
        clearTimeout(r2), cancelAnimationFrame(t3), setTimeout(n2);
      }, r2 = setTimeout(u3, 100);
      typeof window != "undefined" && (t3 = requestAnimationFrame(u3));
    })(_$1));
  }
}, n.__c = function(t2, u2) {
  u2.some(function(t3) {
    try {
      t3.__h.forEach(g), t3.__h = t3.__h.filter(function(n2) {
        return !n2.__ || q$1(n2);
      });
    } catch (r2) {
      u2.some(function(n2) {
        n2.__h && (n2.__h = []);
      }), u2 = [], n.__e(r2, t3.__v);
    }
  }), e && e(t2, u2);
}, n.unmount = function(t2) {
  a && a(t2);
  var u2 = t2.__c;
  if (u2) {
    var r2 = u2.__H;
    if (r2)
      try {
        r2.__.forEach(function(n2) {
          return n2.t && n2.t();
        });
      } catch (t3) {
        n.__e(t3, u2.__v);
      }
  }
};
function E(n2, t2) {
  for (var e2 in t2)
    n2[e2] = t2[e2];
  return n2;
}
function w(n2, t2) {
  for (var e2 in n2)
    if (e2 !== "__source" && !(e2 in t2))
      return true;
  for (var r2 in t2)
    if (r2 !== "__source" && n2[r2] !== t2[r2])
      return true;
  return false;
}
var C$1 = function(n2) {
  var t2, e2;
  function r2(t3) {
    var e3;
    return (e3 = n2.call(this, t3) || this).isPureReactComponent = true, e3;
  }
  return e2 = n2, (t2 = r2).prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, t2.__proto__ = e2, r2.prototype.shouldComponentUpdate = function(n3, t3) {
    return w(this.props, n3) || w(this.state, t3);
  }, r2;
}(m$1);
function _(n2, t2) {
  function e2(n3) {
    var e3 = this.props.ref, r3 = e3 == n3.ref;
    return !r3 && e3 && (e3.call ? e3(null) : e3.current = null), t2 ? !t2(this.props, n3) || !r3 : w(this.props, n3);
  }
  function r2(t3) {
    return this.shouldComponentUpdate = e2, h$2(n2, E({}, t3));
  }
  return r2.prototype.isReactComponent = true, r2.displayName = "Memo(" + (n2.displayName || n2.name) + ")", r2.t = true, r2;
}
var A = n.__b;
function S(n2) {
  function t2(t3) {
    var e2 = E({}, t3);
    return delete e2.ref, n2(e2, t3.ref);
  }
  return t2.prototype.isReactComponent = t2.t = true, t2.displayName = "ForwardRef(" + (n2.displayName || n2.name) + ")", t2;
}
n.__b = function(n2) {
  n2.type && n2.type.t && n2.ref && (n2.props.ref = n2.ref, n2.ref = null), A && A(n2);
};
var k = function(n2, t2) {
  return n2 ? x$2(n2).reduce(function(n3, e2, r2) {
    return n3.concat(t2(e2, r2));
  }, []) : null;
}, R$1 = { map: k, forEach: k, count: function(n2) {
  return n2 ? x$2(n2).length : 0;
}, only: function(n2) {
  if ((n2 = x$2(n2)).length !== 1)
    throw new Error("Children.only() expects only one child.");
  return n2[0];
}, toArray: x$2 }, F = n.__e;
function N(n2) {
  return n2 && ((n2 = E({}, n2)).__c = null, n2.__k = n2.__k && n2.__k.map(N)), n2;
}
function U() {
  this.__u = 0, this.o = null, this.__b = null;
}
function M$1(n2) {
  var t2 = n2.__.__c;
  return t2 && t2.u && t2.u(n2);
}
function L$1(n2) {
  var t2, e2, r2;
  function o2(o3) {
    if (t2 || (t2 = n2()).then(function(n3) {
      e2 = n3.default || n3;
    }, function(n3) {
      r2 = n3;
    }), r2)
      throw r2;
    if (!e2)
      throw t2;
    return h$2(e2, o3);
  }
  return o2.displayName = "Lazy", o2.t = true, o2;
}
function O$1() {
  this.i = null, this.l = null;
}
n.__e = function(n2, t2, e2) {
  if (n2.then) {
    for (var r2, o2 = t2; o2 = o2.__; )
      if ((r2 = o2.__c) && r2.__c)
        return r2.__c(n2, t2.__c);
  }
  F(n2, t2, e2);
}, (U.prototype = new m$1()).__c = function(n2, t2) {
  var e2 = this;
  e2.o == null && (e2.o = []), e2.o.push(t2);
  var r2 = M$1(e2.__v), o2 = false, u2 = function() {
    o2 || (o2 = true, r2 ? r2(i2) : i2());
  };
  t2.__c = t2.componentWillUnmount, t2.componentWillUnmount = function() {
    u2(), t2.__c && t2.__c();
  };
  var i2 = function() {
    var n3;
    if (!--e2.__u)
      for (e2.__v.__k[0] = e2.state.u, e2.setState({ u: e2.__b = null }); n3 = e2.o.pop(); )
        n3.forceUpdate();
  };
  e2.__u++ || e2.setState({ u: e2.__b = e2.__v.__k[0] }), n2.then(u2, u2);
}, U.prototype.render = function(n2, t2) {
  return this.__b && (this.__v.__k[0] = N(this.__b), this.__b = null), [h$2(m$1, null, t2.u ? null : n2.children), t2.u && n2.fallback];
};
var P$1 = function(n2, t2, e2) {
  if (++e2[1] === e2[0] && n2.l.delete(t2), n2.props.revealOrder && (n2.props.revealOrder[0] !== "t" || !n2.l.size))
    for (e2 = n2.i; e2; ) {
      for (; e2.length > 3; )
        e2.pop()();
      if (e2[1] < e2[0])
        break;
      n2.i = e2 = e2[2];
    }
};
(O$1.prototype = new m$1()).u = function(n2) {
  var t2 = this, e2 = M$1(t2.__v), r2 = t2.l.get(n2);
  return r2[0]++, function(o2) {
    var u2 = function() {
      t2.props.revealOrder ? (r2.push(o2), P$1(t2, n2, r2)) : o2();
    };
    e2 ? e2(u2) : u2();
  };
}, O$1.prototype.render = function(n2) {
  this.i = null, this.l = /* @__PURE__ */ new Map();
  var t2 = x$2(n2.children);
  n2.revealOrder && n2.revealOrder[0] === "b" && t2.reverse();
  for (var e2 = t2.length; e2--; )
    this.l.set(t2[e2], this.i = [1, 0, this.i]);
  return n2.children;
}, O$1.prototype.componentDidUpdate = O$1.prototype.componentDidMount = function() {
  var n2 = this;
  n2.l.forEach(function(t2, e2) {
    P$1(n2, e2, t2);
  });
};
var W = function() {
  function n2() {
  }
  var t2 = n2.prototype;
  return t2.getChildContext = function() {
    return this.props.context;
  }, t2.render = function(n3) {
    return n3.children;
  }, n2;
}();
function j(n2) {
  var t2 = this, e2 = n2.container, r2 = h$2(W, { context: t2.context }, n2.vnode);
  return t2.s && t2.s !== e2 && (t2.v.parentNode && t2.s.removeChild(t2.v), D$1(t2.h), t2.p = false), n2.vnode ? t2.p ? (e2.__k = t2.__k, H$1(r2, e2), t2.__k = e2.__k) : (t2.v = document.createTextNode(""), I$2("", e2), e2.appendChild(t2.v), t2.p = true, t2.s = e2, H$1(r2, e2, t2.v), t2.__k = t2.v.__k) : t2.p && (t2.v.parentNode && t2.s.removeChild(t2.v), D$1(t2.h)), t2.h = r2, t2.componentWillUnmount = function() {
    t2.v.parentNode && t2.s.removeChild(t2.v), D$1(t2.h);
  }, null;
}
function z(n2, t2) {
  return h$2(j, { vnode: n2, container: t2 });
}
var D = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
m$1.prototype.isReactComponent = {};
var H = typeof Symbol != "undefined" && Symbol.for && Symbol.for("react.element") || 60103;
function T$1(n2, t2, e2) {
  if (t2.__k == null)
    for (; t2.firstChild; )
      t2.removeChild(t2.firstChild);
  return H$1(n2, t2), typeof e2 == "function" && e2(), n2 ? n2.__c : null;
}
function V(n2, t2, e2) {
  return I$2(n2, t2), typeof e2 == "function" && e2(), n2 ? n2.__c : null;
}
var Z = n.event;
function I$1(n2, t2) {
  n2["UNSAFE_" + t2] && !n2[t2] && Object.defineProperty(n2, t2, { configurable: false, get: function() {
    return this["UNSAFE_" + t2];
  }, set: function(n3) {
    this["UNSAFE_" + t2] = n3;
  } });
}
n.event = function(n2) {
  Z && (n2 = Z(n2)), n2.persist = function() {
  };
  var t2 = false, e2 = false, r2 = n2.stopPropagation;
  n2.stopPropagation = function() {
    r2.call(n2), t2 = true;
  };
  var o2 = n2.preventDefault;
  return n2.preventDefault = function() {
    o2.call(n2), e2 = true;
  }, n2.isPropagationStopped = function() {
    return t2;
  }, n2.isDefaultPrevented = function() {
    return e2;
  }, n2.nativeEvent = n2;
};
var $ = { configurable: true, get: function() {
  return this.class;
} }, q = n.vnode;
n.vnode = function(n2) {
  n2.$$typeof = H;
  var t2 = n2.type, e2 = n2.props;
  if (t2) {
    if (e2.class != e2.className && ($.enumerable = "className" in e2, e2.className != null && (e2.class = e2.className), Object.defineProperty(e2, "className", $)), typeof t2 != "function") {
      var r2, o2, u2;
      for (u2 in e2.defaultValue && e2.value !== void 0 && (e2.value || e2.value === 0 || (e2.value = e2.defaultValue), delete e2.defaultValue), Array.isArray(e2.value) && e2.multiple && t2 === "select" && (x$2(e2.children).forEach(function(n3) {
        e2.value.indexOf(n3.props.value) != -1 && (n3.props.selected = true);
      }), delete e2.value), e2)
        if (r2 = D.test(u2))
          break;
      if (r2)
        for (u2 in o2 = n2.props = {}, e2)
          o2[D.test(u2) ? u2.replace(/[A-Z0-9]/, "-$&").toLowerCase() : u2] = e2[u2];
    }
    !function(t3) {
      var e3 = n2.type, r3 = n2.props;
      if (r3 && typeof e3 == "string") {
        var o3 = {};
        for (var u3 in r3)
          /^on(Ani|Tra|Tou)/.test(u3) && (r3[u3.toLowerCase()] = r3[u3], delete r3[u3]), o3[u3.toLowerCase()] = u3;
        if (o3.ondoubleclick && (r3.ondblclick = r3[o3.ondoubleclick], delete r3[o3.ondoubleclick]), o3.onbeforeinput && (r3.onbeforeinput = r3[o3.onbeforeinput], delete r3[o3.onbeforeinput]), o3.onchange && (e3 === "textarea" || e3.toLowerCase() === "input" && !/^fil|che|ra/i.test(r3.type))) {
          var i2 = o3.oninput || "oninput";
          r3[i2] || (r3[i2] = r3[o3.onchange], delete r3[o3.onchange]);
        }
      }
    }(), typeof t2 == "function" && !t2.m && t2.prototype && (I$1(t2.prototype, "componentWillMount"), I$1(t2.prototype, "componentWillReceiveProps"), I$1(t2.prototype, "componentWillUpdate"), t2.m = true);
  }
  q && q(n2);
};
var B = "16.8.0";
function G$1(n2) {
  return h$2.bind(null, n2);
}
function J$1(n2) {
  return !!n2 && n2.$$typeof === H;
}
function K$1(n2) {
  return J$1(n2) ? L$2.apply(null, arguments) : n2;
}
function Q$1(n2) {
  return !!n2.__k && (H$1(null, n2), true);
}
function X(n2) {
  return n2 && (n2.base || n2.nodeType === 1 && n2) || null;
}
var Y$1 = function(n2, t2) {
  return n2(t2);
};
var compat_module = { useState: m, useReducer: p, useEffect: l, useLayoutEffect: y, useRef: d, useImperativeHandle: s, useMemo: h$1, useCallback: T$2, useContext: w$1, useDebugValue: A$1, version: "16.8.0", Children: R$1, render: T$1, hydrate: T$1, unmountComponentAtNode: Q$1, createPortal: z, createElement: h$2, createContext: M$2, createFactory: G$1, cloneElement: K$1, createRef: y$1, Fragment: d$1, isValidElement: J$1, findDOMNode: X, Component: m$1, PureComponent: C$1, memo: _, forwardRef: S, unstable_batchedUpdates: Y$1, Suspense: U, SuspenseList: O$1, lazy: L$1 };
var compat_module$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": compat_module,
  version: B,
  Children: R$1,
  render: T$1,
  hydrate: V,
  unmountComponentAtNode: Q$1,
  createPortal: z,
  createFactory: G$1,
  cloneElement: K$1,
  isValidElement: J$1,
  findDOMNode: X,
  PureComponent: C$1,
  memo: _,
  forwardRef: S,
  unstable_batchedUpdates: Y$1,
  Suspense: U,
  SuspenseList: O$1,
  lazy: L$1,
  createElement: h$2,
  createContext: M$2,
  createRef: y$1,
  Fragment: d$1,
  Component: m$1,
  useState: m,
  useReducer: p,
  useEffect: l,
  useLayoutEffect: y,
  useRef: d,
  useImperativeHandle: s,
  useMemo: h$1,
  useCallback: T$2,
  useContext: w$1,
  useDebugValue: A$1,
  useErrorBoundary: F$1
}, Symbol.toStringTag, { value: "Module" }));
var require$$3 = /* @__PURE__ */ getAugmentedNamespace(compat_module$1);
function _interopDefault(ex) {
  return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
}
var browserUtils = require$$0;
var QRCode = _interopDefault(browser);
var copy3 = _interopDefault(copyToClipboard);
var React = require$$3;
function open(uri) {
  QRCode.toString(uri, {
    type: "terminal"
  }).then(console.log);
}
var WALLETCONNECT_STYLE_SHEET = ':root {\n  --animation-duration: 300ms;\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n@keyframes fadeOut {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.animated {\n  animation-duration: var(--animation-duration);\n  animation-fill-mode: both;\n}\n\n.fadeIn {\n  animation-name: fadeIn;\n}\n\n.fadeOut {\n  animation-name: fadeOut;\n}\n\n#walletconnect-wrapper {\n  -webkit-user-select: none;\n  align-items: center;\n  display: flex;\n  height: 100%;\n  justify-content: center;\n  left: 0;\n  pointer-events: none;\n  position: fixed;\n  top: 0;\n  user-select: none;\n  width: 100%;\n  z-index: 99999999999999;\n}\n\n.walletconnect-modal__headerLogo {\n  height: 21px;\n}\n\n.walletconnect-modal__header p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n  align-items: flex-start;\n  display: flex;\n  flex: 1;\n  margin-left: 5px;\n}\n\n.walletconnect-modal__close__wrapper {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  z-index: 10000;\n  background: white;\n  border-radius: 26px;\n  padding: 6px;\n  box-sizing: border-box;\n  width: 26px;\n  height: 26px;\n  cursor: pointer;\n}\n\n.walletconnect-modal__close__icon {\n  position: relative;\n  top: 7px;\n  right: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transform: rotate(45deg);\n}\n\n.walletconnect-modal__close__line1 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n}\n\n.walletconnect-modal__close__line2 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n  transform: rotate(90deg);\n}\n\n.walletconnect-qrcode__base {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  background: rgba(37, 41, 46, 0.95);\n  height: 100%;\n  left: 0;\n  pointer-events: auto;\n  position: fixed;\n  top: 0;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  width: 100%;\n  will-change: opacity;\n  padding: 40px;\n  box-sizing: border-box;\n}\n\n.walletconnect-qrcode__text {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 10px 0 20px 0;\n  text-align: center;\n  width: 100%;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-qrcode__text {\n    font-size: 4vw;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-qrcode__text {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-qrcode__image {\n  width: calc(100% - 30px);\n  box-sizing: border-box;\n  cursor: none;\n  margin: 0 auto;\n}\n\n.walletconnect-qrcode__notification {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  font-size: 16px;\n  padding: 16px 20px;\n  border-radius: 16px;\n  text-align: center;\n  transition: all 0.1s ease-in-out;\n  background: white;\n  color: black;\n  margin-bottom: -60px;\n  opacity: 0;\n}\n\n.walletconnect-qrcode__notification.notification__show {\n  opacity: 1;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__header {\n    height: 130px;\n  }\n  .walletconnect-modal__base {\n    overflow: auto;\n  }\n}\n\n@media only screen and (min-device-width: 415px) and (max-width: 768px) {\n  #content {\n    max-width: 768px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 375px) and (max-width: 415px) {\n  #content {\n    max-width: 414px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 320px) and (max-width: 375px) {\n  #content {\n    max-width: 375px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  #content {\n    max-width: 320px;\n    box-sizing: border-box;\n  }\n}\n\n.walletconnect-modal__base {\n  -webkit-font-smoothing: antialiased;\n  background: #ffffff;\n  border-radius: 24px;\n  box-shadow: 0 10px 50px 5px rgba(0, 0, 0, 0.4);\n  font-family: ui-rounded, "SF Pro Rounded", "SF Pro Text", medium-content-sans-serif-font,\n    -apple-system, BlinkMacSystemFont, ui-sans-serif, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell,\n    "Open Sans", "Helvetica Neue", sans-serif;\n  margin-top: 41px;\n  padding: 24px 24px 22px;\n  pointer-events: auto;\n  position: relative;\n  text-align: center;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  will-change: transform;\n  overflow: visible;\n  transform: translateY(-50%);\n  top: 50%;\n  max-width: 500px;\n  margin: auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__base {\n    padding: 24px 12px;\n  }\n}\n\n.walletconnect-modal__base .hidden {\n  transform: translateY(150%);\n  transition: 0.125s cubic-bezier(0.4, 0, 1, 1);\n}\n\n.walletconnect-modal__header {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  left: 0;\n  justify-content: space-between;\n  position: absolute;\n  top: -42px;\n  width: 100%;\n}\n\n.walletconnect-modal__base .wc-logo {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  margin-top: 15px;\n  padding-bottom: 15px;\n  pointer-events: auto;\n}\n\n.walletconnect-modal__base .wc-logo div {\n  background-color: #3399ff;\n  height: 21px;\n  margin-right: 5px;\n  mask-image: url("images/wc-logo.svg") center no-repeat;\n  width: 32px;\n}\n\n.walletconnect-modal__base .wc-logo p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n}\n\n.walletconnect-modal__base h2 {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 0 0 19px 0;\n  text-align: center;\n  width: 100%;\n}\n\n.walletconnect-modal__base__row {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  align-items: center;\n  border-radius: 20px;\n  cursor: pointer;\n  display: flex;\n  height: 56px;\n  justify-content: space-between;\n  padding: 0 15px;\n  position: relative;\n  margin: 0px 0px 8px;\n  text-align: left;\n  transition: 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  will-change: transform;\n  text-decoration: none;\n}\n\n.walletconnect-modal__base__row:hover {\n  background: rgba(60, 66, 82, 0.06);\n}\n\n.walletconnect-modal__base__row:active {\n  background: rgba(60, 66, 82, 0.06);\n  transform: scale(0.975);\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n}\n\n.walletconnect-modal__base__row__h3 {\n  color: #25292e;\n  font-size: 20px;\n  font-weight: 700;\n  margin: 0;\n  padding-bottom: 3px;\n}\n\n.walletconnect-modal__base__row__right {\n  align-items: center;\n  display: flex;\n  justify-content: center;\n}\n\n.walletconnect-modal__base__row__right__app-icon {\n  border-radius: 8px;\n  height: 34px;\n  margin: 0 11px 2px 0;\n  width: 34px;\n  background-size: 100%;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-modal__base__row__right__caret {\n  height: 18px;\n  opacity: 0.3;\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  width: 8px;\n  will-change: opacity;\n}\n\n.walletconnect-modal__base__row:hover .caret,\n.walletconnect-modal__base__row:active .caret {\n  opacity: 0.6;\n}\n\n.walletconnect-modal__mobile__toggle {\n  width: 80%;\n  display: flex;\n  margin: 0 auto;\n  position: relative;\n  overflow: hidden;\n  border-radius: 8px;\n  margin-bottom: 18px;\n  background: #d4d5d9;\n}\n\n.walletconnect-modal__single_wallet {\n  display: flex;\n  justify-content: center;\n  margin-top: 7px;\n  margin-bottom: 18px;\n}\n\n.walletconnect-modal__single_wallet a {\n  cursor: pointer;\n  color: rgb(64, 153, 255);\n  font-size: 21px;\n  font-weight: 800;\n  text-decoration: none !important;\n  margin: 0 auto;\n}\n\n.walletconnect-modal__mobile__toggle_selector {\n  width: calc(50% - 8px);\n  background: white;\n  position: absolute;\n  border-radius: 5px;\n  height: calc(100% - 8px);\n  top: 4px;\n  transition: all 0.2s ease-in-out;\n  transform: translate3d(4px, 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle.right__selected .walletconnect-modal__mobile__toggle_selector {\n  transform: translate3d(calc(100% + 12px), 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle a {\n  font-size: 12px;\n  width: 50%;\n  text-align: center;\n  padding: 8px;\n  margin: 0;\n  font-weight: 600;\n  z-index: 1;\n}\n\n.walletconnect-modal__footer {\n  display: flex;\n  justify-content: center;\n  margin-top: 20px;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__footer {\n    margin-top: 5vw;\n  }\n}\n\n.walletconnect-modal__footer a {\n  cursor: pointer;\n  color: #898d97;\n  font-size: 15px;\n  margin: 0 auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__footer a {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-connect__buttons__wrapper {\n  max-height: 44vh;\n}\n\n.walletconnect-connect__buttons__wrapper__android {\n  margin: 50% 0;\n}\n\n.walletconnect-connect__buttons__wrapper__wrap {\n  display: grid;\n  grid-template-columns: repeat(4, 1fr);\n  margin: 10px 0;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__buttons__wrapper__wrap {\n    margin-top: 40px;\n  }\n}\n\n.walletconnect-connect__button {\n  background-color: rgb(64, 153, 255);\n  padding: 12px;\n  border-radius: 8px;\n  text-decoration: none;\n  color: rgb(255, 255, 255);\n  font-weight: 500;\n}\n\n.walletconnect-connect__button__icon_anchor {\n  cursor: pointer;\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n  margin: 8px;\n  width: 42px;\n  justify-self: center;\n  flex-direction: column;\n  text-decoration: none !important;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-connect__button__icon_anchor {\n    margin: 4px;\n  }\n}\n\n.walletconnect-connect__button__icon {\n  border-radius: 10px;\n  height: 42px;\n  margin: 0;\n  width: 42px;\n  background-size: cover !important;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-connect__button__text {\n  color: #424952;\n  font-size: 2.7vw;\n  text-decoration: none !important;\n  padding: 0;\n  margin-top: 1.8vw;\n  font-weight: 600;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__button__text {\n    font-size: 16px;\n    margin-top: 12px;\n  }\n}\n\n.walletconnect-search__input {\n  border: none;\n  background: #d4d5d9;\n  border-style: none;\n  padding: 8px 16px;\n  outline: none;\n  font-style: normal;\n  font-stretch: normal;\n  font-size: 16px;\n  font-style: normal;\n  font-stretch: normal;\n  line-height: normal;\n  letter-spacing: normal;\n  text-align: left;\n  border-radius: 8px;\n  width: calc(100% - 16px);\n  margin: 0;\n  margin-bottom: 8px;\n}\n';
typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator";
function _catch(body, recover) {
  try {
    var result = body();
  } catch (e2) {
    return recover(e2);
  }
  if (result && result.then) {
    return result.then(void 0, recover);
  }
  return result;
}
var WALLETCONNECT_LOGO_SVG_URL = "data:image/svg+xml,%3Csvg height='185' viewBox='0 0 300 185' width='300' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='m61.4385429 36.2562612c48.9112241-47.8881663 128.2119871-47.8881663 177.1232091 0l5.886545 5.7634174c2.445561 2.3944081 2.445561 6.2765112 0 8.6709204l-20.136695 19.715503c-1.222781 1.1972051-3.2053 1.1972051-4.428081 0l-8.100584-7.9311479c-34.121692-33.4079817-89.443886-33.4079817-123.5655788 0l-8.6750562 8.4936051c-1.2227816 1.1972041-3.205301 1.1972041-4.4280806 0l-20.1366949-19.7155031c-2.4455612-2.3944092-2.4455612-6.2765122 0-8.6709204zm218.7677961 40.7737449 17.921697 17.546897c2.445549 2.3943969 2.445563 6.2764769.000031 8.6708899l-80.810171 79.121134c-2.445544 2.394426-6.410582 2.394453-8.85616.000062-.00001-.00001-.000022-.000022-.000032-.000032l-57.354143-56.154572c-.61139-.598602-1.60265-.598602-2.21404 0-.000004.000004-.000007.000008-.000011.000011l-57.3529212 56.154531c-2.4455368 2.394432-6.4105755 2.394472-8.8561612.000087-.0000143-.000014-.0000296-.000028-.0000449-.000044l-80.81241943-79.122185c-2.44556021-2.394408-2.44556021-6.2765115 0-8.6709197l17.92172963-17.5468673c2.4455602-2.3944082 6.4105989-2.3944082 8.8561602 0l57.3549775 56.155357c.6113908.598602 1.602649.598602 2.2140398 0 .0000092-.000009.0000174-.000017.0000265-.000024l57.3521031-56.155333c2.445505-2.3944633 6.410544-2.3945531 8.856161-.0002.000034.0000336.000068.0000673.000101.000101l57.354902 56.155432c.61139.598601 1.60265.598601 2.21404 0l57.353975-56.1543249c2.445561-2.3944092 6.410599-2.3944092 8.85616 0z' fill='%233b99fc'/%3E%3C/svg%3E";
var WALLETCONNECT_HEADER_TEXT = "WalletConnect";
var ANIMATION_DURATION = 300;
var DEFAULT_BUTTON_COLOR = "rgb(64, 153, 255)";
var WALLETCONNECT_WRAPPER_ID = "walletconnect-wrapper";
var WALLETCONNECT_STYLE_ID = "walletconnect-style-sheet";
var WALLETCONNECT_MODAL_ID = "walletconnect-qrcode-modal";
var WALLETCONNECT_CLOSE_BUTTON_ID = "walletconnect-qrcode-close";
var WALLETCONNECT_CTA_TEXT_ID = "walletconnect-qrcode-text";
var WALLETCONNECT_CONNECT_BUTTON_ID = "walletconnect-connect-button";
function Header(props) {
  return React.createElement("div", {
    className: "walletconnect-modal__header"
  }, React.createElement("img", {
    src: WALLETCONNECT_LOGO_SVG_URL,
    className: "walletconnect-modal__headerLogo"
  }), React.createElement("p", null, WALLETCONNECT_HEADER_TEXT), React.createElement("div", {
    className: "walletconnect-modal__close__wrapper",
    onClick: props.onClose
  }, React.createElement("div", {
    id: WALLETCONNECT_CLOSE_BUTTON_ID,
    className: "walletconnect-modal__close__icon"
  }, React.createElement("div", {
    className: "walletconnect-modal__close__line1"
  }), React.createElement("div", {
    className: "walletconnect-modal__close__line2"
  }))));
}
function ConnectButton(props) {
  return React.createElement("a", {
    className: "walletconnect-connect__button",
    href: props.href,
    id: WALLETCONNECT_CONNECT_BUTTON_ID + "-" + props.name,
    onClick: props.onClick,
    rel: "noopener noreferrer",
    style: {
      backgroundColor: props.color
    },
    target: "_blank"
  }, props.name);
}
var CARET_SVG_URL = "data:image/svg+xml,%3Csvg fill='none' height='18' viewBox='0 0 8 18' width='8' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath clip-rule='evenodd' d='m.586301.213898c-.435947.33907-.5144813.967342-.175411 1.403292l4.87831 6.27212c.28087.36111.28087.86677 0 1.22788l-4.878311 6.27211c-.33907.436-.260536 1.0642.175412 1.4033.435949.3391 1.064219.2605 1.403289-.1754l4.87832-6.2721c.84259-1.08336.84259-2.60034 0-3.68367l-4.87832-6.27212c-.33907-.4359474-.96734-.514482-1.403289-.175412z' fill='%233c4252' fill-rule='evenodd'/%3E%3C/svg%3E";
function WalletButton(props) {
  var color = props.color;
  var href = props.href;
  var name = props.name;
  var logo = props.logo;
  var onClick = props.onClick;
  return React.createElement("a", {
    className: "walletconnect-modal__base__row",
    href,
    onClick,
    rel: "noopener noreferrer",
    target: "_blank"
  }, React.createElement("h3", {
    className: "walletconnect-modal__base__row__h3"
  }, name), React.createElement("div", {
    className: "walletconnect-modal__base__row__right"
  }, React.createElement("div", {
    className: "walletconnect-modal__base__row__right__app-icon",
    style: {
      background: "url('" + logo + "') " + color,
      backgroundSize: "100%"
    }
  }), React.createElement("img", {
    src: CARET_SVG_URL,
    className: "walletconnect-modal__base__row__right__caret"
  })));
}
function WalletIcon(props) {
  var color = props.color;
  var href = props.href;
  var name = props.name;
  var logo = props.logo;
  var onClick = props.onClick;
  var fontSize = window.innerWidth < 768 ? (name.length > 8 ? 2.5 : 2.7) + "vw" : "inherit";
  return React.createElement("a", {
    className: "walletconnect-connect__button__icon_anchor",
    href,
    onClick,
    rel: "noopener noreferrer",
    target: "_blank"
  }, React.createElement("div", {
    className: "walletconnect-connect__button__icon",
    style: {
      background: "url('" + logo + "') " + color,
      backgroundSize: "100%"
    }
  }), React.createElement("div", {
    style: {
      fontSize
    },
    className: "walletconnect-connect__button__text"
  }, name));
}
var GRID_MIN_COUNT = 5;
var LINKS_PER_PAGE = 12;
function LinkDisplay(props) {
  var android = browserUtils.isAndroid();
  var ref2 = React.useState("");
  var input = ref2[0];
  var setInput = ref2[1];
  var ref$1 = React.useState("");
  var filter = ref$1[0];
  var setFilter = ref$1[1];
  var ref$2 = React.useState(1);
  var page = ref$2[0];
  var setPage = ref$2[1];
  var links = filter ? props.links.filter(function(link) {
    return link.name.toLowerCase().includes(filter.toLowerCase());
  }) : props.links;
  var errorMessage = props.errorMessage;
  var grid = filter || links.length > GRID_MIN_COUNT;
  var pages = Math.ceil(links.length / LINKS_PER_PAGE);
  var range = [(page - 1) * LINKS_PER_PAGE + 1, page * LINKS_PER_PAGE];
  var pageLinks = links.length ? links.filter(function(_2, index2) {
    return index2 + 1 >= range[0] && index2 + 1 <= range[1];
  }) : [];
  var hasPaging = !!(!android && pages > 1);
  var filterTimeout = void 0;
  function handleInput(e2) {
    setInput(e2.target.value);
    clearTimeout(filterTimeout);
    if (e2.target.value) {
      filterTimeout = setTimeout(function() {
        setFilter(e2.target.value);
        setPage(1);
      }, 1e3);
    } else {
      setInput("");
      setFilter("");
      setPage(1);
    }
  }
  return React.createElement("div", null, React.createElement("p", {
    id: WALLETCONNECT_CTA_TEXT_ID,
    className: "walletconnect-qrcode__text"
  }, android ? props.text.connect_mobile_wallet : props.text.choose_preferred_wallet), !android && React.createElement("input", {
    className: "walletconnect-search__input",
    placeholder: "Search",
    value: input,
    onChange: handleInput
  }), React.createElement("div", {
    className: "walletconnect-connect__buttons__wrapper" + (android ? "__android" : grid && links.length ? "__wrap" : "")
  }, !android ? pageLinks.length ? pageLinks.map(function(entry) {
    var color = entry.color;
    var name = entry.name;
    var shortName = entry.shortName;
    var logo = entry.logo;
    var href = browserUtils.formatIOSMobile(props.uri, entry);
    var handleClickIOS = React.useCallback(function() {
      browserUtils.saveMobileLinkInfo({
        name,
        href
      });
    }, [pageLinks]);
    return !grid ? React.createElement(WalletButton, {
      color,
      href,
      name,
      logo,
      onClick: handleClickIOS
    }) : React.createElement(WalletIcon, {
      color,
      href,
      name: shortName || name,
      logo,
      onClick: handleClickIOS
    });
  }) : React.createElement(React.Fragment, null, React.createElement("p", null, errorMessage.length ? props.errorMessage : !!props.links.length && !links.length ? props.text.no_wallets_found : props.text.loading)) : React.createElement(ConnectButton, {
    name: props.text.connect,
    color: DEFAULT_BUTTON_COLOR,
    href: props.uri,
    onClick: React.useCallback(function() {
      browserUtils.saveMobileLinkInfo({
        name: "Unknown",
        href: props.uri
      });
    }, [])
  })), hasPaging && React.createElement("div", {
    className: "walletconnect-modal__footer"
  }, Array(pages).fill(0).map(function(_2, index2) {
    var pageNumber = index2 + 1;
    var selected = page === pageNumber;
    return React.createElement("a", {
      style: {
        margin: "auto 10px",
        fontWeight: selected ? "bold" : "normal"
      },
      onClick: function() {
        return setPage(pageNumber);
      }
    }, pageNumber);
  })));
}
function Notification(props) {
  var show = !!props.message.trim();
  return React.createElement("div", {
    className: "walletconnect-qrcode__notification" + (show ? " notification__show" : "")
  }, props.message);
}
var formatQRCodeImage = function(data2) {
  try {
    var result = "";
    return Promise.resolve(QRCode.toString(data2, {
      margin: 0,
      type: "svg"
    })).then(function(dataString) {
      if (typeof dataString === "string") {
        result = dataString.replace("<svg", '<svg class="walletconnect-qrcode__image"');
      }
      return result;
    });
  } catch (e2) {
    return Promise.reject(e2);
  }
};
function QRCodeDisplay(props) {
  var ref2 = React.useState("");
  var notification = ref2[0];
  var setNotification = ref2[1];
  var ref$1 = React.useState("");
  var svg = ref$1[0];
  var setSvg = ref$1[1];
  React.useEffect(function() {
    try {
      return Promise.resolve(formatQRCodeImage(props.uri)).then(function(_formatQRCodeImage) {
        setSvg(_formatQRCodeImage);
      });
    } catch (e2) {
      Promise.reject(e2);
    }
  }, []);
  var copyToClipboard2 = function() {
    var success = copy3(props.uri);
    if (success) {
      setNotification(props.text.copied_to_clipboard);
      setInterval(function() {
        return setNotification("");
      }, 1200);
    } else {
      setNotification("Error");
      setInterval(function() {
        return setNotification("");
      }, 1200);
    }
  };
  return React.createElement("div", null, React.createElement("p", {
    id: WALLETCONNECT_CTA_TEXT_ID,
    className: "walletconnect-qrcode__text"
  }, props.text.scan_qrcode_with_wallet), React.createElement("div", {
    dangerouslySetInnerHTML: {
      __html: svg
    }
  }), React.createElement("div", {
    className: "walletconnect-modal__footer"
  }, React.createElement("a", {
    onClick: copyToClipboard2
  }, props.text.copy_to_clipboard)), React.createElement(Notification, {
    message: notification
  }));
}
function Modal$1(props) {
  var android = browserUtils.isAndroid();
  var mobile = browserUtils.isMobile();
  var whitelist = mobile ? props.qrcodeModalOptions && props.qrcodeModalOptions.mobileLinks ? props.qrcodeModalOptions.mobileLinks : void 0 : props.qrcodeModalOptions && props.qrcodeModalOptions.desktopLinks ? props.qrcodeModalOptions.desktopLinks : void 0;
  var ref2 = React.useState(false);
  var loading = ref2[0];
  var setLoading = ref2[1];
  var ref$1 = React.useState(false);
  var fetched = ref$1[0];
  var setFetched = ref$1[1];
  var ref$2 = React.useState(!mobile);
  var displayQRCode = ref$2[0];
  var setDisplayQRCode = ref$2[1];
  var displayProps = {
    mobile,
    text: props.text,
    uri: props.uri,
    qrcodeModalOptions: props.qrcodeModalOptions
  };
  var ref$3 = React.useState("");
  var singleLinkHref = ref$3[0];
  var setSingleLinkHref = ref$3[1];
  var ref$4 = React.useState(false);
  var hasSingleLink = ref$4[0];
  var setHasSingleLink = ref$4[1];
  var ref$5 = React.useState([]);
  var links = ref$5[0];
  var setLinks = ref$5[1];
  var ref$6 = React.useState("");
  var errorMessage = ref$6[0];
  var setErrorMessage = ref$6[1];
  var getLinksIfNeeded = function() {
    if (fetched || loading || whitelist && !whitelist.length || links.length > 0) {
      return;
    }
    React.useEffect(function() {
      var initLinks = function() {
        try {
          if (android) {
            return Promise.resolve();
          }
          setLoading(true);
          var _temp = _catch(function() {
            var url = props.qrcodeModalOptions && props.qrcodeModalOptions.registryUrl ? props.qrcodeModalOptions.registryUrl : browserUtils.getWalletRegistryUrl();
            return Promise.resolve(fetch(url)).then(function(registryResponse) {
              return Promise.resolve(registryResponse.json()).then(function(_registryResponse$jso) {
                var registry = _registryResponse$jso.listings;
                var platform2 = mobile ? "mobile" : "desktop";
                var _links = browserUtils.getMobileLinkRegistry(browserUtils.formatMobileRegistry(registry, platform2), whitelist);
                setLoading(false);
                setFetched(true);
                setErrorMessage(!_links.length ? props.text.no_supported_wallets : "");
                setLinks(_links);
                var hasSingleLink2 = _links.length === 1;
                if (hasSingleLink2) {
                  setSingleLinkHref(browserUtils.formatIOSMobile(props.uri, _links[0]));
                  setDisplayQRCode(true);
                }
                setHasSingleLink(hasSingleLink2);
              });
            });
          }, function(e2) {
            setLoading(false);
            setFetched(true);
            setErrorMessage(props.text.something_went_wrong);
            console.error(e2);
          });
          return Promise.resolve(_temp && _temp.then ? _temp.then(function() {
          }) : void 0);
        } catch (e2) {
          return Promise.reject(e2);
        }
      };
      initLinks();
    });
  };
  getLinksIfNeeded();
  var rightSelected = mobile ? displayQRCode : !displayQRCode;
  return React.createElement("div", {
    id: WALLETCONNECT_MODAL_ID,
    className: "walletconnect-qrcode__base animated fadeIn"
  }, React.createElement("div", {
    className: "walletconnect-modal__base"
  }, React.createElement(Header, {
    onClose: props.onClose
  }), hasSingleLink && displayQRCode ? React.createElement("div", {
    className: "walletconnect-modal__single_wallet"
  }, React.createElement("a", {
    onClick: function() {
      return browserUtils.saveMobileLinkInfo({
        name: links[0].name,
        href: singleLinkHref
      });
    },
    href: singleLinkHref,
    rel: "noopener noreferrer",
    target: "_blank"
  }, props.text.connect_with + " " + (hasSingleLink ? links[0].name : "") + " \u203A")) : android || loading || !loading && links.length ? React.createElement("div", {
    className: "walletconnect-modal__mobile__toggle" + (rightSelected ? " right__selected" : "")
  }, React.createElement("div", {
    className: "walletconnect-modal__mobile__toggle_selector"
  }), mobile ? React.createElement(React.Fragment, null, React.createElement("a", {
    onClick: function() {
      return setDisplayQRCode(false), getLinksIfNeeded();
    }
  }, props.text.mobile), React.createElement("a", {
    onClick: function() {
      return setDisplayQRCode(true);
    }
  }, props.text.qrcode)) : React.createElement(React.Fragment, null, React.createElement("a", {
    onClick: function() {
      return setDisplayQRCode(true);
    }
  }, props.text.qrcode), React.createElement("a", {
    onClick: function() {
      return setDisplayQRCode(false), getLinksIfNeeded();
    }
  }, props.text.desktop))) : null, React.createElement("div", null, displayQRCode || !android && !loading && !links.length ? React.createElement(QRCodeDisplay, Object.assign({}, displayProps)) : React.createElement(LinkDisplay, Object.assign({}, displayProps, {
    links,
    errorMessage
  })))));
}
var de = {
  choose_preferred_wallet: "W\xE4hle bevorzugte Wallet",
  connect_mobile_wallet: "Verbinde mit Mobile Wallet",
  scan_qrcode_with_wallet: "Scanne den QR-code mit einer WalletConnect kompatiblen Wallet",
  connect: "Verbinden",
  qrcode: "QR-Code",
  mobile: "Mobile",
  desktop: "Desktop",
  copy_to_clipboard: "In die Zwischenablage kopieren",
  copied_to_clipboard: "In die Zwischenablage kopiert!",
  connect_with: "Verbinden mit Hilfe von",
  loading: "Laden...",
  something_went_wrong: "Etwas ist schief gelaufen",
  no_supported_wallets: "Es gibt noch keine unterst\xFCtzten Wallet",
  no_wallets_found: "keine Wallet gefunden"
};
var en = {
  choose_preferred_wallet: "Choose your preferred wallet",
  connect_mobile_wallet: "Connect to Mobile Wallet",
  scan_qrcode_with_wallet: "Scan QR code with a WalletConnect-compatible wallet",
  connect: "Connect",
  qrcode: "QR Code",
  mobile: "Mobile",
  desktop: "Desktop",
  copy_to_clipboard: "Copy to clipboard",
  copied_to_clipboard: "Copied to clipboard!",
  connect_with: "Connect with",
  loading: "Loading...",
  something_went_wrong: "Something went wrong",
  no_supported_wallets: "There are no supported wallets yet",
  no_wallets_found: "No wallets found"
};
var es = {
  choose_preferred_wallet: "Elige tu billetera preferida",
  connect_mobile_wallet: "Conectar a billetera m\xF3vil",
  scan_qrcode_with_wallet: "Escanea el c\xF3digo QR con una billetera compatible con WalletConnect",
  connect: "Conectar",
  qrcode: "C\xF3digo QR",
  mobile: "M\xF3vil",
  desktop: "Desktop",
  copy_to_clipboard: "Copiar",
  copied_to_clipboard: "Copiado!",
  connect_with: "Conectar mediante",
  loading: "Cargando...",
  something_went_wrong: "Algo sali\xF3 mal",
  no_supported_wallets: "Todav\xEDa no hay billeteras compatibles",
  no_wallets_found: "No se encontraron billeteras"
};
var fr = {
  choose_preferred_wallet: "Choisissez votre portefeuille pr\xE9f\xE9r\xE9",
  connect_mobile_wallet: "Se connecter au portefeuille mobile",
  scan_qrcode_with_wallet: "Scannez le QR code avec un portefeuille compatible WalletConnect",
  connect: "Se connecter",
  qrcode: "QR Code",
  mobile: "Mobile",
  desktop: "Desktop",
  copy_to_clipboard: "Copier",
  copied_to_clipboard: "Copi\xE9!",
  connect_with: "Connectez-vous \xE0 l'aide de",
  loading: "Chargement...",
  something_went_wrong: "Quelque chose a mal tourn\xE9",
  no_supported_wallets: "Il n'y a pas encore de portefeuilles pris en charge",
  no_wallets_found: "Aucun portefeuille trouv\xE9"
};
var ko = {
  choose_preferred_wallet: "\uC6D0\uD558\uB294 \uC9C0\uAC11\uC744 \uC120\uD0DD\uD558\uC138\uC694",
  connect_mobile_wallet: "\uBAA8\uBC14\uC77C \uC9C0\uAC11\uACFC \uC5F0\uACB0",
  scan_qrcode_with_wallet: "WalletConnect \uC9C0\uC6D0 \uC9C0\uAC11\uC5D0\uC11C QR\uCF54\uB4DC\uB97C \uC2A4\uCE94\uD558\uC138\uC694",
  connect: "\uC5F0\uACB0",
  qrcode: "QR \uCF54\uB4DC",
  mobile: "\uBAA8\uBC14\uC77C",
  desktop: "\uB370\uC2A4\uD06C\uD0D1",
  copy_to_clipboard: "\uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC",
  copied_to_clipboard: "\uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC\uB418\uC5C8\uC2B5\uB2C8\uB2E4!",
  connect_with: "\uC640 \uC5F0\uACB0\uD558\uB2E4",
  loading: "\uB85C\uB4DC \uC911...",
  something_went_wrong: "\uBB38\uC81C\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.",
  no_supported_wallets: "\uC544\uC9C1 \uC9C0\uC6D0\uB418\uB294 \uC9C0\uAC11\uC774 \uC5C6\uC2B5\uB2C8\uB2E4",
  no_wallets_found: "\uC9C0\uAC11\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4"
};
var pt = {
  choose_preferred_wallet: "Escolha sua carteira preferida",
  connect_mobile_wallet: "Conectar-se \xE0 carteira m\xF3vel",
  scan_qrcode_with_wallet: "Ler o c\xF3digo QR com uma carteira compat\xEDvel com WalletConnect",
  connect: "Conectar",
  qrcode: "C\xF3digo QR",
  mobile: "M\xF3vel",
  desktop: "Desktop",
  copy_to_clipboard: "Copiar",
  copied_to_clipboard: "Copiado!",
  connect_with: "Ligar por meio de",
  loading: "Carregamento...",
  something_went_wrong: "Algo correu mal",
  no_supported_wallets: "Ainda n\xE3o h\xE1 carteiras suportadas",
  no_wallets_found: "Nenhuma carteira encontrada"
};
var zh = {
  choose_preferred_wallet: "\u9009\u62E9\u4F60\u7684\u94B1\u5305",
  connect_mobile_wallet: "\u8FDE\u63A5\u81F3\u79FB\u52A8\u7AEF\u94B1\u5305",
  scan_qrcode_with_wallet: "\u4F7F\u7528\u517C\u5BB9 WalletConnect \u7684\u94B1\u5305\u626B\u63CF\u4E8C\u7EF4\u7801",
  connect: "\u8FDE\u63A5",
  qrcode: "\u4E8C\u7EF4\u7801",
  mobile: "\u79FB\u52A8",
  desktop: "\u684C\u9762",
  copy_to_clipboard: "\u590D\u5236\u5230\u526A\u8D34\u677F",
  copied_to_clipboard: "\u590D\u5236\u5230\u526A\u8D34\u677F\u6210\u529F\uFF01",
  connect_with: "\u901A\u8FC7\u4EE5\u4E0B\u65B9\u5F0F\u8FDE\u63A5",
  loading: "\u6B63\u5728\u52A0\u8F7D...",
  something_went_wrong: "\u51FA\u4E86\u95EE\u9898",
  no_supported_wallets: "\u76EE\u524D\u8FD8\u6CA1\u6709\u652F\u6301\u7684\u94B1\u5305",
  no_wallets_found: "\u6CA1\u6709\u627E\u5230\u94B1\u5305"
};
var fa = {
  choose_preferred_wallet: "\u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0645\u0648\u0631\u062F \u0646\u0638\u0631 \u062E\u0648\u062F \u0631\u0627 \u0627\u0646\u062A\u062E\u0627\u0628 \u06A9\u0646\u06CC\u062F",
  connect_mobile_wallet: "\u0628\u0647 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0645\u0648\u0628\u0627\u06CC\u0644 \u0648\u0635\u0644 \u0634\u0648\u06CC\u062F",
  scan_qrcode_with_wallet: "\u06A9\u062F QR \u0631\u0627 \u0628\u0627 \u06CC\u06A9 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0633\u0627\u0632\u06AF\u0627\u0631 \u0628\u0627 WalletConnect \u0627\u0633\u06A9\u0646 \u06A9\u0646\u06CC\u062F",
  connect: "\u0627\u062A\u0635\u0627\u0644",
  qrcode: "\u06A9\u062F QR",
  mobile: "\u0633\u06CC\u0627\u0631",
  desktop: "\u062F\u0633\u06A9\u062A\u0627\u067E",
  copy_to_clipboard: "\u06A9\u067E\u06CC \u0628\u0647 \u06A9\u0644\u06CC\u067E \u0628\u0648\u0631\u062F",
  copied_to_clipboard: "\u062F\u0631 \u06A9\u0644\u06CC\u067E \u0628\u0648\u0631\u062F \u06A9\u067E\u06CC \u0634\u062F!",
  connect_with: "\u0627\u0631\u062A\u0628\u0627\u0637 \u0628\u0627",
  loading: "...\u0628\u0627\u0631\u06AF\u0630\u0627\u0631\u06CC",
  something_went_wrong: "\u0645\u0634\u06A9\u0644\u06CC \u067E\u06CC\u0634 \u0622\u0645\u062F",
  no_supported_wallets: "\u0647\u0646\u0648\u0632 \u0647\u06CC\u0686 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u067E\u0634\u062A\u06CC\u0628\u0627\u0646\u06CC \u0634\u062F\u0647 \u0627\u06CC \u0648\u062C\u0648\u062F \u0646\u062F\u0627\u0631\u062F",
  no_wallets_found: "\u0647\u06CC\u0686 \u06A9\u06CC\u0641 \u067E\u0648\u0644\u06CC \u067E\u06CC\u062F\u0627 \u0646\u0634\u062F"
};
var languages = {
  de,
  en,
  es,
  fr,
  ko,
  pt,
  zh,
  fa
};
function injectStyleSheet() {
  var doc2 = browserUtils.getDocumentOrThrow();
  var prev = doc2.getElementById(WALLETCONNECT_STYLE_ID);
  if (prev) {
    doc2.head.removeChild(prev);
  }
  var style2 = doc2.createElement("style");
  style2.setAttribute("id", WALLETCONNECT_STYLE_ID);
  style2.innerText = WALLETCONNECT_STYLE_SHEET;
  doc2.head.appendChild(style2);
}
function renderWrapper() {
  var doc2 = browserUtils.getDocumentOrThrow();
  var wrapper = doc2.createElement("div");
  wrapper.setAttribute("id", WALLETCONNECT_WRAPPER_ID);
  doc2.body.appendChild(wrapper);
  return wrapper;
}
function triggerCloseAnimation() {
  var doc2 = browserUtils.getDocumentOrThrow();
  var modal = doc2.getElementById(WALLETCONNECT_MODAL_ID);
  if (modal) {
    modal.className = modal.className.replace("fadeIn", "fadeOut");
    setTimeout(function() {
      var wrapper = doc2.getElementById(WALLETCONNECT_WRAPPER_ID);
      if (wrapper) {
        doc2.body.removeChild(wrapper);
      }
    }, ANIMATION_DURATION);
  }
}
function getWrappedCallback(cb) {
  return function() {
    triggerCloseAnimation();
    if (cb) {
      cb();
    }
  };
}
function getText() {
  var lang = browserUtils.getNavigatorOrThrow().language.split("-")[0] || "en";
  return languages[lang] || languages["en"];
}
function open$1(uri, cb, qrcodeModalOptions) {
  injectStyleSheet();
  var wrapper = renderWrapper();
  React.render(React.createElement(Modal$1, {
    text: getText(),
    uri,
    onClose: getWrappedCallback(cb),
    qrcodeModalOptions
  }), wrapper);
}
function close$1() {
  triggerCloseAnimation();
}
var isNode$1 = function() {
  return typeof browser$1$1 !== "undefined" && typeof browser$1$1.versions !== "undefined" && typeof browser$1$1.versions.node !== "undefined";
};
function open$2(uri, cb, qrcodeModalOptions) {
  console.log(uri);
  if (isNode$1()) {
    open(uri);
  } else {
    open$1(uri, cb, qrcodeModalOptions);
  }
}
function close$2() {
  if (isNode$1())
    ;
  else {
    close$1();
  }
}
var index = {
  open: open$2,
  close: close$2
};
var cjs = index;
class WalletConnectProvider {
  constructor() {
    this.name = "WalletConnect";
    this.supportedChains = ["ETH", "MATIC"];
    this.available = true;
    this.metadata = {
      icon: WalletConnectIcon,
      desc: "Mobile & other wallets"
    };
    this.provider = new WalletConnect({
      bridge: "https://bridge.walletconnect.org",
      qrcodeModal: cjs
    });
    this._forceOpen = false;
  }
  getAddress() {
    const [account] = this.provider.accounts;
    return account;
  }
  async connect(_chain, network = "mainnet") {
    return new Promise(async (r2, j2) => {
      let setForceOpen = false;
      if (!this.provider.connected) {
        await this.provider.createSession();
        setForceOpen = true;
      }
      if (this._forceOpen) {
        this.provider._qrcodeModal.open(this.provider.uri, this.provider._qrcodeModalOptions);
      } else if (setForceOpen) {
        this._forceOpen = true;
      }
      const ob = new MutationObserver(([event]) => {
        const removed = [...event.removedNodes].find((el) => el.id === "walletconnect-wrapper");
        if (!removed)
          return;
        ob.disconnect();
        return this.provider.connected ? r2(this.getAddress()) : j2(new UserRejectedRequestError());
      });
      ob.observe(document.querySelector("body"), { childList: true });
    });
  }
  async sign(message) {
    const encodedMessage = new TextEncoder().encode(message);
    return this.provider.signPersonalMessage([encodedMessage, this.getAddress()]);
  }
}
var EthereumProviders = [
  new MetaMaskProvider(),
  new WalletConnectProvider()
];
var events = { exports: {} };
var R = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === "function") {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn)
    console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
  return value !== value;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once2;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter.init = function() {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n2) {
  if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
  }
  this._maxListeners = n2;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit2(type) {
  var args = [];
  for (var i2 = 1; i2 < arguments.length; i2++)
    args.push(arguments[i2]);
  var doError = type === "error";
  var events2 = this._events;
  if (events2 !== void 0)
    doError = doError && events2.error === void 0;
  else if (!doError)
    return false;
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      throw er;
    }
    var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
    err.context = er;
    throw err;
  }
  var handler = events2[type];
  if (handler === void 0)
    return false;
  if (typeof handler === "function") {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      ReflectApply(listeners2[i2], this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m2;
  var events2;
  var existing;
  checkListener(listener);
  events2 = target._events;
  if (events2 === void 0) {
    events2 = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events2.newListener !== void 0) {
      target.emit("newListener", type, listener.listener ? listener.listener : listener);
      events2 = target._events;
    }
    existing = events2[type];
  }
  if (existing === void 0) {
    existing = events2[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m2 = _getMaxListeners(target);
    if (m2 > 0 && existing.length > m2 && !existing.warned) {
      existing.warned = true;
      var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      w2.name = "MaxListenersExceededWarning";
      w2.emitter = target;
      w2.type = type;
      w2.count = existing.length;
      ProcessEmitWarning(w2);
    }
  }
  return target;
}
EventEmitter.prototype.addListener = function addListener2(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  var state2 = { fired: false, wrapFn: void 0, target, type, listener };
  var wrapped = onceWrapper.bind(state2);
  wrapped.listener = listener;
  state2.wrapFn = wrapped;
  return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.removeListener = function removeListener2(type, listener) {
  var list, events2, position, i2, originalListener;
  checkListener(listener);
  events2 = this._events;
  if (events2 === void 0)
    return this;
  list = events2[type];
  if (list === void 0)
    return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = /* @__PURE__ */ Object.create(null);
    else {
      delete events2[type];
      if (events2.removeListener)
        this.emit("removeListener", type, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i2 = list.length - 1; i2 >= 0; i2--) {
      if (list[i2] === listener || list[i2].listener === listener) {
        originalListener = list[i2].listener;
        position = i2;
        break;
      }
    }
    if (position < 0)
      return this;
    if (position === 0)
      list.shift();
    else {
      spliceOne(list, position);
    }
    if (list.length === 1)
      events2[type] = list[0];
    if (events2.removeListener !== void 0)
      this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners2(type) {
  var listeners2, events2, i2;
  events2 = this._events;
  if (events2 === void 0)
    return this;
  if (events2.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events2[type] !== void 0) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else
        delete events2[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys = Object.keys(events2);
    var key2;
    for (i2 = 0; i2 < keys.length; ++i2) {
      key2 = keys[i2];
      if (key2 === "removeListener")
        continue;
      this.removeAllListeners(key2);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners2 = events2[type];
  if (typeof listeners2 === "function") {
    this.removeListener(type, listeners2);
  } else if (listeners2 !== void 0) {
    for (i2 = listeners2.length - 1; i2 >= 0; i2--) {
      this.removeListener(type, listeners2[i2]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  var events2 = target._events;
  if (events2 === void 0)
    return [];
  var evlistener = events2[type];
  if (evlistener === void 0)
    return [];
  if (typeof evlistener === "function")
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events2 = this._events;
  if (events2 !== void 0) {
    var evlistener = events2[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n2) {
  var copy4 = new Array(n2);
  for (var i2 = 0; i2 < n2; ++i2)
    copy4[i2] = arr[i2];
  return copy4;
}
function spliceOne(list, index2) {
  for (; index2 + 1 < list.length; index2++)
    list[index2] = list[index2 + 1];
  list.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i2 = 0; i2 < ret.length; ++i2) {
    ret[i2] = arr[i2].listener || arr[i2];
  }
  return ret;
}
function once2(emitter, name) {
  return new Promise(function(resolve2, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      resolve2([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== "error") {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === "function") {
    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name, function wrapListener(arg) {
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
var EventEmitter$1 = events.exports;
class Wallet {
  constructor() {
    this.providers = [];
    this.active = null;
  }
  registerProviders(providers) {
    this.providers = providers;
    return this;
  }
  setActive(name, symbol) {
    this.active = this.providers.find((provider) => provider.name === name && provider.symbol === symbol);
    return this;
  }
  providersForChain(chain) {
    return this.providers.filter((provider) => provider.supportedChains.includes(chain));
  }
  async getAddress() {
    return this.active.getAddress();
  }
  async connect(chain, network) {
    return this.active.connect(chain, network);
  }
  async sign(message) {
    return this.active.sign(message);
  }
}
var Wallet$1 = new Wallet();
var axios$2 = { exports: {} };
var bind$3 = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i2 = 0; i2 < args.length; i2++) {
      args[i2] = arguments[i2];
    }
    return fn.apply(thisArg, args);
  };
};
var bind$2 = bind$3;
var toString2 = Object.prototype.toString;
function isArray(val) {
  return Array.isArray(val);
}
function isUndefined(val) {
  return typeof val === "undefined";
}
function isBuffer2(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
function isArrayBuffer(val) {
  return toString2.call(val) === "[object ArrayBuffer]";
}
function isFormData(val) {
  return toString2.call(val) === "[object FormData]";
}
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
function isString(val) {
  return typeof val === "string";
}
function isNumber(val) {
  return typeof val === "number";
}
function isObject$1(val) {
  return val !== null && typeof val === "object";
}
function isPlainObject(val) {
  if (toString2.call(val) !== "[object Object]") {
    return false;
  }
  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}
function isDate(val) {
  return toString2.call(val) === "[object Date]";
}
function isFile(val) {
  return toString2.call(val) === "[object File]";
}
function isBlob(val) {
  return toString2.call(val) === "[object Blob]";
}
function isFunction(val) {
  return toString2.call(val) === "[object Function]";
}
function isStream(val) {
  return isObject$1(val) && isFunction(val.pipe);
}
function isURLSearchParams(val) {
  return toString2.call(val) === "[object URLSearchParams]";
}
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function forEach(obj, fn) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      fn.call(null, obj[i2], i2, obj);
    }
  } else {
    for (var key2 in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key2)) {
        fn.call(null, obj[key2], key2, obj);
      }
    }
  }
}
function merge() {
  var result = {};
  function assignValue(val, key2) {
    if (isPlainObject(result[key2]) && isPlainObject(val)) {
      result[key2] = merge(result[key2], val);
    } else if (isPlainObject(val)) {
      result[key2] = merge({}, val);
    } else if (isArray(val)) {
      result[key2] = val.slice();
    } else {
      result[key2] = val;
    }
  }
  for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    forEach(arguments[i2], assignValue);
  }
  return result;
}
function extend(a2, b2, thisArg) {
  forEach(b2, function assignValue(val, key2) {
    if (thisArg && typeof val === "function") {
      a2[key2] = bind$2(val, thisArg);
    } else {
      a2[key2] = val;
    }
  });
  return a2;
}
function stripBOM(content) {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
}
var utils$e = {
  isArray,
  isArrayBuffer,
  isBuffer: isBuffer2,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isObject: isObject$1,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isFunction,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach,
  merge,
  extend,
  trim,
  stripBOM
};
var utils$d = utils$e;
function encode3(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$2 = function buildURL(url, params, paramsSerializer) {
  if (!params) {
    return url;
  }
  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils$d.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils$d.forEach(params, function serialize(val, key2) {
      if (val === null || typeof val === "undefined") {
        return;
      }
      if (utils$d.isArray(val)) {
        key2 = key2 + "[]";
      } else {
        val = [val];
      }
      utils$d.forEach(val, function parseValue(v2) {
        if (utils$d.isDate(v2)) {
          v2 = v2.toISOString();
        } else if (utils$d.isObject(v2)) {
          v2 = JSON.stringify(v2);
        }
        parts.push(encode3(key2) + "=" + encode3(v2));
      });
    });
    serializedParams = parts.join("&");
  }
  if (serializedParams) {
    var hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
};
var utils$c = utils$e;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled,
    rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};
InterceptorManager$1.prototype.eject = function eject(id2) {
  if (this.handlers[id2]) {
    this.handlers[id2] = null;
  }
};
InterceptorManager$1.prototype.forEach = function forEach2(fn) {
  utils$c.forEach(this.handlers, function forEachHandler(h2) {
    if (h2 !== null) {
      fn(h2);
    }
  });
};
var InterceptorManager_1 = InterceptorManager$1;
var utils$b = utils$e;
var normalizeHeaderName$1 = function normalizeHeaderName(headers, normalizedName) {
  utils$b.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};
var enhanceError$2 = function enhanceError(error, config2, code2, request2, response) {
  error.config = config2;
  if (code2) {
    error.code = code2;
  }
  error.request = request2;
  error.response = response;
  error.isAxiosError = true;
  error.toJSON = function toJSON3() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  };
  return error;
};
var enhanceError$1 = enhanceError$2;
var createError$2 = function createError(message, config2, code2, request2, response) {
  var error = new Error(message);
  return enhanceError$1(error, config2, code2, request2, response);
};
var createError$1 = createError$2;
var settle$1 = function settle(resolve2, reject, response) {
  var validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve2(response);
  } else {
    reject(createError$1("Request failed with status code " + response.status, response.config, null, response.request, response));
  }
};
var utils$a = utils$e;
var cookies$1 = utils$a.isStandardBrowserEnv() ? function standardBrowserEnv() {
  return {
    write: function write6(name, value, expires, path, domain2, secure) {
      var cookie = [];
      cookie.push(name + "=" + encodeURIComponent(value));
      if (utils$a.isNumber(expires)) {
        cookie.push("expires=" + new Date(expires).toGMTString());
      }
      if (utils$a.isString(path)) {
        cookie.push("path=" + path);
      }
      if (utils$a.isString(domain2)) {
        cookie.push("domain=" + domain2);
      }
      if (secure === true) {
        cookie.push("secure");
      }
      document.cookie = cookie.join("; ");
    },
    read: function read2(name) {
      var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove2(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  };
}() : function nonStandardBrowserEnv() {
  return {
    write: function write6() {
    },
    read: function read2() {
      return null;
    },
    remove: function remove2() {
    }
  };
}();
var isAbsoluteURL$1 = function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
};
var combineURLs$1 = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
};
var isAbsoluteURL2 = isAbsoluteURL$1;
var combineURLs2 = combineURLs$1;
var buildFullPath$1 = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL2(requestedURL)) {
    return combineURLs2(baseURL, requestedURL);
  }
  return requestedURL;
};
var utils$9 = utils$e;
var ignoreDuplicateOf = [
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
];
var parseHeaders$1 = function parseHeaders(headers) {
  var parsed = {};
  var key2;
  var val;
  var i2;
  if (!headers) {
    return parsed;
  }
  utils$9.forEach(headers.split("\n"), function parser(line) {
    i2 = line.indexOf(":");
    key2 = utils$9.trim(line.substr(0, i2)).toLowerCase();
    val = utils$9.trim(line.substr(i2 + 1));
    if (key2) {
      if (parsed[key2] && ignoreDuplicateOf.indexOf(key2) >= 0) {
        return;
      }
      if (key2 === "set-cookie") {
        parsed[key2] = (parsed[key2] ? parsed[key2] : []).concat([val]);
      } else {
        parsed[key2] = parsed[key2] ? parsed[key2] + ", " + val : val;
      }
    }
  });
  return parsed;
};
var utils$8 = utils$e;
var isURLSameOrigin$1 = utils$8.isStandardBrowserEnv() ? function standardBrowserEnv2() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement("a");
  var originURL;
  function resolveURL(url) {
    var href = url;
    if (msie) {
      urlParsingNode.setAttribute("href", href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute("href", href);
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
    };
  }
  originURL = resolveURL(window.location.href);
  return function isURLSameOrigin2(requestURL) {
    var parsed = utils$8.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : function nonStandardBrowserEnv2() {
  return function isURLSameOrigin2() {
    return true;
  };
}();
function Cancel$3(message) {
  this.message = message;
}
Cancel$3.prototype.toString = function toString3() {
  return "Cancel" + (this.message ? ": " + this.message : "");
};
Cancel$3.prototype.__CANCEL__ = true;
var Cancel_1 = Cancel$3;
var utils$7 = utils$e;
var settle2 = settle$1;
var cookies = cookies$1;
var buildURL$1 = buildURL$2;
var buildFullPath2 = buildFullPath$1;
var parseHeaders2 = parseHeaders$1;
var isURLSameOrigin = isURLSameOrigin$1;
var createError2 = createError$2;
var defaults$4 = defaults_1;
var Cancel$2 = Cancel_1;
var xhr = function xhrAdapter(config2) {
  return new Promise(function dispatchXhrRequest(resolve2, reject) {
    var requestData = config2.data;
    var requestHeaders = config2.headers;
    var responseType = config2.responseType;
    var onCanceled;
    function done() {
      if (config2.cancelToken) {
        config2.cancelToken.unsubscribe(onCanceled);
      }
      if (config2.signal) {
        config2.signal.removeEventListener("abort", onCanceled);
      }
    }
    if (utils$7.isFormData(requestData)) {
      delete requestHeaders["Content-Type"];
    }
    var request2 = new XMLHttpRequest();
    if (config2.auth) {
      var username = config2.auth.username || "";
      var password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
      requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
    }
    var fullPath = buildFullPath2(config2.baseURL, config2.url);
    request2.open(config2.method.toUpperCase(), buildURL$1(fullPath, config2.params, config2.paramsSerializer), true);
    request2.timeout = config2.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      var responseHeaders = "getAllResponseHeaders" in request2 ? parseHeaders2(request2.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      var response = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config: config2,
        request: request2
      };
      settle2(function _resolve(value) {
        resolve2(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(createError2("Request aborted", config2, "ECONNABORTED", request2));
      request2 = null;
    };
    request2.onerror = function handleError2() {
      reject(createError2("Network Error", config2, null, request2));
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
      var transitional2 = config2.transitional || defaults$4.transitional;
      if (config2.timeoutErrorMessage) {
        timeoutErrorMessage = config2.timeoutErrorMessage;
      }
      reject(createError2(timeoutErrorMessage, config2, transitional2.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", request2));
      request2 = null;
    };
    if (utils$7.isStandardBrowserEnv()) {
      var xsrfValue = (config2.withCredentials || isURLSameOrigin(fullPath)) && config2.xsrfCookieName ? cookies.read(config2.xsrfCookieName) : void 0;
      if (xsrfValue) {
        requestHeaders[config2.xsrfHeaderName] = xsrfValue;
      }
    }
    if ("setRequestHeader" in request2) {
      utils$7.forEach(requestHeaders, function setRequestHeader(val, key2) {
        if (typeof requestData === "undefined" && key2.toLowerCase() === "content-type") {
          delete requestHeaders[key2];
        } else {
          request2.setRequestHeader(key2, val);
        }
      });
    }
    if (!utils$7.isUndefined(config2.withCredentials)) {
      request2.withCredentials = !!config2.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = config2.responseType;
    }
    if (typeof config2.onDownloadProgress === "function") {
      request2.addEventListener("progress", config2.onDownloadProgress);
    }
    if (typeof config2.onUploadProgress === "function" && request2.upload) {
      request2.upload.addEventListener("progress", config2.onUploadProgress);
    }
    if (config2.cancelToken || config2.signal) {
      onCanceled = function(cancel) {
        if (!request2) {
          return;
        }
        reject(!cancel || cancel && cancel.type ? new Cancel$2("canceled") : cancel);
        request2.abort();
        request2 = null;
      };
      config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
      if (config2.signal) {
        config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
      }
    }
    if (!requestData) {
      requestData = null;
    }
    request2.send(requestData);
  });
};
var utils$6 = utils$e;
var normalizeHeaderName2 = normalizeHeaderName$1;
var enhanceError2 = enhanceError$2;
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(headers, value) {
  if (!utils$6.isUndefined(headers) && utils$6.isUndefined(headers["Content-Type"])) {
    headers["Content-Type"] = value;
  }
}
function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== "undefined") {
    adapter = xhr;
  } else if (typeof browser$1$1 !== "undefined" && Object.prototype.toString.call(browser$1$1) === "[object process]") {
    adapter = xhr;
  }
  return adapter;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$6.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$6.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults$3 = {
  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data2, headers) {
    normalizeHeaderName2(headers, "Accept");
    normalizeHeaderName2(headers, "Content-Type");
    if (utils$6.isFormData(data2) || utils$6.isArrayBuffer(data2) || utils$6.isBuffer(data2) || utils$6.isStream(data2) || utils$6.isFile(data2) || utils$6.isBlob(data2)) {
      return data2;
    }
    if (utils$6.isArrayBufferView(data2)) {
      return data2.buffer;
    }
    if (utils$6.isURLSearchParams(data2)) {
      setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
      return data2.toString();
    }
    if (utils$6.isObject(data2) || headers && headers["Content-Type"] === "application/json") {
      setContentTypeIfUnset(headers, "application/json");
      return stringifySafely(data2);
    }
    return data2;
  }],
  transformResponse: [function transformResponse(data2) {
    var transitional2 = this.transitional || defaults$3.transitional;
    var silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
    var forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
    if (strictJSONParsing || forcedJSONParsing && utils$6.isString(data2) && data2.length) {
      try {
        return JSON.parse(data2);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw enhanceError2(e2, this, "E_JSON_PARSE");
          }
          throw e2;
        }
      }
    }
    return data2;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils$6.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults$3.headers[method] = {};
});
utils$6.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults$3.headers[method] = utils$6.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$3;
var utils$5 = utils$e;
var defaults$2 = defaults_1;
var transformData$1 = function transformData(data2, headers, fns) {
  var context = this || defaults$2;
  utils$5.forEach(fns, function transform(fn) {
    data2 = fn.call(context, data2, headers);
  });
  return data2;
};
var isCancel$1 = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};
var utils$4 = utils$e;
var transformData2 = transformData$1;
var isCancel2 = isCancel$1;
var defaults$1 = defaults_1;
var Cancel$1 = Cancel_1;
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new Cancel$1("canceled");
  }
}
var dispatchRequest$1 = function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = config2.headers || {};
  config2.data = transformData2.call(config2, config2.data, config2.headers, config2.transformRequest);
  config2.headers = utils$4.merge(config2.headers.common || {}, config2.headers[config2.method] || {}, config2.headers);
  utils$4.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
    delete config2.headers[method];
  });
  var adapter = config2.adapter || defaults$1.adapter;
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData2.call(config2, response.data, response.headers, config2.transformResponse);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel2(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData2.call(config2, reason.response.data, reason.response.headers, config2.transformResponse);
      }
    }
    return Promise.reject(reason);
  });
};
var utils$3 = utils$e;
var mergeConfig$2 = function mergeConfig(config1, config2) {
  config2 = config2 || {};
  var config3 = {};
  function getMergedValue(target, source2) {
    if (utils$3.isPlainObject(target) && utils$3.isPlainObject(source2)) {
      return utils$3.merge(target, source2);
    } else if (utils$3.isPlainObject(source2)) {
      return utils$3.merge({}, source2);
    } else if (utils$3.isArray(source2)) {
      return source2.slice();
    }
    return source2;
  }
  function mergeDeepProperties(prop) {
    if (!utils$3.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils$3.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function valueFromConfig2(prop) {
    if (!utils$3.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    }
  }
  function defaultToConfig2(prop) {
    if (!utils$3.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    } else if (!utils$3.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  var mergeMap = {
    "url": valueFromConfig2,
    "method": valueFromConfig2,
    "data": valueFromConfig2,
    "baseURL": defaultToConfig2,
    "transformRequest": defaultToConfig2,
    "transformResponse": defaultToConfig2,
    "paramsSerializer": defaultToConfig2,
    "timeout": defaultToConfig2,
    "timeoutMessage": defaultToConfig2,
    "withCredentials": defaultToConfig2,
    "adapter": defaultToConfig2,
    "responseType": defaultToConfig2,
    "xsrfCookieName": defaultToConfig2,
    "xsrfHeaderName": defaultToConfig2,
    "onUploadProgress": defaultToConfig2,
    "onDownloadProgress": defaultToConfig2,
    "decompress": defaultToConfig2,
    "maxContentLength": defaultToConfig2,
    "maxBodyLength": defaultToConfig2,
    "transport": defaultToConfig2,
    "httpAgent": defaultToConfig2,
    "httpsAgent": defaultToConfig2,
    "cancelToken": defaultToConfig2,
    "socketPath": defaultToConfig2,
    "responseEncoding": defaultToConfig2,
    "validateStatus": mergeDirectKeys
  };
  utils$3.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge2 = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge2(prop);
    utils$3.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
};
var data = {
  "version": "0.26.0"
};
var VERSION = data.version;
var validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i2) {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return function(value, opt, opts) {
    if (validator2 === false) {
      throw new Error(formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")));
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(formatMessage(opt, " has been deprecated since v" + version2 + " and will be removed in the near future"));
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new TypeError("options must be an object");
  }
  var keys = Object.keys(options);
  var i2 = keys.length;
  while (i2-- > 0) {
    var opt = keys[i2];
    var validator2 = schema[opt];
    if (validator2) {
      var value = options[opt];
      var result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new TypeError("option " + opt + " must be " + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error("Unknown option " + opt);
    }
  }
}
var validator$1 = {
  assertOptions,
  validators: validators$1
};
var utils$2 = utils$e;
var buildURL2 = buildURL$2;
var InterceptorManager = InterceptorManager_1;
var dispatchRequest2 = dispatchRequest$1;
var mergeConfig$1 = mergeConfig$2;
var validator = validator$1;
var validators = validator.validators;
function Axios$1(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
Axios$1.prototype.request = function request(configOrUrl, config2) {
  if (typeof configOrUrl === "string") {
    config2 = config2 || {};
    config2.url = configOrUrl;
  } else {
    config2 = configOrUrl || {};
  }
  config2 = mergeConfig$1(this.defaults, config2);
  if (config2.method) {
    config2.method = config2.method.toLowerCase();
  } else if (this.defaults.method) {
    config2.method = this.defaults.method.toLowerCase();
  } else {
    config2.method = "get";
  }
  var transitional2 = config2.transitional;
  if (transitional2 !== void 0) {
    validator.assertOptions(transitional2, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
      return;
    }
    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });
  var promise;
  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest2, void 0];
    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);
    promise = Promise.resolve(config2);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }
    return promise;
  }
  var newConfig = config2;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }
  try {
    promise = dispatchRequest2(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }
  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }
  return promise;
};
Axios$1.prototype.getUri = function getUri(config2) {
  config2 = mergeConfig$1(this.defaults, config2);
  return buildURL2(config2.url, config2.params, config2.paramsSerializer).replace(/^\?/, "");
};
utils$2.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios$1.prototype[method] = function(url, config2) {
    return this.request(mergeConfig$1(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
});
utils$2.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  Axios$1.prototype[method] = function(url, data2, config2) {
    return this.request(mergeConfig$1(config2 || {}, {
      method,
      url,
      data: data2
    }));
  };
});
var Axios_1 = Axios$1;
var Cancel = Cancel_1;
function CancelToken(executor) {
  if (typeof executor !== "function") {
    throw new TypeError("executor must be a function.");
  }
  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve2) {
    resolvePromise = resolve2;
  });
  var token2 = this;
  this.promise.then(function(cancel) {
    if (!token2._listeners)
      return;
    var i2;
    var l2 = token2._listeners.length;
    for (i2 = 0; i2 < l2; i2++) {
      token2._listeners[i2](cancel);
    }
    token2._listeners = null;
  });
  this.promise.then = function(onfulfilled) {
    var _resolve;
    var promise = new Promise(function(resolve2) {
      token2.subscribe(resolve2);
      _resolve = resolve2;
    }).then(onfulfilled);
    promise.cancel = function reject() {
      token2.unsubscribe(_resolve);
    };
    return promise;
  };
  executor(function cancel(message) {
    if (token2.reason) {
      return;
    }
    token2.reason = new Cancel(message);
    resolvePromise(token2.reason);
  });
}
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};
CancelToken.prototype.subscribe = function subscribe(listener) {
  if (this.reason) {
    listener(this.reason);
    return;
  }
  if (this._listeners) {
    this._listeners.push(listener);
  } else {
    this._listeners = [listener];
  }
};
CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
  if (!this._listeners) {
    return;
  }
  var index2 = this._listeners.indexOf(listener);
  if (index2 !== -1) {
    this._listeners.splice(index2, 1);
  }
};
CancelToken.source = function source() {
  var cancel;
  var token2 = new CancelToken(function executor(c2) {
    cancel = c2;
  });
  return {
    token: token2,
    cancel
  };
};
var CancelToken_1 = CancelToken;
var spread = function spread2(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};
var utils$1 = utils$e;
var isAxiosError = function isAxiosError2(payload) {
  return utils$1.isObject(payload) && payload.isAxiosError === true;
};
var utils = utils$e;
var bind$1 = bind$3;
var Axios = Axios_1;
var mergeConfig2 = mergeConfig$2;
var defaults = defaults_1;
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind$1(Axios.prototype.request, context);
  utils.extend(instance, Axios.prototype, context);
  utils.extend(instance, context);
  instance.create = function create2(instanceConfig) {
    return createInstance(mergeConfig2(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios$1 = createInstance(defaults);
axios$1.Axios = Axios;
axios$1.Cancel = Cancel_1;
axios$1.CancelToken = CancelToken_1;
axios$1.isCancel = isCancel$1;
axios$1.VERSION = data.version;
axios$1.all = function all(promises) {
  return Promise.all(promises);
};
axios$1.spread = spread;
axios$1.isAxiosError = isAxiosError;
axios$2.exports = axios$1;
axios$2.exports.default = axios$1;
var axios = axios$2.exports;
function getDevtoolsGlobalHook() {
  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
  return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : {};
}
const isProxyAvailable = typeof Proxy === "function";
const HOOK_SETUP = "devtools-plugin:setup";
const HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";
class ApiProxy {
  constructor(plugin, hook) {
    this.target = null;
    this.targetQueue = [];
    this.onQueue = [];
    this.plugin = plugin;
    this.hook = hook;
    const defaultSettings = {};
    if (plugin.settings) {
      for (const id2 in plugin.settings) {
        const item = plugin.settings[id2];
        defaultSettings[id2] = item.defaultValue;
      }
    }
    const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
    let currentSettings = Object.assign({}, defaultSettings);
    try {
      const raw = localStorage.getItem(localSettingsSaveId);
      const data2 = JSON.parse(raw);
      Object.assign(currentSettings, data2);
    } catch (e2) {
    }
    this.fallbacks = {
      getSettings() {
        return currentSettings;
      },
      setSettings(value) {
        try {
          localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
        } catch (e2) {
        }
        currentSettings = value;
      }
    };
    if (hook) {
      hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
        if (pluginId === this.plugin.id) {
          this.fallbacks.setSettings(value);
        }
      });
    }
    this.proxiedOn = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target.on[prop];
        } else {
          return (...args) => {
            this.onQueue.push({
              method: prop,
              args
            });
          };
        }
      }
    });
    this.proxiedTarget = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target[prop];
        } else if (prop === "on") {
          return this.proxiedOn;
        } else if (Object.keys(this.fallbacks).includes(prop)) {
          return (...args) => {
            this.targetQueue.push({
              method: prop,
              args,
              resolve: () => {
              }
            });
            return this.fallbacks[prop](...args);
          };
        } else {
          return (...args) => {
            return new Promise((resolve2) => {
              this.targetQueue.push({
                method: prop,
                args,
                resolve: resolve2
              });
            });
          };
        }
      }
    });
  }
  async setRealTarget(target) {
    this.target = target;
    for (const item of this.onQueue) {
      this.target.on[item.method](...item.args);
    }
    for (const item of this.targetQueue) {
      item.resolve(await this.target[item.method](...item.args));
    }
  }
}
function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
  const descriptor = pluginDescriptor;
  const target = getTarget();
  const hook = getDevtoolsGlobalHook();
  const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
  if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
  } else {
    const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
    const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
    list.push({
      pluginDescriptor: descriptor,
      setupFn,
      proxy
    });
    if (proxy)
      setupFn(proxy.proxiedTarget);
  }
}
/*!
 * vuex v4.0.2
 * (c) 2021 Evan You
 * @license MIT
 */
var storeKey = "store";
function useStore(key2) {
  if (key2 === void 0)
    key2 = null;
  return inject(key2 !== null ? key2 : storeKey);
}
function forEachValue(obj, fn) {
  Object.keys(obj).forEach(function(key2) {
    return fn(obj[key2], key2);
  });
}
function isObject(obj) {
  return obj !== null && typeof obj === "object";
}
function isPromise(val) {
  return val && typeof val.then === "function";
}
function partial(fn, arg) {
  return function() {
    return fn(arg);
  };
}
function genericSubscribe(fn, subs, options) {
  if (subs.indexOf(fn) < 0) {
    options && options.prepend ? subs.unshift(fn) : subs.push(fn);
  }
  return function() {
    var i2 = subs.indexOf(fn);
    if (i2 > -1) {
      subs.splice(i2, 1);
    }
  };
}
function resetStore(store2, hot) {
  store2._actions = /* @__PURE__ */ Object.create(null);
  store2._mutations = /* @__PURE__ */ Object.create(null);
  store2._wrappedGetters = /* @__PURE__ */ Object.create(null);
  store2._modulesNamespaceMap = /* @__PURE__ */ Object.create(null);
  var state2 = store2.state;
  installModule(store2, state2, [], store2._modules.root, true);
  resetStoreState(store2, state2, hot);
}
function resetStoreState(store2, state2, hot) {
  var oldState = store2._state;
  store2.getters = {};
  store2._makeLocalGettersCache = /* @__PURE__ */ Object.create(null);
  var wrappedGetters = store2._wrappedGetters;
  var computedObj = {};
  forEachValue(wrappedGetters, function(fn, key2) {
    computedObj[key2] = partial(fn, store2);
    Object.defineProperty(store2.getters, key2, {
      get: function() {
        return computedObj[key2]();
      },
      enumerable: true
    });
  });
  store2._state = reactive({
    data: state2
  });
  if (store2.strict) {
    enableStrictMode(store2);
  }
  if (oldState) {
    if (hot) {
      store2._withCommit(function() {
        oldState.data = null;
      });
    }
  }
}
function installModule(store2, rootState, path, module, hot) {
  var isRoot = !path.length;
  var namespace = store2._modules.getNamespace(path);
  if (module.namespaced) {
    if (store2._modulesNamespaceMap[namespace] && false) {
      console.error("[vuex] duplicate namespace " + namespace + " for the namespaced module " + path.join("/"));
    }
    store2._modulesNamespaceMap[namespace] = module;
  }
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];
    store2._withCommit(function() {
      parentState[moduleName] = module.state;
    });
  }
  var local = module.context = makeLocalContext(store2, namespace, path);
  module.forEachMutation(function(mutation, key2) {
    var namespacedType = namespace + key2;
    registerMutation(store2, namespacedType, mutation, local);
  });
  module.forEachAction(function(action, key2) {
    var type = action.root ? key2 : namespace + key2;
    var handler = action.handler || action;
    registerAction(store2, type, handler, local);
  });
  module.forEachGetter(function(getter, key2) {
    var namespacedType = namespace + key2;
    registerGetter(store2, namespacedType, getter, local);
  });
  module.forEachChild(function(child, key2) {
    installModule(store2, rootState, path.concat(key2), child, hot);
  });
}
function makeLocalContext(store2, namespace, path) {
  var noNamespace = namespace === "";
  var local = {
    dispatch: noNamespace ? store2.dispatch : function(_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;
      if (!options || !options.root) {
        type = namespace + type;
      }
      return store2.dispatch(type, payload);
    },
    commit: noNamespace ? store2.commit : function(_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;
      if (!options || !options.root) {
        type = namespace + type;
      }
      store2.commit(type, payload, options);
    }
  };
  Object.defineProperties(local, {
    getters: {
      get: noNamespace ? function() {
        return store2.getters;
      } : function() {
        return makeLocalGetters(store2, namespace);
      }
    },
    state: {
      get: function() {
        return getNestedState(store2.state, path);
      }
    }
  });
  return local;
}
function makeLocalGetters(store2, namespace) {
  if (!store2._makeLocalGettersCache[namespace]) {
    var gettersProxy = {};
    var splitPos = namespace.length;
    Object.keys(store2.getters).forEach(function(type) {
      if (type.slice(0, splitPos) !== namespace) {
        return;
      }
      var localType = type.slice(splitPos);
      Object.defineProperty(gettersProxy, localType, {
        get: function() {
          return store2.getters[type];
        },
        enumerable: true
      });
    });
    store2._makeLocalGettersCache[namespace] = gettersProxy;
  }
  return store2._makeLocalGettersCache[namespace];
}
function registerMutation(store2, type, handler, local) {
  var entry = store2._mutations[type] || (store2._mutations[type] = []);
  entry.push(function wrappedMutationHandler(payload) {
    handler.call(store2, local.state, payload);
  });
}
function registerAction(store2, type, handler, local) {
  var entry = store2._actions[type] || (store2._actions[type] = []);
  entry.push(function wrappedActionHandler(payload) {
    var res = handler.call(store2, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store2.getters,
      rootState: store2.state
    }, payload);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store2._devtoolHook) {
      return res.catch(function(err) {
        store2._devtoolHook.emit("vuex:error", err);
        throw err;
      });
    } else {
      return res;
    }
  });
}
function registerGetter(store2, type, rawGetter, local) {
  if (store2._wrappedGetters[type]) {
    return;
  }
  store2._wrappedGetters[type] = function wrappedGetter(store3) {
    return rawGetter(local.state, local.getters, store3.state, store3.getters);
  };
}
function enableStrictMode(store2) {
  watch(function() {
    return store2._state.data;
  }, function() {
  }, { deep: true, flush: "sync" });
}
function getNestedState(state2, path) {
  return path.reduce(function(state3, key2) {
    return state3[key2];
  }, state2);
}
function unifyObjectStyle(type, payload, options) {
  if (isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }
  return { type, payload, options };
}
var LABEL_VUEX_BINDINGS = "vuex bindings";
var MUTATIONS_LAYER_ID = "vuex:mutations";
var ACTIONS_LAYER_ID = "vuex:actions";
var INSPECTOR_ID = "vuex";
var actionId = 0;
function addDevtools(app, store2) {
  setupDevtoolsPlugin({
    id: "org.vuejs.vuex",
    app,
    label: "Vuex",
    homepage: "https://next.vuex.vuejs.org/",
    logo: "https://vuejs.org/images/icons/favicon-96x96.png",
    packageName: "vuex",
    componentStateTypes: [LABEL_VUEX_BINDINGS]
  }, function(api) {
    api.addTimelineLayer({
      id: MUTATIONS_LAYER_ID,
      label: "Vuex Mutations",
      color: COLOR_LIME_500
    });
    api.addTimelineLayer({
      id: ACTIONS_LAYER_ID,
      label: "Vuex Actions",
      color: COLOR_LIME_500
    });
    api.addInspector({
      id: INSPECTOR_ID,
      label: "Vuex",
      icon: "storage",
      treeFilterPlaceholder: "Filter stores..."
    });
    api.on.getInspectorTree(function(payload) {
      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
        if (payload.filter) {
          var nodes = [];
          flattenStoreForInspectorTree(nodes, store2._modules.root, payload.filter, "");
          payload.rootNodes = nodes;
        } else {
          payload.rootNodes = [
            formatStoreForInspectorTree(store2._modules.root, "")
          ];
        }
      }
    });
    api.on.getInspectorState(function(payload) {
      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
        var modulePath = payload.nodeId;
        makeLocalGetters(store2, modulePath);
        payload.state = formatStoreForInspectorState(getStoreModule(store2._modules, modulePath), modulePath === "root" ? store2.getters : store2._makeLocalGettersCache, modulePath);
      }
    });
    api.on.editInspectorState(function(payload) {
      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
        var modulePath = payload.nodeId;
        var path = payload.path;
        if (modulePath !== "root") {
          path = modulePath.split("/").filter(Boolean).concat(path);
        }
        store2._withCommit(function() {
          payload.set(store2._state.data, path, payload.state.value);
        });
      }
    });
    store2.subscribe(function(mutation, state2) {
      var data2 = {};
      if (mutation.payload) {
        data2.payload = mutation.payload;
      }
      data2.state = state2;
      api.notifyComponentUpdate();
      api.sendInspectorTree(INSPECTOR_ID);
      api.sendInspectorState(INSPECTOR_ID);
      api.addTimelineEvent({
        layerId: MUTATIONS_LAYER_ID,
        event: {
          time: Date.now(),
          title: mutation.type,
          data: data2
        }
      });
    });
    store2.subscribeAction({
      before: function(action, state2) {
        var data2 = {};
        if (action.payload) {
          data2.payload = action.payload;
        }
        action._id = actionId++;
        action._time = Date.now();
        data2.state = state2;
        api.addTimelineEvent({
          layerId: ACTIONS_LAYER_ID,
          event: {
            time: action._time,
            title: action.type,
            groupId: action._id,
            subtitle: "start",
            data: data2
          }
        });
      },
      after: function(action, state2) {
        var data2 = {};
        var duration = Date.now() - action._time;
        data2.duration = {
          _custom: {
            type: "duration",
            display: duration + "ms",
            tooltip: "Action duration",
            value: duration
          }
        };
        if (action.payload) {
          data2.payload = action.payload;
        }
        data2.state = state2;
        api.addTimelineEvent({
          layerId: ACTIONS_LAYER_ID,
          event: {
            time: Date.now(),
            title: action.type,
            groupId: action._id,
            subtitle: "end",
            data: data2
          }
        });
      }
    });
  });
}
var COLOR_LIME_500 = 8702998;
var COLOR_DARK = 6710886;
var COLOR_WHITE = 16777215;
var TAG_NAMESPACED = {
  label: "namespaced",
  textColor: COLOR_WHITE,
  backgroundColor: COLOR_DARK
};
function extractNameFromPath(path) {
  return path && path !== "root" ? path.split("/").slice(-2, -1)[0] : "Root";
}
function formatStoreForInspectorTree(module, path) {
  return {
    id: path || "root",
    label: extractNameFromPath(path),
    tags: module.namespaced ? [TAG_NAMESPACED] : [],
    children: Object.keys(module._children).map(function(moduleName) {
      return formatStoreForInspectorTree(module._children[moduleName], path + moduleName + "/");
    })
  };
}
function flattenStoreForInspectorTree(result, module, filter, path) {
  if (path.includes(filter)) {
    result.push({
      id: path || "root",
      label: path.endsWith("/") ? path.slice(0, path.length - 1) : path || "Root",
      tags: module.namespaced ? [TAG_NAMESPACED] : []
    });
  }
  Object.keys(module._children).forEach(function(moduleName) {
    flattenStoreForInspectorTree(result, module._children[moduleName], filter, path + moduleName + "/");
  });
}
function formatStoreForInspectorState(module, getters2, path) {
  getters2 = path === "root" ? getters2 : getters2[path];
  var gettersKeys = Object.keys(getters2);
  var storeState = {
    state: Object.keys(module.state).map(function(key2) {
      return {
        key: key2,
        editable: true,
        value: module.state[key2]
      };
    })
  };
  if (gettersKeys.length) {
    var tree = transformPathsToObjectTree(getters2);
    storeState.getters = Object.keys(tree).map(function(key2) {
      return {
        key: key2.endsWith("/") ? extractNameFromPath(key2) : key2,
        editable: false,
        value: canThrow(function() {
          return tree[key2];
        })
      };
    });
  }
  return storeState;
}
function transformPathsToObjectTree(getters2) {
  var result = {};
  Object.keys(getters2).forEach(function(key2) {
    var path = key2.split("/");
    if (path.length > 1) {
      var target = result;
      var leafKey = path.pop();
      path.forEach(function(p2) {
        if (!target[p2]) {
          target[p2] = {
            _custom: {
              value: {},
              display: p2,
              tooltip: "Module",
              abstract: true
            }
          };
        }
        target = target[p2]._custom.value;
      });
      target[leafKey] = canThrow(function() {
        return getters2[key2];
      });
    } else {
      result[key2] = canThrow(function() {
        return getters2[key2];
      });
    }
  });
  return result;
}
function getStoreModule(moduleMap, path) {
  var names2 = path.split("/").filter(function(n2) {
    return n2;
  });
  return names2.reduce(function(module, moduleName, i2) {
    var child = module[moduleName];
    if (!child) {
      throw new Error('Missing module "' + moduleName + '" for path "' + path + '".');
    }
    return i2 === names2.length - 1 ? child : child._children;
  }, path === "root" ? moduleMap : moduleMap.root._children);
}
function canThrow(cb) {
  try {
    return cb();
  } catch (e2) {
    return e2;
  }
}
var Module = function Module2(rawModule, runtime) {
  this.runtime = runtime;
  this._children = /* @__PURE__ */ Object.create(null);
  this._rawModule = rawModule;
  var rawState = rawModule.state;
  this.state = (typeof rawState === "function" ? rawState() : rawState) || {};
};
var prototypeAccessors$1 = { namespaced: { configurable: true } };
prototypeAccessors$1.namespaced.get = function() {
  return !!this._rawModule.namespaced;
};
Module.prototype.addChild = function addChild(key2, module) {
  this._children[key2] = module;
};
Module.prototype.removeChild = function removeChild(key2) {
  delete this._children[key2];
};
Module.prototype.getChild = function getChild(key2) {
  return this._children[key2];
};
Module.prototype.hasChild = function hasChild(key2) {
  return key2 in this._children;
};
Module.prototype.update = function update5(rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};
Module.prototype.forEachChild = function forEachChild(fn) {
  forEachValue(this._children, fn);
};
Module.prototype.forEachGetter = function forEachGetter(fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};
Module.prototype.forEachAction = function forEachAction(fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};
Module.prototype.forEachMutation = function forEachMutation(fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};
Object.defineProperties(Module.prototype, prototypeAccessors$1);
var ModuleCollection = function ModuleCollection2(rawRootModule) {
  this.register([], rawRootModule, false);
};
ModuleCollection.prototype.get = function get2(path) {
  return path.reduce(function(module, key2) {
    return module.getChild(key2);
  }, this.root);
};
ModuleCollection.prototype.getNamespace = function getNamespace(path) {
  var module = this.root;
  return path.reduce(function(namespace, key2) {
    module = module.getChild(key2);
    return namespace + (module.namespaced ? key2 + "/" : "");
  }, "");
};
ModuleCollection.prototype.update = function update$1(rawRootModule) {
  update6([], this.root, rawRootModule);
};
ModuleCollection.prototype.register = function register(path, rawModule, runtime) {
  var this$1$1 = this;
  if (runtime === void 0)
    runtime = true;
  var newModule = new Module(rawModule, runtime);
  if (path.length === 0) {
    this.root = newModule;
  } else {
    var parent = this.get(path.slice(0, -1));
    parent.addChild(path[path.length - 1], newModule);
  }
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function(rawChildModule, key2) {
      this$1$1.register(path.concat(key2), rawChildModule, runtime);
    });
  }
};
ModuleCollection.prototype.unregister = function unregister(path) {
  var parent = this.get(path.slice(0, -1));
  var key2 = path[path.length - 1];
  var child = parent.getChild(key2);
  if (!child) {
    return;
  }
  if (!child.runtime) {
    return;
  }
  parent.removeChild(key2);
};
ModuleCollection.prototype.isRegistered = function isRegistered(path) {
  var parent = this.get(path.slice(0, -1));
  var key2 = path[path.length - 1];
  if (parent) {
    return parent.hasChild(key2);
  }
  return false;
};
function update6(path, targetModule, newModule) {
  targetModule.update(newModule);
  if (newModule.modules) {
    for (var key2 in newModule.modules) {
      if (!targetModule.getChild(key2)) {
        return;
      }
      update6(path.concat(key2), targetModule.getChild(key2), newModule.modules[key2]);
    }
  }
}
function createStore(options) {
  return new Store(options);
}
var Store = function Store2(options) {
  var this$1$1 = this;
  if (options === void 0)
    options = {};
  var plugins = options.plugins;
  if (plugins === void 0)
    plugins = [];
  var strict = options.strict;
  if (strict === void 0)
    strict = false;
  var devtools = options.devtools;
  this._committing = false;
  this._actions = /* @__PURE__ */ Object.create(null);
  this._actionSubscribers = [];
  this._mutations = /* @__PURE__ */ Object.create(null);
  this._wrappedGetters = /* @__PURE__ */ Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = /* @__PURE__ */ Object.create(null);
  this._subscribers = [];
  this._makeLocalGettersCache = /* @__PURE__ */ Object.create(null);
  this._devtools = devtools;
  var store2 = this;
  var ref2 = this;
  var dispatch2 = ref2.dispatch;
  var commit2 = ref2.commit;
  this.dispatch = function boundDispatch(type, payload) {
    return dispatch2.call(store2, type, payload);
  };
  this.commit = function boundCommit(type, payload, options2) {
    return commit2.call(store2, type, payload, options2);
  };
  this.strict = strict;
  var state2 = this._modules.root.state;
  installModule(this, state2, [], this._modules.root);
  resetStoreState(this, state2);
  plugins.forEach(function(plugin) {
    return plugin(this$1$1);
  });
};
var prototypeAccessors = { state: { configurable: true } };
Store.prototype.install = function install(app, injectKey) {
  app.provide(injectKey || storeKey, this);
  app.config.globalProperties.$store = this;
  var useDevtools = this._devtools !== void 0 ? this._devtools : false;
  if (useDevtools) {
    addDevtools(app, this);
  }
};
prototypeAccessors.state.get = function() {
  return this._state.data;
};
prototypeAccessors.state.set = function(v2) {
};
Store.prototype.commit = function commit(_type, _payload, _options) {
  var this$1$1 = this;
  var ref2 = unifyObjectStyle(_type, _payload, _options);
  var type = ref2.type;
  var payload = ref2.payload;
  var mutation = { type, payload };
  var entry = this._mutations[type];
  if (!entry) {
    return;
  }
  this._withCommit(function() {
    entry.forEach(function commitIterator(handler) {
      handler(payload);
    });
  });
  this._subscribers.slice().forEach(function(sub) {
    return sub(mutation, this$1$1.state);
  });
};
Store.prototype.dispatch = function dispatch(_type, _payload) {
  var this$1$1 = this;
  var ref2 = unifyObjectStyle(_type, _payload);
  var type = ref2.type;
  var payload = ref2.payload;
  var action = { type, payload };
  var entry = this._actions[type];
  if (!entry) {
    return;
  }
  try {
    this._actionSubscribers.slice().filter(function(sub) {
      return sub.before;
    }).forEach(function(sub) {
      return sub.before(action, this$1$1.state);
    });
  } catch (e2) {
  }
  var result = entry.length > 1 ? Promise.all(entry.map(function(handler) {
    return handler(payload);
  })) : entry[0](payload);
  return new Promise(function(resolve2, reject) {
    result.then(function(res) {
      try {
        this$1$1._actionSubscribers.filter(function(sub) {
          return sub.after;
        }).forEach(function(sub) {
          return sub.after(action, this$1$1.state);
        });
      } catch (e2) {
      }
      resolve2(res);
    }, function(error) {
      try {
        this$1$1._actionSubscribers.filter(function(sub) {
          return sub.error;
        }).forEach(function(sub) {
          return sub.error(action, this$1$1.state, error);
        });
      } catch (e2) {
      }
      reject(error);
    });
  });
};
Store.prototype.subscribe = function subscribe2(fn, options) {
  return genericSubscribe(fn, this._subscribers, options);
};
Store.prototype.subscribeAction = function subscribeAction(fn, options) {
  var subs = typeof fn === "function" ? { before: fn } : fn;
  return genericSubscribe(subs, this._actionSubscribers, options);
};
Store.prototype.watch = function watch$1(getter, cb, options) {
  var this$1$1 = this;
  return watch(function() {
    return getter(this$1$1.state, this$1$1.getters);
  }, cb, Object.assign({}, options));
};
Store.prototype.replaceState = function replaceState(state2) {
  var this$1$1 = this;
  this._withCommit(function() {
    this$1$1._state.data = state2;
  });
};
Store.prototype.registerModule = function registerModule(path, rawModule, options) {
  if (options === void 0)
    options = {};
  if (typeof path === "string") {
    path = [path];
  }
  this._modules.register(path, rawModule);
  installModule(this, this.state, path, this._modules.get(path), options.preserveState);
  resetStoreState(this, this.state);
};
Store.prototype.unregisterModule = function unregisterModule(path) {
  var this$1$1 = this;
  if (typeof path === "string") {
    path = [path];
  }
  this._modules.unregister(path);
  this._withCommit(function() {
    var parentState = getNestedState(this$1$1.state, path.slice(0, -1));
    delete parentState[path[path.length - 1]];
  });
  resetStore(this);
};
Store.prototype.hasModule = function hasModule(path) {
  if (typeof path === "string") {
    path = [path];
  }
  return this._modules.isRegistered(path);
};
Store.prototype.hotUpdate = function hotUpdate(newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
};
Store.prototype._withCommit = function _withCommit(fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};
Object.defineProperties(Store.prototype, prototypeAccessors);
const state = () => {
  return {
    open: false,
    apiKey: null,
    view: "LOADING",
    supportedChains: [],
    app: {
      id: null,
      name: null,
      attributionRequired: true
    },
    request: null,
    response: null,
    contractMetadata: null,
    wallets: [],
    provider: null,
    error: {
      code: null,
      message: null,
      fields: null,
      requestId: null
    }
  };
};
const getters = {
  open: (state2) => state2.open,
  apiKey: (state2) => state2.apiKey,
  view: (state2) => state2.view,
  app: (state2) => state2.app,
  contract: (state2) => state2.contract,
  contractMetadata: (state2) => state2.contractMetadata,
  provider: (state2) => state2.provider,
  attempt: (state2) => state2.attempt,
  error: (state2) => state2.error,
  walletHmac: (state2) => ({ chain, address }) => {
    return state2.wallets.filter((wallet) => {
      if (wallet.hmac.includes(":")) {
        const [exp2, hmac3] = wallet.hmac.split(":");
        return exp2 > Math.floor(Date.now() / 1e3);
      }
      return true;
    }).find((wallet) => {
      return wallet.chain === chain && wallet.address === address;
    });
  },
  contractLink: ({ contractMetadata: contractMetadata2 }) => {
    var _a;
    if ((_a = contractMetadata2.listing) == null ? void 0 : _a.url) {
      return contractMetadata2.listing.url;
    }
    const link = contractMetadata2.socials.find(({ type }) => type === "WEB");
    if (link)
      return link.url;
  },
  request: (state2) => state2.request,
  response: (state2) => state2.response
};
const actions = {
  initialize({ commit: commit2 }, { apiKey, providers }) {
    const supportedChains = providers.map((provider) => provider.supportedChains).flat().filter(function(item, pos, self2) {
      return self2.indexOf(item) === pos;
    });
    commit2("SET_API_KEY", apiKey);
    commit2("SET_SUPPORTED_CHAINS", supportedChains);
  },
  reset({ commit: commit2 }) {
    commit2("SET_RESPONSE", null);
    commit2("SET_VIEW", "START");
  },
  handleError({ commit: commit2 }, err) {
    console.error(err);
    commit2("SET_VIEW", "ERROR");
    switch (err.name) {
      case "BadRequestError":
        commit2("SET_ERROR", {
          code: "BAD_REQUEST",
          message: err.message,
          fields: err.fields,
          requestId: err.requestId
        });
        break;
      case "InvalidCredentialsError":
        commit2("SET_ERROR", {
          code: "BAD_CREDENTIALS",
          message: err.message,
          requestId: err.requestId
        });
        break;
      case "InternalServerError":
        commit2("SET_ERROR", {
          code: "SERVER_ERROR",
          message: err.message,
          requestId: err.requestId
        });
        break;
      case "RateLimitedError":
        commit2("SET_ERROR", {
          code: "SERVER_ERROR",
          message: err.message,
          requestId: err.requestId
        });
        commit2("SET_VIEW", "RATE_LIMITED");
        break;
      case "NetworkError":
        commit2("SET_ERROR", { code: "NETWORK" });
        break;
      case "UserRejectedRequestError":
        commit2("SET_ERROR", { code: "CONNECTION_DENIED" });
        break;
      case "UnsupportedChainError":
        commit2("SET_ERROR", { code: "CHAIN_INVALID" });
        break;
      default:
        commit2("SET_ERROR", { code: "UNKNOWN", message: err.message });
        break;
    }
  },
  async startRequest({ commit: commit2, dispatch: dispatch2 }, config2) {
    var _a, _b;
    commit2("SET_REQUEST", config2);
    commit2("SET_RESPONSE", null);
    await dispatch2("getContractMetadata", {
      chain: config2.chain,
      network: config2.network,
      contract: config2.contract,
      marketplace: config2.marketplace,
      externalImages: {
        avatarImage: (_a = config2.metadata) == null ? void 0 : _a.avatarImage,
        bannerImage: (_b = config2.metadata) == null ? void 0 : _b.bannerImage
      }
    });
  },
  async getContractMetadata({ commit: commit2, dispatch: dispatch2, getters: getters2 }, config2) {
    try {
      const { data: _metadata } = await contractMetadata(config2);
      const metadata = __spreadValues({}, _metadata);
      if (getters2.request.metadata) {
        const { name, socials } = getters2.request.metadata;
        metadata.name = name || metadata.name;
        metadata.socials = socials || metadata.socials;
      }
      commit2("SET_VIEW", "START");
      commit2("METADATA_LOADED", metadata);
    } catch (err) {
      return dispatch2("handleError", err);
    }
  },
  async connectWallet({ commit: commit2, dispatch: dispatch2, getters: getters2 }, walletName) {
    const { chain, network } = getters2.request;
    commit2("SET_VIEW", "CONNECTING");
    try {
      Wallet$1.setActive(walletName);
      await Wallet$1.connect(chain, network);
      commit2("WALLET_CONNECTED");
    } catch (err) {
      return dispatch2("handleError", err);
    }
    const address = await Wallet$1.getAddress();
    const cachedResult = getters2.walletHmac({ chain, address });
    if (cachedResult) {
      commit2("NONCE_VERIFIED", cachedResult);
      return cachedResult;
    }
    const { data: data2 } = await createNonce({ chain, address });
    commit2("SET_VIEW", "SIGNING");
    let signature2;
    try {
      signature2 = await Wallet$1.sign(data2.nonce);
    } catch (err) {
      dispatch2("handleError", err);
      return;
    }
    await dispatch2("verifyNonce", { nonce: data2.nonce, signature: signature2 });
  },
  async verifyNonce({ commit: commit2, dispatch: dispatch2 }, { nonce, signature: signature2 }) {
    try {
      const { data: nonceResult } = await verifyNonce({ nonce, signature: signature2 });
      commit2("NONCE_VERIFIED", nonceResult);
      return nonceResult;
    } catch (err) {
      dispatch2("handleError", err);
    }
  },
  async verifyNft({ commit: commit2, dispatch: dispatch2, getters: getters2 }, wallet) {
    commit2("SET_VIEW", "VERIFYING");
    try {
      const { data: attempt } = await verifyNFT(__spreadProps(__spreadValues({}, getters2.request), {
        wallet: {
          address: wallet.address,
          hmac: wallet.hmac
        }
      }));
      commit2("SET_VIEW", attempt.result.ownership ? "SUCCESS" : "FAILED");
      commit2("SET_RESPONSE", attempt);
      return attempt;
    } catch (err) {
      dispatch2("handleError", err);
    }
  }
};
const mutations = {
  SET_API_KEY(state2, apiKey) {
    state2.apiKey = apiKey;
  },
  SET_SUPPORTED_CHAINS(state2, chains2) {
    state2.supportedChains = chains2;
  },
  SET_VIEW(state2, view) {
    state2.view = view;
  },
  SET_ERROR(state2, { code: code2, message, fields, requestId }) {
    state2.error = { code: code2, message, fields, requestId };
  },
  SET_REQUEST(state2, request2) {
    state2.request = request2;
  },
  SET_RESPONSE(state2, response) {
    state2.response = response;
  },
  SHOW_MODAL(state2) {
    state2.attempt = null;
    state2.error = null;
    state2.open = true;
  },
  CLOSE_MODAL(state2) {
    state2.open = false;
  },
  METADATA_LOADED(state2, _a) {
    var _b = _a, { app } = _b, metadata = __objRest(_b, ["app"]);
    state2.app = app;
    state2.contractMetadata = metadata;
  },
  WALLET_CONNECTED(state2, provider) {
    state2.provider = provider;
  },
  NONCE_VERIFIED(state2, result) {
    const idx = state2.wallets.findIndex(({ address, chain }) => address === result.address && chain === result.chain);
    if (idx === -1) {
      state2.wallets.push(result);
    } else {
      state2.wallets[idx] = result;
    }
  }
};
const store = createStore({
  state,
  getters,
  actions,
  mutations
});
let client;
const setupClient = (endpoint = "https://dmnd.network/verify/v1") => {
  client = axios.create({ baseURL: endpoint });
  client.interceptors.request.use((request2) => {
    request2.headers["X-Api-Key"] = store.getters.apiKey;
    return request2;
  }, function(err) {
    return Promise.reject(err);
  });
  client.interceptors.response.use((response) => response, (err) => {
    var _a;
    if (err.message === "Network Error") {
      return Promise.reject(new NetworkError());
    }
    switch ((_a = err.response) == null ? void 0 : _a.status) {
      case 400:
        return Promise.reject(new BadRequestError(err.response.data));
      case 401:
        return Promise.reject(new InvalidCredentialsError(err.response.data));
      case 429:
        return Promise.reject(new RateLimitedError(err.response.data));
      case 500:
        return Promise.reject(new InternalServerError(err.response.data));
      default:
        return Promise.reject(new InternalServerError(err.response.data));
    }
  });
};
const contractMetadata = async (_c) => {
  var _d = _c, { chain, network, contract } = _d, additionalArgs = __objRest(_d, ["chain", "network", "contract"]);
  return client.post("/contract/info", __spreadValues({
    chain,
    network,
    contract
  }, additionalArgs));
};
const createNonce = async ({ chain, address }) => {
  return client.post("/address/nonce", {
    chain,
    address
  });
};
const verifyNonce = async ({ nonce, signature: signature2 }) => {
  return client.post("/address/verify", {
    nonce,
    signature: signature2
  });
};
const verifyNFT = async (_e) => {
  var _f = _e, { chain, network, contract, unlockables, wallet, user } = _f, additionalArgs = __objRest(_f, ["chain", "network", "contract", "unlockables", "wallet", "user"]);
  return client.post("/asset/nft", __spreadValues({
    chain,
    network,
    contract,
    unlockables,
    wallet,
    user
  }, additionalArgs));
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].includes(getBasePlacement(placement)) ? "x" : "y";
}
function getLengthFromAxis(axis) {
  return axis === "y" ? "height" : "width";
}
function computeCoordsFromPlacement(_ref) {
  let {
    reference,
    floating,
    placement
  } = _ref;
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  let coords;
  switch (getBasePlacement(placement)) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  switch (getAlignment(placement)) {
    case "start":
      coords[mainAxis] = coords[mainAxis] - (reference[length] / 2 - floating[length] / 2);
      break;
    case "end":
      coords[mainAxis] = coords[mainAxis] + (reference[length] / 2 - floating[length] / 2);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config2;
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(__spreadProps(__spreadValues({}, rects), {
    placement
  }));
  let statefulPlacement = placement;
  let middlewareData = {};
  for (let i2 = 0; i2 < middleware.length; i2++) {
    const {
      name,
      fn
    } = middleware[i2];
    const {
      x: nextX,
      y: nextY,
      data: data2,
      reset: reset2
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = __spreadProps(__spreadValues({}, middlewareData), {
      [name]: data2 != null ? data2 : {}
    });
    if (reset2) {
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(__spreadProps(__spreadValues({}, rects), {
          placement: statefulPlacement
        })));
      }
      i2 = -1;
      continue;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
function expandPaddingObject(padding2) {
  return __spreadValues({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, padding2);
}
function getSideObjectFromPadding(padding2) {
  return typeof padding2 !== "number" ? expandPaddingObject(padding2) : {
    top: padding2,
    right: padding2,
    bottom: padding2,
    left: padding2
  };
}
function rectToClientRect(rect) {
  return __spreadProps(__spreadValues({}, rect), {
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
async function detectOverflow(middlewareArguments, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = middlewareArguments;
  const {
    boundary = "clippingParents",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding: padding2 = 0
  } = options;
  const paddingObject = getSideObjectFromPadding(padding2);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = await platform2.getClippingClientRect({
    element: await platform2.isElement(element) ? element : element.contextElement || await platform2.getDocumentElement({
      element: elements.floating
    }),
    boundary,
    rootBoundary
  });
  const elementClientRect = rectToClientRect(await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: elementContext === "floating" ? __spreadProps(__spreadValues({}, rects.floating), {
      x: x2,
      y: y2
    }) : rects.reference,
    offsetParent: await platform2.getOffsetParent({
      element: elements.floating
    }),
    strategy
  }));
  return {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
}
const min$1 = Math.min;
const max$1 = Math.max;
function within(min$1$1, value, max$1$1) {
  return max$1(min$1$1, min$1(value, max$1$1));
}
const arrow = (options) => ({
  name: "arrow",
  options,
  async fn(middlewareArguments) {
    const {
      element,
      padding: padding2 = 0
    } = options != null ? options : {};
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2
    } = middlewareArguments;
    if (element == null) {
      return {};
    }
    const paddingObject = getSideObjectFromPadding(padding2);
    const coords = {
      x: x2,
      y: y2
    };
    const basePlacement = getBasePlacement(placement);
    const axis = getMainAxisFromPlacement(basePlacement);
    const length = getLengthFromAxis(axis);
    const arrowDimensions = await platform2.getDimensions({
      element
    });
    const minProp = axis === "y" ? "top" : "left";
    const maxProp = axis === "y" ? "bottom" : "right";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await platform2.getOffsetParent({
      element
    });
    const clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    const centerToReference = endDiff / 2 - startDiff / 2;
    const min2 = paddingObject[minProp];
    const max2 = clientSize - arrowDimensions[length] - paddingObject[maxProp];
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = within(min2, center, max2);
    return {
      data: {
        [axis]: offset2,
        centerOffset: center - offset2
      }
    };
  }
});
const hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (matched) => hash$1[matched]);
}
function getAlignmentSides(placement, rects) {
  const isStart = getAlignment(placement) === "start";
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === "x" ? isStart ? "right" : "left" : isStart ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}
const hash = {
  start: "end",
  end: "start"
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (matched) => hash[matched]);
}
const basePlacements = ["top", "right", "bottom", "left"];
const allPlacements = /* @__PURE__ */ basePlacements.reduce((acc, basePlacement) => acc.concat(basePlacement, basePlacement + "-start", basePlacement + "-end"), []);
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getBasePlacement(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter((placement) => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
const autoPlacement = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "autoPlacement",
    options,
    async fn(middlewareArguments) {
      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _middlewareData$autoP5, _placementsSortedByLe;
      const {
        x: x2,
        y: y2,
        rects,
        middlewareData,
        placement
      } = middlewareArguments;
      const _a = options, {
        alignment = null,
        allowedPlacements = allPlacements,
        autoAlignment = true
      } = _a, detectOverflowOptions = __objRest(_a, [
        "alignment",
        "allowedPlacements",
        "autoAlignment"
      ]);
      if ((_middlewareData$autoP = middlewareData.autoPlacement) != null && _middlewareData$autoP.skip) {
        return {};
      }
      const placements2 = getPlacementList(alignment, autoAlignment, allowedPlacements);
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const currentIndex = (_middlewareData$autoP2 = (_middlewareData$autoP3 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP3.index) != null ? _middlewareData$autoP2 : 0;
      const currentPlacement = placements2[currentIndex];
      const {
        main,
        cross
      } = getAlignmentSides(currentPlacement, rects);
      if (placement !== currentPlacement) {
        return {
          x: x2,
          y: y2,
          reset: {
            placement: placements2[0]
          }
        };
      }
      const currentOverflows = [overflow[getBasePlacement(currentPlacement)], overflow[main], overflow[cross]];
      const allOverflows = [...(_middlewareData$autoP4 = (_middlewareData$autoP5 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP5.overflows) != null ? _middlewareData$autoP4 : [], {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements2[currentIndex + 1];
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a2, b2) => a2.overflows[0] - b2.overflows[0]);
      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find((_ref) => {
        let {
          overflows
        } = _ref;
        return overflows.every((overflow2) => overflow2 <= 0);
      })) == null ? void 0 : _placementsSortedByLe.placement;
      return {
        data: {
          skip: true
        },
        reset: {
          placement: placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement
        }
      };
    }
  };
};
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
const flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(middlewareArguments) {
      var _middlewareData$flip, _middlewareData$flip2;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement
      } = middlewareArguments;
      if ((_middlewareData$flip = middlewareData.flip) != null && _middlewareData$flip.skip) {
        return {};
      }
      const _a = options, {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        flipAlignment = true
      } = _a, detectOverflowOptions = __objRest(_a, [
        "mainAxis",
        "crossAxis",
        "fallbackPlacements",
        "fallbackStrategy",
        "flipAlignment"
      ]);
      const basePlacement = getBasePlacement(placement);
      const isBasePlacement = basePlacement === initialPlacement;
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[basePlacement]);
      }
      if (checkCrossAxis) {
        const {
          main,
          cross
        } = getAlignmentSides(placement, rects);
        overflows.push(overflow[main], overflow[cross]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side) => side <= 0)) {
        var _middlewareData$flip$, _middlewareData$flip3;
        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip3 = middlewareData.flip) == null ? void 0 : _middlewareData$flip3.index) != null ? _middlewareData$flip$ : 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = "bottom";
        switch (fallbackStrategy) {
          case "bestFit": {
            var _overflowsData$slice$;
            const placement2 = (_overflowsData$slice$ = overflowsData.slice().sort((a2, b2) => a2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0) - b2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0))[0]) == null ? void 0 : _overflowsData$slice$.placement;
            if (placement2) {
              resetPlacement = placement2;
            }
            break;
          }
          case "initialPlacement":
            resetPlacement = initialPlacement;
            break;
        }
        return {
          data: {
            skip: true
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};
function convertValueToCoords(_ref) {
  let {
    placement,
    rects,
    value
  } = _ref;
  const basePlacement = getBasePlacement(placement);
  const multiplier = ["left", "top"].includes(basePlacement) ? -1 : 1;
  const rawValue = typeof value === "function" ? value(__spreadProps(__spreadValues({}, rects), {
    placement
  })) : value;
  const {
    mainAxis,
    crossAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0
  } : __spreadValues({
    mainAxis: 0,
    crossAxis: 0
  }, rawValue);
  return getMainAxisFromPlacement(basePlacement) === "x" ? {
    x: crossAxis,
    y: mainAxis * multiplier
  } : {
    x: mainAxis * multiplier,
    y: crossAxis
  };
}
const offset = function(value) {
  if (value === void 0) {
    value = 0;
  }
  return {
    name: "offset",
    options: value,
    fn(middlewareArguments) {
      const {
        x: x2,
        y: y2,
        placement,
        rects
      } = middlewareArguments;
      const diffCoords = convertValueToCoords({
        placement,
        rects,
        value
      });
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
function getCrossAxis(axis) {
  return axis === "x" ? "y" : "x";
}
const shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(middlewareArguments) {
      const {
        x: x2,
        y: y2,
        placement
      } = middlewareArguments;
      const _a = options, {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        }
      } = _a, detectOverflowOptions = __objRest(_a, [
        "mainAxis",
        "crossAxis",
        "limiter"
      ]);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement(getBasePlacement(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn(__spreadProps(__spreadValues({}, middlewareArguments), {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      }));
      return __spreadProps(__spreadValues({}, limitedCoords), {
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2
        }
      });
    }
  };
};
const size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(middlewareArguments) {
      var _middlewareData$size;
      const {
        placement,
        rects,
        middlewareData
      } = middlewareArguments;
      const _a = options, {
        apply
      } = _a, detectOverflowOptions = __objRest(_a, [
        "apply"
      ]);
      if ((_middlewareData$size = middlewareData.size) != null && _middlewareData$size.skip) {
        return {};
      }
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const basePlacement = getBasePlacement(placement);
      const isEnd = getAlignment(placement) === "end";
      let heightSide;
      let widthSide;
      if (basePlacement === "top" || basePlacement === "bottom") {
        heightSide = basePlacement;
        widthSide = isEnd ? "left" : "right";
      } else {
        widthSide = basePlacement;
        heightSide = isEnd ? "top" : "bottom";
      }
      const xMin = max$1(overflow.left, 0);
      const xMax = max$1(overflow.right, 0);
      const yMin = max$1(overflow.top, 0);
      const yMax = max$1(overflow.bottom, 0);
      const dimensions = {
        height: rects.floating.height - (["left", "right"].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max$1(overflow.top, overflow.bottom)) : overflow[heightSide]),
        width: rects.floating.width - (["top", "bottom"].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max$1(overflow.left, overflow.right)) : overflow[widthSide])
      };
      apply == null ? void 0 : apply(__spreadValues(__spreadValues({}, dimensions), rects));
      return {
        data: {
          skip: true
        },
        reset: {
          rects: true
        }
      };
    }
  };
};
function isWindow(value) {
  return (value == null ? void 0 : value.toString()) === "[object Window]";
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (!isWindow(node)) {
    const ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeName(node) {
  return isWindow(node) ? "" : node ? (node.nodeName || "").toLowerCase() : "";
}
function isHTMLElement(value) {
  return value instanceof getWindow(value).HTMLElement;
}
function isElement(value) {
  return value instanceof getWindow(value).Element;
}
function isNode(value) {
  return value instanceof getWindow(value).Node;
}
function isShadowRoot(node) {
  const OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isScrollParent(element) {
  const {
    overflow,
    overflowX,
    overflowY
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const isFirefox = navigator.userAgent.toLowerCase().includes("firefox");
  const css = getComputedStyle$1(element);
  return css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].includes(css.willChange) || isFirefox && css.willChange === "filter" || isFirefox && (css.filter ? css.filter !== "none" : false);
}
const min = Math.min;
const max = Math.max;
const round = Math.round;
function getBoundingClientRect(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  const clientRect = element.getBoundingClientRect();
  let scaleX = 1;
  let scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  return {
    width: clientRect.width / scaleX,
    height: clientRect.height / scaleY,
    top: clientRect.top / scaleY,
    right: clientRect.right / scaleX,
    bottom: clientRect.bottom / scaleY,
    left: clientRect.left / scaleX,
    x: clientRect.left / scaleX,
    y: clientRect.top / scaleY
  };
}
function getDocumentElement(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}
function getNodeScroll(element) {
  if (isWindow(element)) {
    return {
      scrollLeft: element.pageXOffset,
      scrollTop: element.pageYOffset
    };
  }
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function isScaled(element) {
  const rect = getBoundingClientRect(element);
  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const rect = getBoundingClientRect(element, isOffsetParentAnElement && isScaled(offsetParent));
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  return node.assignedSlot || node.parentNode || (isShadowRoot(node) ? node.host : null) || getDocumentElement(node);
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !["html", "body"].includes(getNodeName(currentNode))) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  const window2 = getWindow(element);
  let offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getDimensions(element) {
  return {
    width: element.offsetWidth,
    height: element.offsetHeight
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return __spreadProps(__spreadValues({}, rect), {
    x: rect.x - scroll.scrollLeft + offsets.x,
    y: rect.y - scroll.scrollTop + offsets.y
  });
}
function getViewportRect(element) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) < 0.01) {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getScrollParent(node) {
  if (["html", "body", "#document"].includes(getNodeName(node))) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
function getScrollParents(node, list) {
  var _node$ownerDocument;
  if (list === void 0) {
    list = [];
  }
  const scrollParent = getScrollParent(node);
  const isBody = scrollParent === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow(scrollParent);
  const target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  const updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(getScrollParents(getParentNode(target)));
}
function contains(parent, child) {
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    do {
      if (next && parent === next) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getInnerBoundingClientRect(element) {
  const clientRect = getBoundingClientRect(element);
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  return {
    top,
    left,
    x: left,
    y: top,
    right: left + element.clientWidth,
    bottom: top + element.clientHeight,
    width: element.clientWidth,
    height: element.clientHeight
  };
}
function getClientRectFromClippingParent(element, clippingParent) {
  if (clippingParent === "viewport") {
    return rectToClientRect(getViewportRect(element));
  }
  if (isElement(clippingParent)) {
    return getInnerBoundingClientRect(clippingParent);
  }
  return rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  const clippingParents = getScrollParents(getParentNode(element));
  const canEscapeClipping = ["absolute", "fixed"].includes(getComputedStyle$1(element).position);
  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents.filter((clippingParent) => isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body");
}
function getClippingClientRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary
  } = _ref;
  const mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  const clippingParents = [...mainClippingParents, rootBoundary];
  const firstClippingParent = clippingParents[0];
  const clippingRect = clippingParents.reduce((accRect, clippingParent) => {
    const rect = getClientRectFromClippingParent(element, clippingParent);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingParent(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
const platform = {
  getElementRects: (_ref) => {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    return {
      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),
      floating: __spreadProps(__spreadValues({}, getDimensions(floating)), {
        x: 0,
        y: 0
      })
    };
  },
  convertOffsetParentRelativeRectToViewportRelativeRect: (args) => convertOffsetParentRelativeRectToViewportRelativeRect(args),
  getOffsetParent: (_ref2) => {
    let {
      element
    } = _ref2;
    return getOffsetParent(element);
  },
  isElement: (value) => isElement(value),
  getDocumentElement: (_ref3) => {
    let {
      element
    } = _ref3;
    return getDocumentElement(element);
  },
  getClippingClientRect: (args) => getClippingClientRect(args),
  getDimensions: (_ref4) => {
    let {
      element
    } = _ref4;
    return getDimensions(element);
  },
  getClientRects: (_ref5) => {
    let {
      element
    } = _ref5;
    return element.getClientRects();
  }
};
const computePosition = (reference, floating, options) => computePosition$1(reference, floating, __spreadValues({
  platform
}, options));
var __defProp2 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key2, value) => key2 in obj ? __defProp2(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues2 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp2.call(b2, prop))
      __defNormalProp2(a2, prop, b2[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b2)) {
      if (__propIsEnum2.call(b2, prop))
        __defNormalProp2(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps2 = (a2, b2) => __defProps2(a2, __getOwnPropDescs2(b2));
const config = {
  disabled: false,
  distance: 5,
  skidding: 0,
  container: "body",
  boundary: void 0,
  instantMove: false,
  disposeTimeout: 5e3,
  popperTriggers: [],
  strategy: "absolute",
  preventOverflow: true,
  flip: true,
  shift: true,
  overflowPadding: 0,
  arrowPadding: 0,
  arrowOverflow: true,
  themes: {
    tooltip: {
      placement: "top",
      triggers: ["hover", "focus", "touch"],
      hideTriggers: (events2) => [...events2, "click"],
      delay: {
        show: 200,
        hide: 0
      },
      handleResize: false,
      html: false,
      loadingContent: "..."
    },
    dropdown: {
      placement: "bottom",
      triggers: ["click"],
      delay: 0,
      handleResize: true,
      autoHide: true
    },
    menu: {
      $extend: "dropdown",
      triggers: ["hover", "focus"],
      popperTriggers: ["hover", "focus"],
      delay: {
        show: 0,
        hide: 400
      }
    }
  }
};
function getDefaultConfig(theme, key2) {
  let themeConfig = config.themes[theme] || {};
  let value;
  do {
    value = themeConfig[key2];
    if (typeof value === "undefined") {
      if (themeConfig.$extend) {
        themeConfig = config.themes[themeConfig.$extend] || {};
      } else {
        themeConfig = null;
        value = config[key2];
      }
    } else {
      themeConfig = null;
    }
  } while (themeConfig);
  return value;
}
function getThemeClasses(theme) {
  const result = [theme];
  let themeConfig = config.themes[theme] || {};
  do {
    if (themeConfig.$extend && !themeConfig.$resetCss) {
      result.push(themeConfig.$extend);
      themeConfig = config.themes[themeConfig.$extend] || {};
    } else {
      themeConfig = null;
    }
  } while (themeConfig);
  return result.map((c2) => `v-popper--theme-${c2}`);
}
let supportsPassive = false;
if (typeof window !== "undefined") {
  supportsPassive = false;
  try {
    const opts = Object.defineProperty({}, "passive", {
      get() {
        supportsPassive = true;
      }
    });
    window.addEventListener("test", null, opts);
  } catch (e2) {
  }
}
let isIOS = false;
if (typeof window !== "undefined" && typeof navigator !== "undefined") {
  isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
}
const placements = ["auto", "top", "bottom", "left", "right"].reduce((acc, base2) => acc.concat([
  base2,
  `${base2}-start`,
  `${base2}-end`
]), []);
const SHOW_EVENT_MAP = {
  hover: "mouseenter",
  focus: "focus",
  click: "click",
  touch: "touchstart"
};
const HIDE_EVENT_MAP = {
  hover: "mouseleave",
  focus: "blur",
  click: "click",
  touch: "touchend"
};
function removeFromArray(array, item) {
  const index2 = array.indexOf(item);
  if (index2 !== -1) {
    array.splice(index2, 1);
  }
}
function nextFrame() {
  return new Promise((resolve2) => requestAnimationFrame(() => {
    requestAnimationFrame(resolve2);
  }));
}
const shownPoppers = [];
let hidingPopper = null;
let Element$1 = function() {
};
if (typeof window !== "undefined") {
  Element$1 = window.Element;
}
function defaultPropFactory(prop) {
  return function(props) {
    return getDefaultConfig(props.theme, prop);
  };
}
var PrivatePopper = () => defineComponent({
  name: "VPopper",
  props: {
    theme: {
      type: String,
      required: true
    },
    targetNodes: {
      type: Function,
      required: true
    },
    referenceNode: {
      type: Function,
      required: true
    },
    popperNode: {
      type: Function,
      required: true
    },
    shown: {
      type: Boolean,
      default: false
    },
    showGroup: {
      type: String,
      default: null
    },
    ariaId: {
      default: null
    },
    disabled: {
      type: Boolean,
      default: defaultPropFactory("disabled")
    },
    positioningDisabled: {
      type: Boolean,
      default: defaultPropFactory("positioningDisabled")
    },
    placement: {
      type: String,
      default: defaultPropFactory("placement"),
      validator: (value) => placements.includes(value)
    },
    delay: {
      type: [String, Number, Object],
      default: defaultPropFactory("delay")
    },
    distance: {
      type: [Number, String],
      default: defaultPropFactory("distance")
    },
    skidding: {
      type: [Number, String],
      default: defaultPropFactory("skidding")
    },
    triggers: {
      type: Array,
      default: defaultPropFactory("triggers")
    },
    showTriggers: {
      type: [Array, Function],
      default: defaultPropFactory("showTriggers")
    },
    hideTriggers: {
      type: [Array, Function],
      default: defaultPropFactory("hideTriggers")
    },
    popperTriggers: {
      type: Array,
      default: defaultPropFactory("popperTriggers")
    },
    popperShowTriggers: {
      type: [Array, Function],
      default: defaultPropFactory("popperShowTriggers")
    },
    popperHideTriggers: {
      type: [Array, Function],
      default: defaultPropFactory("popperHideTriggers")
    },
    container: {
      type: [String, Object, Element$1, Boolean],
      default: defaultPropFactory("container")
    },
    boundary: {
      type: [String, Element$1],
      default: defaultPropFactory("boundary")
    },
    strategy: {
      type: String,
      validator: (value) => ["absolute", "fixed"].includes(value),
      default: defaultPropFactory("strategy")
    },
    autoHide: {
      type: Boolean,
      default: defaultPropFactory("autoHide")
    },
    handleResize: {
      type: Boolean,
      default: defaultPropFactory("handleResize")
    },
    instantMove: {
      type: Boolean,
      default: defaultPropFactory("instantMove")
    },
    eagerMount: {
      type: Boolean,
      default: defaultPropFactory("eagerMount")
    },
    popperClass: {
      type: [String, Array, Object],
      default: defaultPropFactory("popperClass")
    },
    computeTransformOrigin: {
      type: Boolean,
      default: defaultPropFactory("computeTransformOrigin")
    },
    autoMinSize: {
      type: Boolean,
      default: defaultPropFactory("autoMinSize")
    },
    autoSize: {
      type: [Boolean, String],
      default: defaultPropFactory("autoSize")
    },
    autoMaxSize: {
      type: Boolean,
      default: defaultPropFactory("autoMaxSize")
    },
    autoBoundaryMaxSize: {
      type: Boolean,
      default: defaultPropFactory("autoBoundaryMaxSize")
    },
    preventOverflow: {
      type: Boolean,
      default: defaultPropFactory("preventOverflow")
    },
    overflowPadding: {
      type: [Number, String],
      default: defaultPropFactory("overflowPadding")
    },
    arrowPadding: {
      type: [Number, String],
      default: defaultPropFactory("arrowPadding")
    },
    arrowOverflow: {
      type: Boolean,
      default: defaultPropFactory("arrowOverflow")
    },
    flip: {
      type: Boolean,
      default: defaultPropFactory("flip")
    },
    shift: {
      type: Boolean,
      default: defaultPropFactory("shift")
    },
    shiftCrossAxis: {
      type: Boolean,
      default: defaultPropFactory("shiftCrossAxis")
    }
  },
  emits: [
    "show",
    "hide",
    "update:shown",
    "apply-show",
    "apply-hide",
    "close-group",
    "close-directive",
    "auto-hide",
    "resize",
    "dispose"
  ],
  data() {
    return {
      isShown: false,
      isMounted: false,
      skipTransition: false,
      classes: {
        showFrom: false,
        showTo: false,
        hideFrom: false,
        hideTo: true
      },
      result: {
        x: 0,
        y: 0,
        placement: "",
        strategy: this.strategy,
        arrow: {
          x: 0,
          y: 0,
          centerOffset: 0
        },
        transformOrigin: null
      }
    };
  },
  computed: {
    popperId() {
      return this.ariaId != null ? this.ariaId : this.randomId;
    },
    shouldMountContent() {
      return this.eagerMount || this.isMounted;
    },
    slotData() {
      return {
        popperId: this.popperId,
        isShown: this.isShown,
        shouldMountContent: this.shouldMountContent,
        skipTransition: this.skipTransition,
        autoHide: this.autoHide,
        show: this.show,
        hide: this.hide,
        handleResize: this.handleResize,
        onResize: this.onResize,
        classes: __spreadProps2(__spreadValues2({}, this.classes), {
          popperClass: this.popperClass
        }),
        result: this.positioningDisabled ? null : this.result
      };
    }
  },
  watch: __spreadValues2(__spreadValues2({
    shown: "$_autoShowHide",
    disabled(value) {
      if (value) {
        this.dispose();
      } else {
        this.init();
      }
    },
    async container() {
      if (this.isShown) {
        this.$_ensureTeleport();
        await this.$_computePosition();
      }
    }
  }, [
    "triggers",
    "positioningDisabled"
  ].reduce((acc, prop) => {
    acc[prop] = "$_refreshListeners";
    return acc;
  }, {})), [
    "placement",
    "distance",
    "skidding",
    "boundary",
    "strategy",
    "overflowPadding",
    "arrowPadding",
    "preventOverflow",
    "shift",
    "shiftCrossAxis",
    "flip"
  ].reduce((acc, prop) => {
    acc[prop] = "$_computePosition";
    return acc;
  }, {})),
  created() {
    this.$_isDisposed = true;
    this.randomId = `popper_${[Math.random(), Date.now()].map((n2) => n2.toString(36).substring(2, 10)).join("_")}`;
    if (this.autoMinSize) {
      console.warn('[floating-vue] `autoMinSize` option is deprecated. Use `autoSize="min"` instead.');
    }
    if (this.autoMaxSize) {
      console.warn("[floating-vue] `autoMaxSize` option is deprecated. Use `autoBoundaryMaxSize` instead.");
    }
  },
  mounted() {
    this.init();
    this.$_detachPopperNode();
  },
  activated() {
    this.$_autoShowHide();
  },
  deactivated() {
    this.hide();
  },
  beforeUnmount() {
    this.dispose();
  },
  methods: {
    show({ event = null, skipDelay = false, force = false } = {}) {
      if (force || !this.disabled) {
        this.$_scheduleShow(event, skipDelay);
        this.$emit("show");
        this.$_showFrameLocked = true;
        requestAnimationFrame(() => {
          this.$_showFrameLocked = false;
        });
      }
      this.$emit("update:shown", true);
    },
    hide({ event = null, skipDelay = false } = {}) {
      if (this.$_hideInProgress)
        return;
      this.$_scheduleHide(event, skipDelay);
      this.$emit("hide");
      this.$emit("update:shown", false);
    },
    init() {
      if (!this.$_isDisposed)
        return;
      this.$_isDisposed = false;
      this.isMounted = false;
      this.$_events = [];
      this.$_preventShow = false;
      this.$_referenceNode = this.referenceNode();
      this.$_targetNodes = this.targetNodes().filter((e2) => e2.nodeType === e2.ELEMENT_NODE);
      this.$_popperNode = this.popperNode();
      this.$_innerNode = this.$_popperNode.querySelector(".v-popper__inner");
      this.$_arrowNode = this.$_popperNode.querySelector(".v-popper__arrow-container");
      this.$_swapTargetAttrs("title", "data-original-title");
      this.$_detachPopperNode();
      if (this.triggers.length) {
        this.$_addEventListeners();
      }
      if (this.shown) {
        this.show();
      }
    },
    dispose() {
      if (this.$_isDisposed)
        return;
      this.$_isDisposed = true;
      this.$_removeEventListeners();
      this.hide({ skipDelay: true });
      this.$_detachPopperNode();
      this.isMounted = false;
      this.isShown = false;
      this.$_swapTargetAttrs("data-original-title", "title");
      this.$emit("dispose");
    },
    async onResize() {
      if (this.isShown) {
        await this.$_computePosition();
        this.$emit("resize");
      }
    },
    async $_computePosition() {
      var _a;
      if (this.$_isDisposed || this.positioningDisabled)
        return;
      const options2 = {
        strategy: this.strategy,
        middleware: []
      };
      if (this.distance || this.skidding) {
        options2.middleware.push(offset({
          mainAxis: this.distance,
          crossAxis: this.skidding
        }));
      }
      const isPlacementAuto = this.placement.startsWith("auto");
      if (isPlacementAuto) {
        options2.middleware.push(autoPlacement({
          alignment: (_a = this.placement.split("-")[1]) != null ? _a : ""
        }));
      } else {
        options2.placement = this.placement;
      }
      if (this.preventOverflow) {
        if (this.shift) {
          options2.middleware.push(shift({
            padding: this.overflowPadding,
            boundary: this.boundary,
            crossAxis: this.shiftCrossAxis
          }));
        }
        if (!isPlacementAuto && this.flip) {
          options2.middleware.push(flip({
            padding: this.overflowPadding,
            boundary: this.boundary
          }));
        }
      }
      options2.middleware.push(arrow({
        element: this.$_arrowNode,
        padding: this.arrowPadding
      }));
      if (this.arrowOverflow) {
        options2.middleware.push({
          name: "arrowOverflow",
          fn: ({ placement, rects, middlewareData }) => {
            let overflow;
            const { centerOffset } = middlewareData.arrow;
            if (placement.startsWith("top") || placement.startsWith("bottom")) {
              overflow = Math.abs(centerOffset) > rects.reference.width / 2;
            } else {
              overflow = Math.abs(centerOffset) > rects.reference.height / 2;
            }
            return {
              data: {
                overflow
              }
            };
          }
        });
      }
      if (this.autoMinSize || this.autoSize) {
        const autoSize = this.autoSize ? this.autoSize : this.autoMinSize ? "min" : null;
        options2.middleware.push({
          name: "autoSize",
          fn: ({ rects, placement, middlewareData }) => {
            var _a2;
            if ((_a2 = middlewareData.autoSize) == null ? void 0 : _a2.skip) {
              return {};
            }
            let width;
            let height;
            if (placement.startsWith("top") || placement.startsWith("bottom")) {
              width = rects.reference.width;
            } else {
              height = rects.reference.height;
            }
            this.$_innerNode.style[autoSize === "min" ? "minWidth" : autoSize === "max" ? "maxWidth" : "width"] = width != null ? `${width}px` : null;
            this.$_innerNode.style[autoSize === "min" ? "minHeight" : autoSize === "max" ? "maxHeight" : "height"] = height != null ? `${height}px` : null;
            return {
              data: {
                skip: true
              },
              reset: {
                rects: true
              }
            };
          }
        });
      }
      if (this.autoMaxSize || this.autoBoundaryMaxSize) {
        this.$_innerNode.style.maxWidth = null;
        this.$_innerNode.style.maxHeight = null;
        options2.middleware.push(size({
          boundary: this.boundary,
          padding: this.overflowPadding,
          apply: ({ width, height }) => {
            this.$_innerNode.style.maxWidth = width != null ? `${width}px` : null;
            this.$_innerNode.style.maxHeight = height != null ? `${height}px` : null;
          }
        }));
      }
      const data2 = await computePosition(this.$_referenceNode, this.$_popperNode, options2);
      Object.assign(this.result, {
        x: data2.x,
        y: data2.y,
        placement: data2.placement,
        strategy: data2.strategy,
        arrow: __spreadValues2(__spreadValues2({}, data2.middlewareData.arrow), data2.middlewareData.arrowOverflow)
      });
    },
    $_scheduleShow(event = null, skipDelay = false) {
      this.$_hideInProgress = false;
      clearTimeout(this.$_scheduleTimer);
      if (hidingPopper && this.instantMove && hidingPopper.instantMove) {
        hidingPopper.$_applyHide(true);
        this.$_applyShow(true);
        return;
      }
      if (skipDelay) {
        this.$_applyShow();
      } else {
        this.$_scheduleTimer = setTimeout(this.$_applyShow.bind(this), this.$_computeDelay("show"));
      }
    },
    $_scheduleHide(event = null, skipDelay = false) {
      this.$_hideInProgress = true;
      clearTimeout(this.$_scheduleTimer);
      if (this.isShown) {
        hidingPopper = this;
      }
      if (skipDelay) {
        this.$_applyHide();
      } else {
        this.$_scheduleTimer = setTimeout(this.$_applyHide.bind(this), this.$_computeDelay("hide"));
      }
    },
    $_computeDelay(type) {
      const delay = this.delay;
      return parseInt(delay && delay[type] || delay || 0);
    },
    async $_applyShow(skipTransition = false) {
      clearTimeout(this.$_disposeTimer);
      clearTimeout(this.$_scheduleTimer);
      this.skipTransition = skipTransition;
      if (this.isShown) {
        return;
      }
      this.$_ensureTeleport();
      await nextFrame();
      await this.$_computePosition();
      await this.$_applyShowEffect();
      if (!this.positioningDisabled) {
        this.$_registerEventListeners([
          ...getScrollParents(this.$_referenceNode),
          ...getScrollParents(this.$_popperNode)
        ], "scroll", () => {
          this.$_computePosition();
        });
      }
    },
    async $_applyShowEffect() {
      if (this.$_hideInProgress)
        return;
      if (this.computeTransformOrigin) {
        const bounds = this.$_referenceNode.getBoundingClientRect();
        const popperWrapper = this.$_popperNode.querySelector(".v-popper__wrapper");
        const parentBounds = popperWrapper.parentNode.getBoundingClientRect();
        const x2 = bounds.x + bounds.width / 2 - (parentBounds.left + popperWrapper.offsetLeft);
        const y2 = bounds.y + bounds.height / 2 - (parentBounds.top + popperWrapper.offsetTop);
        this.result.transformOrigin = `${x2}px ${y2}px`;
      }
      this.isShown = true;
      this.$_applyAttrsToTarget({
        "aria-describedby": this.popperId,
        "data-popper-shown": ""
      });
      const showGroup = this.showGroup;
      if (showGroup) {
        let popover;
        for (let i2 = 0; i2 < shownPoppers.length; i2++) {
          popover = shownPoppers[i2];
          if (popover.showGroup !== showGroup) {
            popover.hide();
            popover.$emit("close-group");
          }
        }
      }
      shownPoppers.push(this);
      this.$emit("apply-show");
      this.classes.showFrom = true;
      this.classes.showTo = false;
      this.classes.hideFrom = false;
      this.classes.hideTo = false;
      await nextFrame();
      this.classes.showFrom = false;
      this.classes.showTo = true;
    },
    async $_applyHide(skipTransition = false) {
      clearTimeout(this.$_scheduleTimer);
      if (!this.isShown) {
        return;
      }
      this.skipTransition = skipTransition;
      removeFromArray(shownPoppers, this);
      if (hidingPopper === this) {
        hidingPopper = null;
      }
      this.isShown = false;
      this.$_applyAttrsToTarget({
        "aria-describedby": void 0,
        "data-popper-shown": void 0
      });
      clearTimeout(this.$_disposeTimer);
      const disposeTime = getDefaultConfig(this.theme, "disposeTimeout");
      if (disposeTime !== null) {
        this.$_disposeTimer = setTimeout(() => {
          if (this.$_popperNode) {
            this.$_detachPopperNode();
            this.isMounted = false;
          }
        }, disposeTime);
      }
      this.$_removeEventListeners("scroll");
      this.$emit("apply-hide");
      this.classes.showFrom = false;
      this.classes.showTo = false;
      this.classes.hideFrom = true;
      this.classes.hideTo = false;
      await nextFrame();
      this.classes.hideFrom = false;
      this.classes.hideTo = true;
    },
    $_autoShowHide() {
      if (this.shown) {
        this.show();
      } else {
        this.hide();
      }
    },
    $_ensureTeleport() {
      if (this.$_isDisposed)
        return;
      let container = this.container;
      if (typeof container === "string") {
        container = window.document.querySelector(container);
      } else if (container === false) {
        container = this.$_targetNodes[0].parentNode;
      }
      if (!container) {
        throw new Error("No container for popover: " + this.container);
      }
      container.appendChild(this.$_popperNode);
      this.isMounted = true;
    },
    $_addEventListeners() {
      const handleShow = (event) => {
        if (this.isShown && !this.$_hideInProgress) {
          return;
        }
        event.usedByTooltip = true;
        !this.$_preventShow && this.show({ event });
      };
      this.$_registerTriggerListeners(this.$_targetNodes, SHOW_EVENT_MAP, this.triggers, this.showTriggers, handleShow);
      this.$_registerTriggerListeners([this.$_popperNode], SHOW_EVENT_MAP, this.popperTriggers, this.popperShowTriggers, handleShow);
      const handleHide = (event) => {
        if (event.usedByTooltip) {
          return;
        }
        this.hide({ event });
      };
      this.$_registerTriggerListeners(this.$_targetNodes, HIDE_EVENT_MAP, this.triggers, this.hideTriggers, handleHide);
      this.$_registerTriggerListeners([this.$_popperNode], HIDE_EVENT_MAP, this.popperTriggers, this.popperHideTriggers, handleHide);
    },
    $_registerEventListeners(targetNodes, eventType, handler) {
      this.$_events.push({ targetNodes, eventType, handler });
      targetNodes.forEach((node) => node.addEventListener(eventType, handler, supportsPassive ? {
        passive: true
      } : void 0));
    },
    $_registerTriggerListeners(targetNodes, eventMap, commonTriggers, customTrigger, handler) {
      let triggers = commonTriggers;
      if (customTrigger != null) {
        triggers = typeof customTrigger === "function" ? customTrigger(triggers) : customTrigger;
      }
      triggers.forEach((trigger2) => {
        const eventType = eventMap[trigger2];
        if (eventType) {
          this.$_registerEventListeners(targetNodes, eventType, handler);
        }
      });
    },
    $_removeEventListeners(filterEventType) {
      const newList = [];
      this.$_events.forEach((listener) => {
        const { targetNodes, eventType, handler } = listener;
        if (!filterEventType || filterEventType === eventType) {
          targetNodes.forEach((node) => node.removeEventListener(eventType, handler));
        } else {
          newList.push(listener);
        }
      });
      this.$_events = newList;
    },
    $_refreshListeners() {
      if (!this.$_isDisposed) {
        this.$_removeEventListeners();
        this.$_addEventListeners();
      }
    },
    $_handleGlobalClose(event, touch = false) {
      if (this.$_showFrameLocked)
        return;
      this.hide({ event });
      if (event.closePopover) {
        this.$emit("close-directive");
      } else {
        this.$emit("auto-hide");
      }
      if (touch) {
        this.$_preventShow = true;
        setTimeout(() => {
          this.$_preventShow = false;
        }, 300);
      }
    },
    $_detachPopperNode() {
      this.$_popperNode.parentNode && this.$_popperNode.parentNode.removeChild(this.$_popperNode);
    },
    $_swapTargetAttrs(attrFrom, attrTo) {
      for (const el of this.$_targetNodes) {
        const value = el.getAttribute(attrFrom);
        if (value) {
          el.removeAttribute(attrFrom);
          el.setAttribute(attrTo, value);
        }
      }
    },
    $_applyAttrsToTarget(attrs) {
      for (const el of this.$_targetNodes) {
        for (const n2 in attrs) {
          const value = attrs[n2];
          if (value == null) {
            el.removeAttribute(n2);
          } else {
            el.setAttribute(n2, value);
          }
        }
      }
    }
  },
  render() {
    return this.$slots.default(this.slotData);
  }
});
if (typeof document !== "undefined" && typeof window !== "undefined") {
  if (isIOS) {
    document.addEventListener("touchstart", handleGlobalMousedown, supportsPassive ? {
      passive: true,
      capture: true
    } : true);
    document.addEventListener("touchend", handleGlobalTouchend, supportsPassive ? {
      passive: true,
      capture: true
    } : true);
  } else {
    window.addEventListener("mousedown", handleGlobalMousedown, true);
    window.addEventListener("click", handleGlobalClick, true);
  }
  window.addEventListener("resize", computePositionAllShownPoppers);
}
function handleGlobalMousedown(event) {
  for (let i2 = 0; i2 < shownPoppers.length; i2++) {
    const popper = shownPoppers[i2];
    try {
      const popperContent = popper.popperNode();
      popper.$_mouseDownContains = popperContent.contains(event.target);
    } catch (e2) {
    }
  }
}
function handleGlobalClick(event) {
  handleGlobalClose(event);
}
function handleGlobalTouchend(event) {
  handleGlobalClose(event, true);
}
function handleGlobalClose(event, touch = false) {
  for (let i2 = 0; i2 < shownPoppers.length; i2++) {
    const popper = shownPoppers[i2];
    try {
      const popperContent = popper.popperNode();
      const contains2 = popper.$_mouseDownContains || popperContent.contains(event.target);
      requestAnimationFrame(() => {
        if (event.closeAllPopover || event.closePopover && contains2 || popper.autoHide && !contains2) {
          popper.$_handleGlobalClose(event, touch);
        }
      });
    } catch (e2) {
    }
  }
}
function computePositionAllShownPoppers(event) {
  for (let i2 = 0; i2 < shownPoppers.length; i2++) {
    const popper = shownPoppers[i2];
    popper.$_computePosition(event);
  }
}
function getInternetExplorerVersion() {
  var ua = window.navigator.userAgent;
  var msie = ua.indexOf("MSIE ");
  if (msie > 0) {
    return parseInt(ua.substring(msie + 5, ua.indexOf(".", msie)), 10);
  }
  var trident = ua.indexOf("Trident/");
  if (trident > 0) {
    var rv = ua.indexOf("rv:");
    return parseInt(ua.substring(rv + 3, ua.indexOf(".", rv)), 10);
  }
  var edge = ua.indexOf("Edge/");
  if (edge > 0) {
    return parseInt(ua.substring(edge + 5, ua.indexOf(".", edge)), 10);
  }
  return -1;
}
let isIE;
function initCompat() {
  if (!initCompat.init) {
    initCompat.init = true;
    isIE = getInternetExplorerVersion() !== -1;
  }
}
var script = {
  name: "ResizeObserver",
  props: {
    emitOnMount: {
      type: Boolean,
      default: false
    },
    ignoreWidth: {
      type: Boolean,
      default: false
    },
    ignoreHeight: {
      type: Boolean,
      default: false
    }
  },
  emits: [
    "notify"
  ],
  mounted() {
    initCompat();
    nextTick(() => {
      this._w = this.$el.offsetWidth;
      this._h = this.$el.offsetHeight;
      if (this.emitOnMount) {
        this.emitSize();
      }
    });
    const object = document.createElement("object");
    this._resizeObject = object;
    object.setAttribute("aria-hidden", "true");
    object.setAttribute("tabindex", -1);
    object.onload = this.addResizeHandlers;
    object.type = "text/html";
    if (isIE) {
      this.$el.appendChild(object);
    }
    object.data = "about:blank";
    if (!isIE) {
      this.$el.appendChild(object);
    }
  },
  beforeUnmount() {
    this.removeResizeHandlers();
  },
  methods: {
    compareAndNotify() {
      if (!this.ignoreWidth && this._w !== this.$el.offsetWidth || !this.ignoreHeight && this._h !== this.$el.offsetHeight) {
        this._w = this.$el.offsetWidth;
        this._h = this.$el.offsetHeight;
        this.emitSize();
      }
    },
    emitSize() {
      this.$emit("notify", {
        width: this._w,
        height: this._h
      });
    },
    addResizeHandlers() {
      this._resizeObject.contentDocument.defaultView.addEventListener("resize", this.compareAndNotify);
      this.compareAndNotify();
    },
    removeResizeHandlers() {
      if (this._resizeObject && this._resizeObject.onload) {
        if (!isIE && this._resizeObject.contentDocument) {
          this._resizeObject.contentDocument.defaultView.removeEventListener("resize", this.compareAndNotify);
        }
        this.$el.removeChild(this._resizeObject);
        this._resizeObject.onload = null;
        this._resizeObject = null;
      }
    }
  }
};
const _withId = /* @__PURE__ */ withScopeId("data-v-b329ee4c");
pushScopeId("data-v-b329ee4c");
const _hoisted_1$2$1 = {
  class: "resize-observer",
  tabindex: "-1"
};
popScopeId();
const render$2 = /* @__PURE__ */ _withId((_ctx, _cache, $props, $setup, $data, $options) => {
  return openBlock(), createBlock("div", _hoisted_1$2$1);
});
script.render = render$2;
script.__scopeId = "data-v-b329ee4c";
script.__file = "src/components/ResizeObserver.vue";
var PrivateThemeClass = (prop = "theme") => ({
  computed: {
    themeClass() {
      return getThemeClasses(this[prop]);
    }
  }
});
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key2, val] of props) {
    target[key2] = val;
  }
  return target;
};
const _sfc_main$5$1 = defineComponent({
  name: "VPopperContent",
  components: {
    ResizeObserver: script
  },
  mixins: [
    PrivateThemeClass()
  ],
  props: {
    popperId: String,
    theme: String,
    shown: Boolean,
    mounted: Boolean,
    skipTransition: Boolean,
    autoHide: Boolean,
    handleResize: Boolean,
    classes: Object,
    result: Object
  },
  emits: [
    "hide",
    "resize"
  ],
  methods: {
    toPx(value) {
      if (value != null && !isNaN(value)) {
        return `${value}px`;
      }
      return null;
    }
  }
});
const _hoisted_1$1$1 = ["id", "aria-hidden", "tabindex", "data-popper-placement"];
const _hoisted_2$1$1 = {
  ref: "inner",
  class: "v-popper__inner"
};
const _hoisted_3$c = /* @__PURE__ */ createBaseVNode("div", { class: "v-popper__arrow-outer" }, null, -1);
const _hoisted_4$a = /* @__PURE__ */ createBaseVNode("div", { class: "v-popper__arrow-inner" }, null, -1);
const _hoisted_5$8 = [
  _hoisted_3$c,
  _hoisted_4$a
];
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ResizeObserver = resolveComponent("ResizeObserver");
  return openBlock(), createElementBlock("div", {
    id: _ctx.popperId,
    ref: "popover",
    class: normalizeClass(["v-popper__popper", [
      _ctx.themeClass,
      _ctx.classes.popperClass,
      {
        "v-popper__popper--shown": _ctx.shown,
        "v-popper__popper--hidden": !_ctx.shown,
        "v-popper__popper--show-from": _ctx.classes.showFrom,
        "v-popper__popper--show-to": _ctx.classes.showTo,
        "v-popper__popper--hide-from": _ctx.classes.hideFrom,
        "v-popper__popper--hide-to": _ctx.classes.hideTo,
        "v-popper__popper--skip-transition": _ctx.skipTransition,
        "v-popper__popper--arrow-overflow": _ctx.result && _ctx.result.arrow.overflow,
        "v-popper__popper--no-positioning": !_ctx.result
      }
    ]]),
    style: normalizeStyle(_ctx.result ? {
      position: _ctx.result.strategy,
      transform: `translate3d(${Math.round(_ctx.result.x)}px,${Math.round(_ctx.result.y)}px,0)`
    } : void 0),
    "aria-hidden": _ctx.shown ? "false" : "true",
    tabindex: _ctx.autoHide ? 0 : void 0,
    "data-popper-placement": _ctx.result ? _ctx.result.placement : void 0,
    onKeyup: _cache[2] || (_cache[2] = withKeys(($event) => _ctx.autoHide && _ctx.$emit("hide"), ["esc"]))
  }, [
    createBaseVNode("div", {
      class: "v-popper__backdrop",
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.autoHide && _ctx.$emit("hide"))
    }),
    createBaseVNode("div", {
      class: "v-popper__wrapper",
      style: normalizeStyle(_ctx.result ? {
        transformOrigin: _ctx.result.transformOrigin
      } : void 0)
    }, [
      createBaseVNode("div", _hoisted_2$1$1, [
        _ctx.mounted ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createBaseVNode("div", null, [
            renderSlot(_ctx.$slots, "default")
          ]),
          _ctx.handleResize ? (openBlock(), createBlock(_component_ResizeObserver, {
            key: 0,
            onNotify: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("resize", $event))
          })) : createCommentVNode("", true)
        ], 64)) : createCommentVNode("", true)
      ], 512),
      createBaseVNode("div", {
        ref: "arrow",
        class: "v-popper__arrow-container",
        style: normalizeStyle(_ctx.result ? {
          left: _ctx.toPx(_ctx.result.arrow.x),
          top: _ctx.toPx(_ctx.result.arrow.y)
        } : void 0)
      }, _hoisted_5$8, 4)
    ], 4)
  ], 46, _hoisted_1$1$1);
}
var PrivatePopperContent = /* @__PURE__ */ _export_sfc(_sfc_main$5$1, [["render", _sfc_render$2]]);
var PrivatePopperMethods = {
  methods: {
    show(...args) {
      return this.$refs.popper.show(...args);
    },
    hide(...args) {
      return this.$refs.popper.hide(...args);
    },
    dispose(...args) {
      return this.$refs.popper.dispose(...args);
    },
    onResize(...args) {
      return this.$refs.popper.onResize(...args);
    }
  }
};
const _sfc_main$4$1 = defineComponent({
  name: "VPopperWrapper",
  components: {
    Popper: PrivatePopper(),
    PopperContent: PrivatePopperContent
  },
  mixins: [
    PrivatePopperMethods,
    PrivateThemeClass("finalTheme")
  ],
  inheritAttrs: false,
  props: {
    theme: {
      type: String,
      default: null
    }
  },
  computed: {
    finalTheme() {
      var _a;
      return (_a = this.theme) != null ? _a : this.$options.vPopperTheme;
    },
    popperAttrs() {
      const result = __spreadValues2({}, this.$attrs);
      delete result.class;
      delete result.style;
      return result;
    }
  },
  methods: {
    getTargetNodes() {
      return Array.from(this.$refs.reference.children).filter((node) => node !== this.$refs.popperContent.$el);
    }
  }
});
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PopperContent = resolveComponent("PopperContent");
  const _component_Popper = resolveComponent("Popper");
  return openBlock(), createBlock(_component_Popper, mergeProps({ ref: "popper" }, _ctx.popperAttrs, {
    theme: _ctx.finalTheme,
    "target-nodes": _ctx.getTargetNodes,
    "reference-node": () => _ctx.$refs.reference,
    "popper-node": () => _ctx.$refs.popperContent.$el
  }), {
    default: withCtx(({
      popperId,
      isShown,
      shouldMountContent,
      skipTransition,
      autoHide,
      show,
      hide,
      handleResize,
      onResize,
      classes,
      result
    }) => [
      createBaseVNode("div", {
        ref: "reference",
        class: normalizeClass(["v-popper", [
          _ctx.$attrs.class,
          _ctx.themeClass,
          {
            "v-popper--shown": isShown
          }
        ]]),
        style: normalizeStyle(_ctx.$attrs.style)
      }, [
        renderSlot(_ctx.$slots, "default", {
          shown: isShown,
          show,
          hide
        }),
        createVNode(_component_PopperContent, {
          ref: "popperContent",
          "popper-id": popperId,
          theme: _ctx.finalTheme,
          shown: isShown,
          mounted: shouldMountContent,
          "skip-transition": skipTransition,
          "auto-hide": autoHide,
          "handle-resize": handleResize,
          classes,
          result,
          onHide: hide,
          onResize
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "popper", {
              shown: isShown,
              hide
            })
          ]),
          _: 2
        }, 1032, ["popper-id", "theme", "shown", "mounted", "skip-transition", "auto-hide", "handle-resize", "classes", "result", "onHide", "onResize"])
      ], 6)
    ]),
    _: 3
  }, 16, ["theme", "target-nodes", "reference-node", "popper-node"]);
}
var PrivatePopperWrapper = /* @__PURE__ */ _export_sfc(_sfc_main$4$1, [["render", _sfc_render$1]]);
defineComponent(__spreadProps2(__spreadValues2({}, PrivatePopperWrapper), {
  name: "VDropdown",
  vPopperTheme: "dropdown"
}));
defineComponent(__spreadProps2(__spreadValues2({}, PrivatePopperWrapper), {
  name: "VMenu",
  vPopperTheme: "menu"
}));
defineComponent(__spreadProps2(__spreadValues2({}, PrivatePopperWrapper), {
  name: "VTooltip",
  vPopperTheme: "tooltip"
}));
const _sfc_main$l = defineComponent({
  name: "VTooltipDirective",
  components: {
    Popper: PrivatePopper(),
    PopperContent: PrivatePopperContent
  },
  mixins: [
    PrivatePopperMethods
  ],
  inheritAttrs: false,
  props: {
    theme: {
      type: String,
      default: "tooltip"
    },
    html: {
      type: Boolean,
      default: (props) => getDefaultConfig(props.theme, "html")
    },
    content: {
      type: [String, Number, Function],
      default: null
    },
    loadingContent: {
      type: String,
      default: (props) => getDefaultConfig(props.theme, "loadingContent")
    }
  },
  data() {
    return {
      asyncContent: null
    };
  },
  computed: {
    isContentAsync() {
      return typeof this.content === "function";
    },
    loading() {
      return this.isContentAsync && this.asyncContent == null;
    },
    finalContent() {
      if (this.isContentAsync) {
        return this.loading ? this.loadingContent : this.asyncContent;
      }
      return this.content;
    }
  },
  watch: {
    content: {
      handler() {
        this.fetchContent(true);
      },
      immediate: true
    },
    async finalContent() {
      await this.$nextTick();
      this.$refs.popper.onResize();
    }
  },
  created() {
    this.$_fetchId = 0;
  },
  methods: {
    fetchContent(force) {
      if (typeof this.content === "function" && this.$_isShown && (force || !this.$_loading && this.asyncContent == null)) {
        this.asyncContent = null;
        this.$_loading = true;
        const fetchId = ++this.$_fetchId;
        const result = this.content(this);
        if (result.then) {
          result.then((res) => this.onResult(fetchId, res));
        } else {
          this.onResult(fetchId, result);
        }
      }
    },
    onResult(fetchId, result) {
      if (fetchId !== this.$_fetchId)
        return;
      this.$_loading = false;
      this.asyncContent = result;
    },
    onShow() {
      this.$_isShown = true;
      this.fetchContent();
    },
    onHide() {
      this.$_isShown = false;
    }
  }
});
const _hoisted_1$l = ["innerHTML"];
const _hoisted_2$j = ["textContent"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PopperContent = resolveComponent("PopperContent");
  const _component_Popper = resolveComponent("Popper");
  return openBlock(), createBlock(_component_Popper, mergeProps({ ref: "popper" }, _ctx.$attrs, {
    theme: _ctx.theme,
    "popper-node": () => _ctx.$refs.popperContent.$el,
    onApplyShow: _ctx.onShow,
    onApplyHide: _ctx.onHide
  }), {
    default: withCtx(({
      popperId,
      isShown,
      shouldMountContent,
      skipTransition,
      autoHide,
      hide,
      handleResize,
      onResize,
      classes,
      result
    }) => [
      createVNode(_component_PopperContent, {
        ref: "popperContent",
        class: normalizeClass({
          "v-popper--tooltip-loading": _ctx.loading
        }),
        "popper-id": popperId,
        theme: _ctx.theme,
        shown: isShown,
        mounted: shouldMountContent,
        "skip-transition": skipTransition,
        "auto-hide": autoHide,
        "handle-resize": handleResize,
        classes,
        result,
        onHide: hide,
        onResize
      }, {
        default: withCtx(() => [
          _ctx.html ? (openBlock(), createElementBlock("div", {
            key: 0,
            innerHTML: _ctx.finalContent
          }, null, 8, _hoisted_1$l)) : (openBlock(), createElementBlock("div", {
            key: 1,
            textContent: toDisplayString(_ctx.finalContent)
          }, null, 8, _hoisted_2$j))
        ]),
        _: 2
      }, 1032, ["class", "popper-id", "theme", "shown", "mounted", "skip-transition", "auto-hide", "handle-resize", "classes", "result", "onHide", "onResize"])
    ]),
    _: 1
  }, 16, ["theme", "popper-node", "onApplyShow", "onApplyHide"]);
}
var PrivateTooltipDirective = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render]]);
const TARGET_CLASS = "v-popper--has-tooltip";
function getPlacement(options2, modifiers) {
  let result = options2.placement;
  if (!result && modifiers) {
    for (const pos of placements) {
      if (modifiers[pos]) {
        result = pos;
      }
    }
  }
  if (!result) {
    result = getDefaultConfig(options2.theme || "tooltip", "placement");
  }
  return result;
}
function getOptions(el, value, modifiers) {
  let options2;
  const type = typeof value;
  if (type === "string") {
    options2 = { content: value };
  } else if (value && type === "object") {
    options2 = value;
  } else {
    options2 = { content: false };
  }
  options2.placement = getPlacement(options2, modifiers);
  options2.targetNodes = () => [el];
  options2.referenceNode = () => el;
  return options2;
}
let directiveApp;
let directives;
let uid = 0;
function ensureDirectiveApp() {
  if (directiveApp)
    return;
  directives = ref([]);
  directiveApp = createApp({
    name: "VTooltipDirectiveApp",
    setup() {
      return {
        directives
      };
    },
    render() {
      return this.directives.map((directive) => {
        return h$3(PrivateTooltipDirective, __spreadProps2(__spreadValues2({}, directive.options), {
          shown: directive.shown.value || directive.options.shown,
          key: directive.id
        }));
      });
    },
    devtools: {
      hide: true
    }
  });
  const mountTarget = document.createElement("div");
  document.body.appendChild(mountTarget);
  directiveApp.mount(mountTarget);
}
function createTooltip(el, value, modifiers) {
  ensureDirectiveApp();
  const options2 = ref(getOptions(el, value, modifiers));
  const shown = ref(false);
  const item = {
    id: uid++,
    options: options2,
    shown
  };
  directives.value.push(item);
  if (el.classList) {
    el.classList.add(TARGET_CLASS);
  }
  const result = el.$_popper = {
    options: options2,
    item,
    show() {
      shown.value = true;
    },
    hide() {
      shown.value = false;
    }
  };
  return result;
}
function destroyTooltip(el) {
  if (el.$_popper) {
    const index2 = directives.value.indexOf(el.$_popper.item);
    if (index2 !== -1)
      directives.value.splice(index2, 1);
    delete el.$_popper;
    delete el.$_popperOldShown;
    delete el.$_popperMountTarget;
  }
  if (el.classList) {
    el.classList.remove(TARGET_CLASS);
  }
}
function bind2(el, { value, oldValue, modifiers }) {
  const options2 = getOptions(el, value, modifiers);
  if (!options2.content || getDefaultConfig(options2.theme || "tooltip", "disabled")) {
    destroyTooltip(el);
  } else {
    let directive;
    if (el.$_popper) {
      directive = el.$_popper;
      directive.options.value = options2;
    } else {
      directive = createTooltip(el, value, modifiers);
    }
    if (typeof value.shown !== "undefined" && value.shown !== el.$_popperOldShown) {
      el.$_popperOldShown = value.shown;
      value.shown ? directive.show() : directive.hide();
    }
  }
}
var PrivateVTooltip = {
  beforeMount: bind2,
  updated: bind2,
  beforeUnmount(el) {
    destroyTooltip(el);
  }
};
const VTooltip = PrivateVTooltip;
function T(t2, n2, ...u2) {
  if (t2 in n2) {
    let o2 = n2[t2];
    return typeof o2 == "function" ? o2(...u2) : o2;
  }
  let e2 = new Error(`Tried to handle "${t2}" but there is no handler defined. Only defined handlers are: ${Object.keys(n2).map((o2) => `"${o2}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(e2, T), e2;
}
function x(_g) {
  var _h = _g, { visible: t2 = true, features: n2 = 0 } = _h, u2 = __objRest(_h, ["visible", "features"]);
  var e2;
  if (t2 || n2 & 2 && u2.props.static)
    return Se(u2);
  if (n2 & 1) {
    let o2 = ((e2 = u2.props.unmount) != null ? e2 : true) ? 0 : 1;
    return T(o2, { [0]() {
      return null;
    }, [1]() {
      return Se(__spreadProps(__spreadValues({}, u2), { props: __spreadProps(__spreadValues({}, u2.props), { hidden: true, style: { display: "none" } }) }));
    } });
  }
  return Se(u2);
}
function Se({ props: t2, attrs: n2, slots: u2, slot: e2, name: o2 }) {
  var a2;
  let _a = L(t2, ["unmount", "static"]), { as: r2 } = _a, s2 = __objRest(_a, ["as"]), d2 = (a2 = u2.default) == null ? void 0 : a2.call(u2, e2);
  if (r2 === "template") {
    if (Object.keys(s2).length > 0 || Object.keys(n2).length > 0) {
      let [i2, ...l2] = d2 != null ? d2 : [];
      if (!co(i2) || l2.length > 0)
        throw new Error(['Passing props on "template"!', "", `The current component <${o2} /> is rendering a "template".`, "However we need to passthrough the following props:", Object.keys(s2).concat(Object.keys(n2)).map((c2) => `  - ${c2}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "template".', "Render a single element as the child so that we can forward the props onto that element."].map((c2) => `  - ${c2}`).join(`
`)].join(`
`));
      return cloneVNode(i2, s2);
    }
    return Array.isArray(d2) && d2.length === 1 ? d2[0] : d2;
  }
  return h$3(r2, s2, d2);
}
function L(t2, n2 = []) {
  let u2 = Object.assign({}, t2);
  for (let e2 of n2)
    e2 in u2 && delete u2[e2];
  return u2;
}
function co(t2) {
  return t2 == null ? false : typeof t2.type == "string" || typeof t2.type == "object" || typeof t2.type == "function";
}
var mo = 0;
function vo() {
  return ++mo;
}
function h() {
  return vo();
}
function bo(t2) {
  throw new Error("Unexpected object: " + t2);
}
function J(t2, n2) {
  let u2 = n2.resolveItems();
  if (u2.length <= 0)
    return null;
  let e2 = n2.resolveActiveIndex(), o2 = e2 != null ? e2 : -1, r2 = (() => {
    switch (t2.focus) {
      case 0:
        return u2.findIndex((s2) => !n2.resolveDisabled(s2));
      case 1: {
        let s2 = u2.slice().reverse().findIndex((d2, a2, i2) => o2 !== -1 && i2.length - a2 - 1 >= o2 ? false : !n2.resolveDisabled(d2));
        return s2 === -1 ? s2 : u2.length - 1 - s2;
      }
      case 2:
        return u2.findIndex((s2, d2) => d2 <= o2 ? false : !n2.resolveDisabled(s2));
      case 3: {
        let s2 = u2.slice().reverse().findIndex((d2) => !n2.resolveDisabled(d2));
        return s2 === -1 ? s2 : u2.length - 1 - s2;
      }
      case 4:
        return u2.findIndex((s2) => n2.resolveId(s2) === t2.id);
      case 5:
        return null;
      default:
        bo(t2);
    }
  })();
  return r2 === -1 ? e2 : r2;
}
function v(t2) {
  return t2 == null || t2.value == null ? null : "$el" in t2.value ? t2.value.$el : t2.value;
}
function C(t2, n2, u2) {
  typeof window != "undefined" && watchEffect((e2) => {
    window.addEventListener(t2, n2, u2), e2(() => {
      window.removeEventListener(t2, n2, u2);
    });
  });
}
var at = Symbol("Context");
function it() {
  return I() !== null;
}
function I() {
  return inject(at, null);
}
function M(t2) {
  provide(at, t2);
}
function ut(t2, n2) {
  if (t2)
    return t2;
  let u2 = n2 != null ? n2 : "button";
  if (typeof u2 == "string" && u2.toLowerCase() === "button")
    return "button";
}
function P(t2, n2) {
  let u2 = ref(ut(t2.value.type, t2.value.as));
  return onMounted(() => {
    u2.value = ut(t2.value.type, t2.value.as);
  }), watchEffect(() => {
    var e2;
    u2.value || !v(n2) || v(n2) instanceof HTMLButtonElement && !((e2 = v(n2)) == null ? void 0 : e2.hasAttribute("type")) && (u2.value = "button");
  }), u2;
}
function Y({ container: t2, accept: n2, walk: u2, enabled: e2 }) {
  watchEffect(() => {
    let o2 = t2.value;
    if (!o2 || e2 !== void 0 && !e2.value)
      return;
    let r2 = Object.assign((d2) => n2(d2), { acceptNode: n2 }), s2 = document.createTreeWalker(o2, NodeFilter.SHOW_ELEMENT, r2, false);
    for (; s2.nextNode(); )
      u2(s2.currentNode);
  });
}
var ct = Symbol("ComboboxContext");
function ee(t2) {
  let n2 = inject(ct, null);
  if (n2 === null) {
    let u2 = new Error(`<${t2} /> is missing a parent <Combobox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(u2, ee), u2;
  }
  return n2;
}
defineComponent({ name: "Combobox", emits: { "update:modelValue": (t2) => true }, props: { as: { type: [Object, String], default: "template" }, disabled: { type: [Boolean], default: false }, modelValue: { type: [Object, String, Number, Boolean] } }, setup(t2, { slots: n2, attrs: u2, emit: e2 }) {
  let o2 = ref(1), r2 = ref(null), s2 = ref(null), d2 = ref(null), a2 = ref(null), i2 = ref({ static: false, hold: false }), l2 = ref([]), c2 = ref(null), p2 = computed(() => t2.modelValue), f2 = { comboboxState: o2, value: p2, inputRef: s2, labelRef: r2, buttonRef: d2, optionsRef: a2, disabled: computed(() => t2.disabled), options: l2, activeOptionIndex: c2, inputPropsRef: ref({ displayValue: void 0 }), optionsPropsRef: i2, closeCombobox() {
    t2.disabled || o2.value !== 1 && (o2.value = 1, c2.value = null);
  }, openCombobox() {
    t2.disabled || o2.value !== 0 && (o2.value = 0);
  }, goToOption(m2, g2) {
    if (t2.disabled || a2.value && !i2.value.static && o2.value === 1)
      return;
    let S2 = J(m2 === 4 ? { focus: 4, id: g2 } : { focus: m2 }, { resolveItems: () => l2.value, resolveActiveIndex: () => c2.value, resolveId: (y2) => y2.id, resolveDisabled: (y2) => y2.dataRef.disabled });
    c2.value !== S2 && (c2.value = S2);
  }, syncInputValue() {
    let m2 = f2.value.value;
    if (!v(f2.inputRef) || m2 === void 0)
      return;
    let g2 = f2.inputPropsRef.value.displayValue;
    typeof g2 == "function" ? f2.inputRef.value.value = g2(m2) : typeof m2 == "string" && (f2.inputRef.value.value = m2);
  }, selectOption(m2) {
    let g2 = l2.value.find((y2) => y2.id === m2);
    if (!g2)
      return;
    let { dataRef: S2 } = g2;
    e2("update:modelValue", S2.value), f2.syncInputValue();
  }, selectActiveOption() {
    if (c2.value === null)
      return;
    let { dataRef: m2 } = l2.value[c2.value];
    e2("update:modelValue", m2.value), f2.syncInputValue();
  }, registerOption(m2, g2) {
    var R2, E2;
    let S2 = c2.value !== null ? l2.value[c2.value] : null, y2 = Array.from((E2 = (R2 = a2.value) == null ? void 0 : R2.querySelectorAll('[id^="headlessui-combobox-option-"]')) != null ? E2 : []).reduce((D2, w2, F2) => Object.assign(D2, { [w2.id]: F2 }), {});
    l2.value = [...l2.value, { id: m2, dataRef: g2 }].sort((D2, w2) => y2[D2.id] - y2[w2.id]), c2.value = (() => S2 === null ? null : l2.value.indexOf(S2))();
  }, unregisterOption(m2) {
    let g2 = l2.value.slice(), S2 = c2.value !== null ? g2[c2.value] : null, y2 = g2.findIndex((R2) => R2.id === m2);
    y2 !== -1 && g2.splice(y2, 1), l2.value = g2, c2.value = (() => y2 === c2.value || S2 === null ? null : g2.indexOf(S2))();
  } };
  C("mousedown", (m2) => {
    var S2, y2, R2;
    let g2 = m2.target;
    o2.value === 0 && (((S2 = v(s2)) == null ? void 0 : S2.contains(g2)) || ((y2 = v(d2)) == null ? void 0 : y2.contains(g2)) || ((R2 = v(a2)) == null ? void 0 : R2.contains(g2)) || f2.closeCombobox());
  }), watch([f2.value, f2.inputRef], () => f2.syncInputValue(), { immediate: true }), provide(ct, f2), M(computed(() => T(o2.value, { [0]: 0, [1]: 1 })));
  let b2 = computed(() => c2.value === null ? null : l2.value[c2.value].dataRef.value);
  return () => {
    let m2 = { open: o2.value === 0, disabled: t2.disabled, activeIndex: c2.value, activeOption: b2.value };
    return x({ props: L(t2, ["modelValue", "onUpdate:modelValue", "disabled"]), slot: m2, slots: n2, attrs: u2, name: "Combobox" });
  };
} });
defineComponent({ name: "ComboboxLabel", props: { as: { type: [Object, String], default: "label" } }, setup(t2, { attrs: n2, slots: u2 }) {
  let e2 = ee("ComboboxLabel"), o2 = `headlessui-combobox-label-${h()}`;
  function r2() {
    var s2;
    (s2 = v(e2.inputRef)) == null || s2.focus({ preventScroll: true });
  }
  return () => {
    let s2 = { open: e2.comboboxState.value === 0, disabled: e2.disabled.value }, d2 = { id: o2, ref: e2.labelRef, onClick: r2 };
    return x({ props: __spreadValues(__spreadValues({}, t2), d2), slot: s2, attrs: n2, slots: u2, name: "ComboboxLabel" });
  };
} });
defineComponent({ name: "ComboboxButton", props: { as: { type: [Object, String], default: "button" } }, setup(t2, { attrs: n2, slots: u2 }) {
  let e2 = ee("ComboboxButton"), o2 = `headlessui-combobox-button-${h()}`;
  function r2(a2) {
    e2.disabled.value || (e2.comboboxState.value === 0 ? e2.closeCombobox() : (a2.preventDefault(), e2.openCombobox()), nextTick(() => {
      var i2;
      return (i2 = v(e2.inputRef)) == null ? void 0 : i2.focus({ preventScroll: true });
    }));
  }
  function s2(a2) {
    switch (a2.key) {
      case "ArrowDown":
        a2.preventDefault(), a2.stopPropagation(), e2.comboboxState.value === 1 && (e2.openCombobox(), nextTick(() => {
          e2.value.value || e2.goToOption(0);
        })), nextTick(() => {
          var i2;
          return (i2 = e2.inputRef.value) == null ? void 0 : i2.focus({ preventScroll: true });
        });
        return;
      case "ArrowUp":
        a2.preventDefault(), a2.stopPropagation(), e2.comboboxState.value === 1 && (e2.openCombobox(), nextTick(() => {
          e2.value.value || e2.goToOption(3);
        })), nextTick(() => {
          var i2;
          return (i2 = e2.inputRef.value) == null ? void 0 : i2.focus({ preventScroll: true });
        });
        return;
      case "Escape":
        a2.preventDefault(), e2.optionsRef.value && !e2.optionsPropsRef.value.static && a2.stopPropagation(), e2.closeCombobox(), nextTick(() => {
          var i2;
          return (i2 = e2.inputRef.value) == null ? void 0 : i2.focus({ preventScroll: true });
        });
        return;
    }
  }
  let d2 = P(computed(() => ({ as: t2.as, type: n2.type })), e2.buttonRef);
  return () => {
    var l2, c2;
    let a2 = { open: e2.comboboxState.value === 0, disabled: e2.disabled.value }, i2 = { ref: e2.buttonRef, id: o2, type: d2.value, tabindex: "-1", "aria-haspopup": true, "aria-controls": (l2 = v(e2.optionsRef)) == null ? void 0 : l2.id, "aria-expanded": e2.disabled.value ? void 0 : e2.comboboxState.value === 0, "aria-labelledby": e2.labelRef.value ? [(c2 = v(e2.labelRef)) == null ? void 0 : c2.id, o2].join(" ") : void 0, disabled: e2.disabled.value === true ? true : void 0, onKeydown: s2, onClick: r2 };
    return x({ props: __spreadValues(__spreadValues({}, t2), i2), slot: a2, attrs: n2, slots: u2, name: "ComboboxButton" });
  };
} });
defineComponent({ name: "ComboboxInput", props: { as: { type: [Object, String], default: "input" }, static: { type: Boolean, default: false }, unmount: { type: Boolean, default: true }, displayValue: { type: Function } }, emits: { change: (t2) => true }, setup(t2, { emit: n2, attrs: u2, slots: e2 }) {
  let o2 = ee("ComboboxInput"), r2 = `headlessui-combobox-input-${h()}`;
  o2.inputPropsRef = computed(() => t2);
  function s2(a2) {
    switch (a2.key) {
      case "Enter":
        a2.preventDefault(), a2.stopPropagation(), o2.selectActiveOption(), o2.closeCombobox();
        break;
      case "ArrowDown":
        return a2.preventDefault(), a2.stopPropagation(), T(o2.comboboxState.value, { [0]: () => o2.goToOption(2), [1]: () => {
          o2.openCombobox(), nextTick(() => {
            o2.value.value || o2.goToOption(0);
          });
        } });
      case "ArrowUp":
        return a2.preventDefault(), a2.stopPropagation(), T(o2.comboboxState.value, { [0]: () => o2.goToOption(1), [1]: () => {
          o2.openCombobox(), nextTick(() => {
            o2.value.value || o2.goToOption(3);
          });
        } });
      case "Home":
      case "PageUp":
        return a2.preventDefault(), a2.stopPropagation(), o2.goToOption(0);
      case "End":
      case "PageDown":
        return a2.preventDefault(), a2.stopPropagation(), o2.goToOption(3);
      case "Escape":
        a2.preventDefault(), o2.optionsRef.value && !o2.optionsPropsRef.value.static && a2.stopPropagation(), o2.closeCombobox();
        break;
      case "Tab":
        o2.selectActiveOption(), o2.closeCombobox();
        break;
    }
  }
  function d2(a2) {
    o2.openCombobox(), n2("change", a2);
  }
  return () => {
    var c2, p2, f2, b2, m2;
    let a2 = { open: o2.comboboxState.value === 0 }, i2 = { "aria-controls": (c2 = o2.optionsRef.value) == null ? void 0 : c2.id, "aria-expanded": o2.disabled ? void 0 : o2.comboboxState.value === 0, "aria-activedescendant": o2.activeOptionIndex.value === null || (p2 = o2.options.value[o2.activeOptionIndex.value]) == null ? void 0 : p2.id, "aria-labelledby": (m2 = (f2 = v(o2.labelRef)) == null ? void 0 : f2.id) != null ? m2 : (b2 = v(o2.buttonRef)) == null ? void 0 : b2.id, id: r2, onKeydown: s2, onChange: d2, onInput: d2, role: "combobox", type: "text", tabIndex: 0, ref: o2.inputRef }, l2 = L(t2, ["displayValue"]);
    return x({ props: __spreadValues(__spreadValues({}, l2), i2), slot: a2, attrs: u2, slots: e2, features: 1 | 2, name: "ComboboxInput" });
  };
} });
defineComponent({ name: "ComboboxOptions", props: { as: { type: [Object, String], default: "ul" }, static: { type: Boolean, default: false }, unmount: { type: Boolean, default: true }, hold: { type: [Boolean], default: false } }, setup(t2, { attrs: n2, slots: u2 }) {
  let e2 = ee("ComboboxOptions"), o2 = `headlessui-combobox-options-${h()}`;
  watchEffect(() => {
    e2.optionsPropsRef.value.static = t2.static;
  }), watchEffect(() => {
    e2.optionsPropsRef.value.hold = t2.hold;
  });
  let r2 = I(), s2 = computed(() => r2 !== null ? r2.value === 0 : e2.comboboxState.value === 0);
  return Y({ container: computed(() => v(e2.optionsRef)), enabled: computed(() => e2.comboboxState.value === 0), accept(d2) {
    return d2.getAttribute("role") === "option" ? NodeFilter.FILTER_REJECT : d2.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(d2) {
    d2.setAttribute("role", "none");
  } }), () => {
    var l2, c2, p2, f2;
    let d2 = { open: e2.comboboxState.value === 0 }, a2 = { "aria-activedescendant": e2.activeOptionIndex.value === null || (l2 = e2.options.value[e2.activeOptionIndex.value]) == null ? void 0 : l2.id, "aria-labelledby": (f2 = (c2 = v(e2.labelRef)) == null ? void 0 : c2.id) != null ? f2 : (p2 = v(e2.buttonRef)) == null ? void 0 : p2.id, id: o2, ref: e2.optionsRef, role: "listbox" }, i2 = L(t2, ["hold"]);
    return x({ props: __spreadValues(__spreadValues({}, i2), a2), slot: d2, attrs: n2, slots: u2, features: 1 | 2, visible: s2.value, name: "ComboboxOptions" });
  };
} });
defineComponent({ name: "ComboboxOption", props: { as: { type: [Object, String], default: "li" }, value: { type: [Object, String, Number, Boolean] }, disabled: { type: Boolean, default: false } }, setup(t2, { slots: n2, attrs: u2 }) {
  let e2 = ee("ComboboxOption"), o2 = `headlessui-combobox-option-${h()}`, r2 = computed(() => e2.activeOptionIndex.value !== null ? e2.options.value[e2.activeOptionIndex.value].id === o2 : false), s2 = computed(() => toRaw(e2.value.value) === toRaw(t2.value)), d2 = computed(() => ({ disabled: t2.disabled, value: t2.value }));
  onMounted(() => e2.registerOption(o2, d2)), onUnmounted(() => e2.unregisterOption(o2)), onMounted(() => {
    watch([e2.comboboxState, s2], () => {
      e2.comboboxState.value === 0 && (!s2.value || e2.goToOption(4, o2));
    }, { immediate: true });
  }), watchEffect(() => {
    e2.comboboxState.value === 0 && (!r2.value || nextTick(() => {
      var p2, f2;
      return (f2 = (p2 = document.getElementById(o2)) == null ? void 0 : p2.scrollIntoView) == null ? void 0 : f2.call(p2, { block: "nearest" });
    }));
  });
  function a2(p2) {
    if (t2.disabled)
      return p2.preventDefault();
    e2.selectOption(o2), e2.closeCombobox(), nextTick(() => {
      var f2;
      return (f2 = v(e2.inputRef)) == null ? void 0 : f2.focus({ preventScroll: true });
    });
  }
  function i2() {
    if (t2.disabled)
      return e2.goToOption(5);
    e2.goToOption(4, o2);
  }
  function l2() {
    t2.disabled || r2.value || e2.goToOption(4, o2);
  }
  function c2() {
    t2.disabled || !r2.value || e2.optionsPropsRef.value.hold || e2.goToOption(5);
  }
  return () => {
    let { disabled: p2 } = t2, f2 = { active: r2.value, selected: s2.value, disabled: p2 }, b2 = { id: o2, role: "option", tabIndex: p2 === true ? void 0 : -1, "aria-disabled": p2 === true ? true : void 0, "aria-selected": s2.value === true ? s2.value : void 0, disabled: void 0, onClick: a2, onFocus: i2, onPointermove: l2, onMousemove: l2, onPointerleave: c2, onMouseleave: c2 };
    return x({ props: __spreadValues(__spreadValues({}, t2), b2), slot: f2, attrs: u2, slots: n2, name: "ComboboxOption" });
  };
} });
var Ke = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((t2) => `${t2}:not([tabindex='-1'])`).join(",");
function ae(t2 = document.body) {
  return t2 == null ? [] : Array.from(t2.querySelectorAll(Ke));
}
function mt(t2, n2 = 0) {
  return t2 === document.body ? false : T(n2, { [0]() {
    return t2.matches(Ke);
  }, [1]() {
    let u2 = t2;
    for (; u2 !== null; ) {
      if (u2.matches(Ke))
        return true;
      u2 = u2.parentElement;
    }
    return false;
  } });
}
function te(t2) {
  t2 == null || t2.focus({ preventScroll: true });
}
function O(t2, n2) {
  let u2 = Array.isArray(t2) ? t2.slice().sort((l2, c2) => {
    let p2 = l2.compareDocumentPosition(c2);
    return p2 & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : p2 & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  }) : ae(t2), e2 = document.activeElement, o2 = (() => {
    if (n2 & (1 | 4))
      return 1;
    if (n2 & (2 | 8))
      return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), r2 = (() => {
    if (n2 & 1)
      return 0;
    if (n2 & 2)
      return Math.max(0, u2.indexOf(e2)) - 1;
    if (n2 & 4)
      return Math.max(0, u2.indexOf(e2)) + 1;
    if (n2 & 8)
      return u2.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), s2 = n2 & 32 ? { preventScroll: true } : {}, d2 = 0, a2 = u2.length, i2;
  do {
    if (d2 >= a2 || d2 + a2 <= 0)
      return 0;
    let l2 = r2 + d2;
    if (n2 & 16)
      l2 = (l2 + a2) % a2;
    else {
      if (l2 < 0)
        return 3;
      if (l2 >= a2)
        return 1;
    }
    i2 = u2[l2], i2 == null || i2.focus(s2), d2 += o2;
  } while (i2 !== document.activeElement);
  return i2.hasAttribute("tabindex") || i2.setAttribute("tabindex", "0"), 2;
}
function ie(t2, n2) {
  for (let u2 of t2)
    if (u2.contains(n2))
      return true;
  return false;
}
function Re(t2, n2 = ref(true), u2 = ref({})) {
  let e2 = ref(typeof window != "undefined" ? document.activeElement : null), o2 = ref(null);
  function r2() {
    if (!n2.value || t2.value.size !== 1)
      return;
    let { initialFocus: d2 } = u2.value, a2 = document.activeElement;
    if (d2) {
      if (d2 === a2)
        return;
    } else if (ie(t2.value, a2))
      return;
    if (e2.value = a2, d2)
      te(d2);
    else {
      let i2 = false;
      for (let l2 of t2.value)
        if (O(l2, 1) === 2) {
          i2 = true;
          break;
        }
      i2 || console.warn("There are no focusable elements inside the <FocusTrap />");
    }
    o2.value = document.activeElement;
  }
  function s2() {
    te(e2.value), e2.value = null, o2.value = null;
  }
  watchEffect(r2), onUpdated(() => {
    n2.value ? r2() : s2();
  }), onUnmounted(s2), C("keydown", (d2) => {
    if (!!n2.value && d2.key === "Tab" && !!document.activeElement && t2.value.size === 1) {
      d2.preventDefault();
      for (let a2 of t2.value)
        if (O(a2, (d2.shiftKey ? 2 : 4) | 16) === 2) {
          o2.value = document.activeElement;
          break;
        }
    }
  }), C("focus", (d2) => {
    if (!n2.value || t2.value.size !== 1)
      return;
    let a2 = o2.value;
    if (!a2)
      return;
    let i2 = d2.target;
    i2 && i2 instanceof HTMLElement ? ie(t2.value, i2) ? (o2.value = i2, te(i2)) : (d2.preventDefault(), d2.stopPropagation(), te(a2)) : te(o2.value);
  }, true);
}
var bt = "body > *", oe = /* @__PURE__ */ new Set(), K = /* @__PURE__ */ new Map();
function gt(t2) {
  t2.setAttribute("aria-hidden", "true"), t2.inert = true;
}
function xt(t2) {
  let n2 = K.get(t2);
  !n2 || (n2["aria-hidden"] === null ? t2.removeAttribute("aria-hidden") : t2.setAttribute("aria-hidden", n2["aria-hidden"]), t2.inert = n2.inert);
}
function yt(t2, n2 = ref(true)) {
  watchEffect((u2) => {
    if (!n2.value || !t2.value)
      return;
    let e2 = t2.value;
    oe.add(e2);
    for (let o2 of K.keys())
      o2.contains(e2) && (xt(o2), K.delete(o2));
    document.querySelectorAll(bt).forEach((o2) => {
      if (o2 instanceof HTMLElement) {
        for (let r2 of oe)
          if (o2.contains(r2))
            return;
        oe.size === 1 && (K.set(o2, { "aria-hidden": o2.getAttribute("aria-hidden"), inert: o2.inert }), gt(o2));
      }
    }), u2(() => {
      if (oe.delete(e2), oe.size > 0)
        document.querySelectorAll(bt).forEach((o2) => {
          if (o2 instanceof HTMLElement && !K.has(o2)) {
            for (let r2 of oe)
              if (o2.contains(r2))
                return;
            K.set(o2, { "aria-hidden": o2.getAttribute("aria-hidden"), inert: o2.inert }), gt(o2);
          }
        });
      else
        for (let o2 of K.keys())
          xt(o2), K.delete(o2);
    });
  });
}
var St = Symbol("StackContext");
function ht() {
  return inject(St, () => {
  });
}
function Rt(t2) {
  let n2 = ht();
  watchEffect((u2) => {
    let e2 = t2 == null ? void 0 : t2.value;
    !e2 || (n2(0, e2), u2(() => n2(1, e2)));
  });
}
function Te(t2) {
  let n2 = ht();
  function u2(...e2) {
    t2 == null || t2(...e2), n2(...e2);
  }
  provide(St, u2);
}
var Tt = Symbol("ForcePortalRootContext");
function Ot() {
  return inject(Tt, false);
}
var Ne = defineComponent({ name: "ForcePortalRoot", props: { as: { type: [Object, String], default: "template" }, force: { type: Boolean, default: false } }, setup(t2, { slots: n2, attrs: u2 }) {
  return provide(Tt, t2.force), () => {
    let _a = t2, { force: e2 } = _a, o2 = __objRest(_a, ["force"]);
    return x({ props: o2, slot: {}, slots: n2, attrs: u2, name: "ForcePortalRoot" });
  };
} });
function It() {
  let t2 = document.getElementById("headlessui-portal-root");
  if (t2)
    return t2;
  let n2 = document.createElement("div");
  return n2.setAttribute("id", "headlessui-portal-root"), document.body.appendChild(n2);
}
var Pt = defineComponent({ name: "Portal", props: { as: { type: [Object, String], default: "div" } }, setup(t2, { slots: n2, attrs: u2 }) {
  let e2 = Ot(), o2 = inject(Dt, null), r2 = ref(e2 === true || o2 === null ? It() : o2.resolveTarget());
  watchEffect(() => {
    e2 || o2 !== null && (r2.value = o2.resolveTarget());
  });
  let s2 = ref(null);
  return Rt(s2), onUnmounted(() => {
    var a2;
    let d2 = document.getElementById("headlessui-portal-root");
    !d2 || r2.value === d2 && r2.value.children.length <= 0 && ((a2 = r2.value.parentElement) == null || a2.removeChild(r2.value));
  }), Te(), () => {
    if (r2.value === null)
      return null;
    let d2 = { ref: s2 };
    return h$3(Teleport, { to: r2.value }, x({ props: __spreadValues(__spreadValues({}, t2), d2), slot: {}, attrs: u2, slots: n2, name: "Portal" }));
  };
} }), Dt = Symbol("PortalGroupContext"), wt = defineComponent({ name: "PortalGroup", props: { as: { type: [Object, String], default: "template" }, target: { type: Object, default: null } }, setup(t2, { attrs: n2, slots: u2 }) {
  let e2 = reactive({ resolveTarget() {
    return t2.target;
  } });
  return provide(Dt, e2), () => {
    let _a = t2, { target: o2 } = _a, r2 = __objRest(_a, ["target"]);
    return x({ props: r2, slot: {}, attrs: n2, slots: u2, name: "PortalGroup" });
  };
} });
var Lt = Symbol("DescriptionContext");
function Xo() {
  let t2 = inject(Lt, null);
  if (t2 === null)
    throw new Error("Missing parent");
  return t2;
}
function G({ slot: t2 = ref({}), name: n2 = "Description", props: u2 = {} } = {}) {
  let e2 = ref([]);
  function o2(r2) {
    return e2.value.push(r2), () => {
      let s2 = e2.value.indexOf(r2);
      s2 !== -1 && e2.value.splice(s2, 1);
    };
  }
  return provide(Lt, { register: o2, slot: t2, name: n2, props: u2 }), computed(() => e2.value.length > 0 ? e2.value.join(" ") : void 0);
}
defineComponent({ name: "Description", props: { as: { type: [Object, String], default: "p" } }, setup(t2, { attrs: n2, slots: u2 }) {
  let e2 = Xo(), o2 = `headlessui-description-${h()}`;
  return onMounted(() => onUnmounted(e2.register(o2))), () => {
    let { name: r2 = "Description", slot: s2 = ref({}), props: d2 = {} } = e2, a2 = t2, i2 = __spreadProps(__spreadValues({}, Object.entries(d2).reduce((l2, [c2, p2]) => Object.assign(l2, { [c2]: unref(p2) }), {})), { id: o2 });
    return x({ props: __spreadValues(__spreadValues({}, a2), i2), slot: s2.value, attrs: n2, slots: u2, name: r2 });
  };
} });
var kt = Symbol("DialogContext");
function $e(t2) {
  let n2 = inject(kt, null);
  if (n2 === null) {
    let u2 = new Error(`<${t2} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(u2, $e), u2;
  }
  return n2;
}
var Ee = "DC8F892D-2EBD-447C-A4C8-A03058436FF4", Gr = defineComponent({ name: "Dialog", inheritAttrs: false, props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: false }, unmount: { type: Boolean, default: true }, open: { type: [Boolean, String], default: Ee }, initialFocus: { type: Object, default: null } }, emits: { close: (t2) => true }, setup(t2, { emit: n2, attrs: u2, slots: e2 }) {
  let o2 = ref(/* @__PURE__ */ new Set()), r2 = I(), s2 = computed(() => t2.open === Ee && r2 !== null ? T(r2.value, { [0]: true, [1]: false }) : t2.open);
  if (!(t2.open !== Ee || r2 !== null))
    throw new Error("You forgot to provide an `open` prop to the `Dialog`.");
  if (typeof s2.value != "boolean")
    throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${s2.value === Ee ? void 0 : t2.open}`);
  let a2 = computed(() => t2.open ? 0 : 1), i2 = computed(() => r2 !== null ? r2.value === 0 : a2.value === 0), l2 = ref(null), c2 = ref(a2.value === 0);
  onUpdated(() => {
    c2.value = a2.value === 0;
  });
  let p2 = `headlessui-dialog-${h()}`, f2 = computed(() => ({ initialFocus: t2.initialFocus }));
  Re(o2, c2, f2), yt(l2, c2), Te((y2, R2) => T(y2, { [0]() {
    o2.value.add(R2);
  }, [1]() {
    o2.value.delete(R2);
  } }));
  let b2 = G({ name: "DialogDescription", slot: computed(() => ({ open: s2.value })) }), m2 = ref(null), g2 = { titleId: m2, dialogState: a2, setTitleId(y2) {
    m2.value !== y2 && (m2.value = y2);
  }, close() {
    n2("close", false);
  } };
  provide(kt, g2), C("mousedown", (y2) => {
    let R2 = y2.target;
    a2.value === 0 && o2.value.size === 1 && (ie(o2.value, R2) || (g2.close(), nextTick(() => R2 == null ? void 0 : R2.focus())));
  }), C("keydown", (y2) => {
    y2.key === "Escape" && a2.value === 0 && (o2.value.size > 1 || (y2.preventDefault(), y2.stopPropagation(), g2.close()));
  }), watchEffect((y2) => {
    if (a2.value !== 0)
      return;
    let R2 = document.documentElement.style.overflow, E2 = document.documentElement.style.paddingRight, D2 = window.innerWidth - document.documentElement.clientWidth;
    document.documentElement.style.overflow = "hidden", document.documentElement.style.paddingRight = `${D2}px`, y2(() => {
      document.documentElement.style.overflow = R2, document.documentElement.style.paddingRight = E2;
    });
  }), watchEffect((y2) => {
    if (a2.value !== 0)
      return;
    let R2 = v(l2);
    if (!R2)
      return;
    let E2 = new IntersectionObserver((D2) => {
      for (let w2 of D2)
        w2.boundingClientRect.x === 0 && w2.boundingClientRect.y === 0 && w2.boundingClientRect.width === 0 && w2.boundingClientRect.height === 0 && g2.close();
    });
    E2.observe(R2), y2(() => E2.disconnect());
  });
  function S2(y2) {
    y2.stopPropagation();
  }
  return () => {
    let y2 = __spreadProps(__spreadValues({}, u2), { ref: l2, id: p2, role: "dialog", "aria-modal": a2.value === 0 ? true : void 0, "aria-labelledby": m2.value, "aria-describedby": b2.value, onClick: S2 }), _a = t2, { open: R2, initialFocus: E2 } = _a, D2 = __objRest(_a, ["open", "initialFocus"]), w2 = { open: a2.value === 0 };
    return h$3(Ne, { force: true }, () => h$3(Pt, () => h$3(wt, { target: l2.value }, () => h$3(Ne, { force: false }, () => x({ props: __spreadValues(__spreadValues({}, D2), y2), slot: w2, attrs: u2, slots: e2, visible: i2.value, features: 1 | 2, name: "Dialog" })))));
  };
} }), _r = defineComponent({ name: "DialogOverlay", props: { as: { type: [Object, String], default: "div" } }, setup(t2, { attrs: n2, slots: u2 }) {
  let e2 = $e("DialogOverlay"), o2 = `headlessui-dialog-overlay-${h()}`;
  function r2(s2) {
    s2.target === s2.currentTarget && (s2.preventDefault(), s2.stopPropagation(), e2.close());
  }
  return () => x({ props: __spreadValues(__spreadValues({}, t2), { id: o2, "aria-hidden": true, onClick: r2 }), slot: { open: e2.dialogState.value === 0 }, attrs: n2, slots: u2, name: "DialogOverlay" });
} }), qr = defineComponent({ name: "DialogTitle", props: { as: { type: [Object, String], default: "h2" } }, setup(t2, { attrs: n2, slots: u2 }) {
  let e2 = $e("DialogTitle"), o2 = `headlessui-dialog-title-${h()}`;
  return onMounted(() => {
    e2.setTitleId(o2), onUnmounted(() => e2.setTitleId(null));
  }), () => x({ props: __spreadValues(__spreadValues({}, t2), { id: o2 }), slot: { open: e2.dialogState.value === 0 }, attrs: n2, slots: u2, name: "DialogTitle" });
} });
var At = Symbol("DisclosureContext");
function qe(t2) {
  let n2 = inject(At, null);
  if (n2 === null) {
    let u2 = new Error(`<${t2} /> is missing a parent <Disclosure /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(u2, qe), u2;
  }
  return n2;
}
var Ht = Symbol("DisclosurePanelContext");
function an() {
  return inject(Ht, null);
}
defineComponent({ name: "Disclosure", props: { as: { type: [Object, String], default: "template" }, defaultOpen: { type: [Boolean], default: false } }, setup(t2, { slots: n2, attrs: u2 }) {
  let e2 = `headlessui-disclosure-button-${h()}`, o2 = `headlessui-disclosure-panel-${h()}`, r2 = ref(t2.defaultOpen ? 0 : 1), s2 = ref(null), d2 = ref(null), a2 = { buttonId: e2, panelId: o2, disclosureState: r2, panel: s2, button: d2, toggleDisclosure() {
    r2.value = T(r2.value, { [0]: 1, [1]: 0 });
  }, closeDisclosure() {
    r2.value !== 1 && (r2.value = 1);
  }, close(i2) {
    a2.closeDisclosure();
    let l2 = (() => i2 ? i2 instanceof HTMLElement ? i2 : i2.value instanceof HTMLElement ? v(i2) : v(a2.button) : v(a2.button))();
    l2 == null || l2.focus();
  } };
  return provide(At, a2), M(computed(() => T(r2.value, { [0]: 0, [1]: 1 }))), () => {
    let _a = t2, { defaultOpen: i2 } = _a, l2 = __objRest(_a, ["defaultOpen"]), c2 = { open: r2.value === 0, close: a2.close };
    return x({ props: l2, slot: c2, slots: n2, attrs: u2, name: "Disclosure" });
  };
} });
defineComponent({ name: "DisclosureButton", props: { as: { type: [Object, String], default: "button" }, disabled: { type: [Boolean], default: false } }, setup(t2, { attrs: n2, slots: u2 }) {
  let e2 = qe("DisclosureButton"), o2 = an(), r2 = o2 === null ? false : o2 === e2.panelId, s2 = ref(null);
  r2 || watchEffect(() => {
    e2.button.value = s2.value;
  });
  let d2 = P(computed(() => ({ as: t2.as, type: n2.type })), s2);
  function a2() {
    var c2;
    t2.disabled || (r2 ? (e2.toggleDisclosure(), (c2 = v(e2.button)) == null || c2.focus()) : e2.toggleDisclosure());
  }
  function i2(c2) {
    var p2;
    if (!t2.disabled)
      if (r2)
        switch (c2.key) {
          case " ":
          case "Enter":
            c2.preventDefault(), c2.stopPropagation(), e2.toggleDisclosure(), (p2 = v(e2.button)) == null || p2.focus();
            break;
        }
      else
        switch (c2.key) {
          case " ":
          case "Enter":
            c2.preventDefault(), c2.stopPropagation(), e2.toggleDisclosure();
            break;
        }
  }
  function l2(c2) {
    switch (c2.key) {
      case " ":
        c2.preventDefault();
        break;
    }
  }
  return () => {
    let c2 = { open: e2.disclosureState.value === 0 }, p2 = r2 ? { ref: s2, type: d2.value, onClick: a2, onKeydown: i2 } : { id: e2.buttonId, ref: s2, type: d2.value, "aria-expanded": t2.disabled ? void 0 : e2.disclosureState.value === 0, "aria-controls": v(e2.panel) ? e2.panelId : void 0, disabled: t2.disabled ? true : void 0, onClick: a2, onKeydown: i2, onKeyup: l2 };
    return x({ props: __spreadValues(__spreadValues({}, t2), p2), slot: c2, attrs: n2, slots: u2, name: "DisclosureButton" });
  };
} });
defineComponent({ name: "DisclosurePanel", props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: false }, unmount: { type: Boolean, default: true } }, setup(t2, { attrs: n2, slots: u2 }) {
  let e2 = qe("DisclosurePanel");
  provide(Ht, e2.panelId);
  let o2 = I(), r2 = computed(() => o2 !== null ? o2.value === 0 : e2.disclosureState.value === 0);
  return () => {
    let s2 = { open: e2.disclosureState.value === 0, close: e2.close }, d2 = { id: e2.panelId, ref: e2.panel };
    return x({ props: __spreadValues(__spreadValues({}, t2), d2), slot: s2, attrs: n2, slots: u2, features: 1 | 2, visible: r2.value, name: "DisclosurePanel" });
  };
} });
defineComponent({ name: "FocusTrap", props: { as: { type: [Object, String], default: "div" }, initialFocus: { type: Object, default: null } }, setup(t2, { attrs: n2, slots: u2 }) {
  let e2 = ref(/* @__PURE__ */ new Set()), o2 = ref(null), r2 = ref(true), s2 = computed(() => ({ initialFocus: t2.initialFocus }));
  return onMounted(() => {
    !o2.value || (e2.value.add(o2.value), Re(e2, r2, s2));
  }), onUnmounted(() => {
    r2.value = false;
  }), () => {
    let d2 = {}, a2 = { ref: o2 }, _a = t2, { initialFocus: i2 } = _a, l2 = __objRest(_a, ["initialFocus"]);
    return x({ props: __spreadValues(__spreadValues({}, l2), a2), slot: d2, attrs: n2, slots: u2, name: "FocusTrap" });
  };
} });
function gn(t2) {
  requestAnimationFrame(() => requestAnimationFrame(t2));
}
var Kt = Symbol("ListboxContext");
function pe(t2) {
  let n2 = inject(Kt, null);
  if (n2 === null) {
    let u2 = new Error(`<${t2} /> is missing a parent <Listbox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(u2, pe), u2;
  }
  return n2;
}
defineComponent({ name: "Listbox", emits: { "update:modelValue": (t2) => true }, props: { as: { type: [Object, String], default: "template" }, disabled: { type: [Boolean], default: false }, horizontal: { type: [Boolean], default: false }, modelValue: { type: [Object, String, Number, Boolean] } }, setup(t2, { slots: n2, attrs: u2, emit: e2 }) {
  let o2 = ref(1), r2 = ref(null), s2 = ref(null), d2 = ref(null), a2 = ref([]), i2 = ref(""), l2 = ref(null), c2 = computed(() => t2.modelValue), p2 = { listboxState: o2, value: c2, orientation: computed(() => t2.horizontal ? "horizontal" : "vertical"), labelRef: r2, buttonRef: s2, optionsRef: d2, disabled: computed(() => t2.disabled), options: a2, searchQuery: i2, activeOptionIndex: l2, closeListbox() {
    t2.disabled || o2.value !== 1 && (o2.value = 1, l2.value = null);
  }, openListbox() {
    t2.disabled || o2.value !== 0 && (o2.value = 0);
  }, goToOption(f2, b2) {
    if (t2.disabled || o2.value === 1)
      return;
    let m2 = J(f2 === 4 ? { focus: 4, id: b2 } : { focus: f2 }, { resolveItems: () => a2.value, resolveActiveIndex: () => l2.value, resolveId: (g2) => g2.id, resolveDisabled: (g2) => g2.dataRef.disabled });
    i2.value === "" && l2.value === m2 || (i2.value = "", l2.value = m2);
  }, search(f2) {
    if (t2.disabled || o2.value === 1)
      return;
    let m2 = i2.value !== "" ? 0 : 1;
    i2.value += f2.toLowerCase();
    let S2 = (l2.value !== null ? a2.value.slice(l2.value + m2).concat(a2.value.slice(0, l2.value + m2)) : a2.value).find((R2) => R2.dataRef.textValue.startsWith(i2.value) && !R2.dataRef.disabled), y2 = S2 ? a2.value.indexOf(S2) : -1;
    y2 === -1 || y2 === l2.value || (l2.value = y2);
  }, clearSearch() {
    t2.disabled || o2.value !== 1 && i2.value !== "" && (i2.value = "");
  }, registerOption(f2, b2) {
    var g2, S2;
    let m2 = Array.from((S2 = (g2 = d2.value) == null ? void 0 : g2.querySelectorAll('[id^="headlessui-listbox-option-"]')) != null ? S2 : []).reduce((y2, R2, E2) => Object.assign(y2, { [R2.id]: E2 }), {});
    a2.value = [...a2.value, { id: f2, dataRef: b2 }].sort((y2, R2) => m2[y2.id] - m2[R2.id]);
  }, unregisterOption(f2) {
    let b2 = a2.value.slice(), m2 = l2.value !== null ? b2[l2.value] : null, g2 = b2.findIndex((S2) => S2.id === f2);
    g2 !== -1 && b2.splice(g2, 1), a2.value = b2, l2.value = (() => g2 === l2.value || m2 === null ? null : b2.indexOf(m2))();
  }, select(f2) {
    t2.disabled || e2("update:modelValue", f2);
  } };
  return C("mousedown", (f2) => {
    var g2, S2, y2;
    let b2 = f2.target, m2 = document.activeElement;
    o2.value === 0 && (((g2 = v(s2)) == null ? void 0 : g2.contains(b2)) || (((S2 = v(d2)) == null ? void 0 : S2.contains(b2)) || p2.closeListbox(), !(m2 !== document.body && (m2 == null ? void 0 : m2.contains(b2))) && (f2.defaultPrevented || (y2 = v(s2)) == null || y2.focus({ preventScroll: true }))));
  }), provide(Kt, p2), M(computed(() => T(o2.value, { [0]: 0, [1]: 1 }))), () => {
    let f2 = { open: o2.value === 0, disabled: t2.disabled };
    return x({ props: L(t2, ["modelValue", "onUpdate:modelValue", "disabled", "horizontal"]), slot: f2, slots: n2, attrs: u2, name: "Listbox" });
  };
} });
defineComponent({ name: "ListboxLabel", props: { as: { type: [Object, String], default: "label" } }, setup(t2, { attrs: n2, slots: u2 }) {
  let e2 = pe("ListboxLabel"), o2 = `headlessui-listbox-label-${h()}`;
  function r2() {
    var s2;
    (s2 = v(e2.buttonRef)) == null || s2.focus({ preventScroll: true });
  }
  return () => {
    let s2 = { open: e2.listboxState.value === 0, disabled: e2.disabled.value }, d2 = { id: o2, ref: e2.labelRef, onClick: r2 };
    return x({ props: __spreadValues(__spreadValues({}, t2), d2), slot: s2, attrs: n2, slots: u2, name: "ListboxLabel" });
  };
} });
defineComponent({ name: "ListboxButton", props: { as: { type: [Object, String], default: "button" } }, setup(t2, { attrs: n2, slots: u2 }) {
  let e2 = pe("ListboxButton"), o2 = `headlessui-listbox-button-${h()}`;
  function r2(i2) {
    switch (i2.key) {
      case " ":
      case "Enter":
      case "ArrowDown":
        i2.preventDefault(), e2.openListbox(), nextTick(() => {
          var l2;
          (l2 = v(e2.optionsRef)) == null || l2.focus({ preventScroll: true }), e2.value.value || e2.goToOption(0);
        });
        break;
      case "ArrowUp":
        i2.preventDefault(), e2.openListbox(), nextTick(() => {
          var l2;
          (l2 = v(e2.optionsRef)) == null || l2.focus({ preventScroll: true }), e2.value.value || e2.goToOption(3);
        });
        break;
    }
  }
  function s2(i2) {
    switch (i2.key) {
      case " ":
        i2.preventDefault();
        break;
    }
  }
  function d2(i2) {
    e2.disabled.value || (e2.listboxState.value === 0 ? (e2.closeListbox(), nextTick(() => {
      var l2;
      return (l2 = v(e2.buttonRef)) == null ? void 0 : l2.focus({ preventScroll: true });
    })) : (i2.preventDefault(), e2.openListbox(), gn(() => {
      var l2;
      return (l2 = v(e2.optionsRef)) == null ? void 0 : l2.focus({ preventScroll: true });
    })));
  }
  let a2 = P(computed(() => ({ as: t2.as, type: n2.type })), e2.buttonRef);
  return () => {
    var c2, p2;
    let i2 = { open: e2.listboxState.value === 0, disabled: e2.disabled.value }, l2 = { ref: e2.buttonRef, id: o2, type: a2.value, "aria-haspopup": true, "aria-controls": (c2 = v(e2.optionsRef)) == null ? void 0 : c2.id, "aria-expanded": e2.disabled.value ? void 0 : e2.listboxState.value === 0, "aria-labelledby": e2.labelRef.value ? [(p2 = v(e2.labelRef)) == null ? void 0 : p2.id, o2].join(" ") : void 0, disabled: e2.disabled.value === true ? true : void 0, onKeydown: r2, onKeyup: s2, onClick: d2 };
    return x({ props: __spreadValues(__spreadValues({}, t2), l2), slot: i2, attrs: n2, slots: u2, name: "ListboxButton" });
  };
} });
defineComponent({ name: "ListboxOptions", props: { as: { type: [Object, String], default: "ul" }, static: { type: Boolean, default: false }, unmount: { type: Boolean, default: true } }, setup(t2, { attrs: n2, slots: u2 }) {
  let e2 = pe("ListboxOptions"), o2 = `headlessui-listbox-options-${h()}`, r2 = ref(null);
  function s2(i2) {
    switch (r2.value && clearTimeout(r2.value), i2.key) {
      case " ":
        if (e2.searchQuery.value !== "")
          return i2.preventDefault(), i2.stopPropagation(), e2.search(i2.key);
      case "Enter":
        if (i2.preventDefault(), i2.stopPropagation(), e2.activeOptionIndex.value !== null) {
          let { dataRef: l2 } = e2.options.value[e2.activeOptionIndex.value];
          e2.select(l2.value);
        }
        e2.closeListbox(), nextTick(() => {
          var l2;
          return (l2 = v(e2.buttonRef)) == null ? void 0 : l2.focus({ preventScroll: true });
        });
        break;
      case T(e2.orientation.value, { vertical: "ArrowDown", horizontal: "ArrowRight" }):
        return i2.preventDefault(), i2.stopPropagation(), e2.goToOption(2);
      case T(e2.orientation.value, { vertical: "ArrowUp", horizontal: "ArrowLeft" }):
        return i2.preventDefault(), i2.stopPropagation(), e2.goToOption(1);
      case "Home":
      case "PageUp":
        return i2.preventDefault(), i2.stopPropagation(), e2.goToOption(0);
      case "End":
      case "PageDown":
        return i2.preventDefault(), i2.stopPropagation(), e2.goToOption(3);
      case "Escape":
        i2.preventDefault(), i2.stopPropagation(), e2.closeListbox(), nextTick(() => {
          var l2;
          return (l2 = v(e2.buttonRef)) == null ? void 0 : l2.focus({ preventScroll: true });
        });
        break;
      case "Tab":
        i2.preventDefault(), i2.stopPropagation();
        break;
      default:
        i2.key.length === 1 && (e2.search(i2.key), r2.value = setTimeout(() => e2.clearSearch(), 350));
        break;
    }
  }
  let d2 = I(), a2 = computed(() => d2 !== null ? d2.value === 0 : e2.listboxState.value === 0);
  return () => {
    var p2, f2, b2, m2;
    let i2 = { open: e2.listboxState.value === 0 }, l2 = { "aria-activedescendant": e2.activeOptionIndex.value === null || (p2 = e2.options.value[e2.activeOptionIndex.value]) == null ? void 0 : p2.id, "aria-labelledby": (m2 = (f2 = v(e2.labelRef)) == null ? void 0 : f2.id) != null ? m2 : (b2 = v(e2.buttonRef)) == null ? void 0 : b2.id, "aria-orientation": e2.orientation.value, id: o2, onKeydown: s2, role: "listbox", tabIndex: 0, ref: e2.optionsRef };
    return x({ props: __spreadValues(__spreadValues({}, t2), l2), slot: i2, attrs: n2, slots: u2, features: 1 | 2, visible: a2.value, name: "ListboxOptions" });
  };
} });
defineComponent({ name: "ListboxOption", props: { as: { type: [Object, String], default: "li" }, value: { type: [Object, String, Number, Boolean] }, disabled: { type: Boolean, default: false } }, setup(t2, { slots: n2, attrs: u2 }) {
  let e2 = pe("ListboxOption"), o2 = `headlessui-listbox-option-${h()}`, r2 = computed(() => e2.activeOptionIndex.value !== null ? e2.options.value[e2.activeOptionIndex.value].id === o2 : false), s2 = computed(() => toRaw(e2.value.value) === toRaw(t2.value)), d2 = ref({ disabled: t2.disabled, value: t2.value, textValue: "" });
  onMounted(() => {
    var f2, b2;
    let p2 = (b2 = (f2 = document.getElementById(o2)) == null ? void 0 : f2.textContent) == null ? void 0 : b2.toLowerCase().trim();
    p2 !== void 0 && (d2.value.textValue = p2);
  }), onMounted(() => e2.registerOption(o2, d2)), onUnmounted(() => e2.unregisterOption(o2)), onMounted(() => {
    watch([e2.listboxState, s2], () => {
      var p2, f2;
      e2.listboxState.value === 0 && (!s2.value || (e2.goToOption(4, o2), (f2 = (p2 = document.getElementById(o2)) == null ? void 0 : p2.focus) == null || f2.call(p2)));
    }, { immediate: true });
  }), watchEffect(() => {
    e2.listboxState.value === 0 && (!r2.value || nextTick(() => {
      var p2, f2;
      return (f2 = (p2 = document.getElementById(o2)) == null ? void 0 : p2.scrollIntoView) == null ? void 0 : f2.call(p2, { block: "nearest" });
    }));
  });
  function a2(p2) {
    if (t2.disabled)
      return p2.preventDefault();
    e2.select(t2.value), e2.closeListbox(), nextTick(() => {
      var f2;
      return (f2 = v(e2.buttonRef)) == null ? void 0 : f2.focus({ preventScroll: true });
    });
  }
  function i2() {
    if (t2.disabled)
      return e2.goToOption(5);
    e2.goToOption(4, o2);
  }
  function l2() {
    t2.disabled || r2.value || e2.goToOption(4, o2);
  }
  function c2() {
    t2.disabled || !r2.value || e2.goToOption(5);
  }
  return () => {
    let { disabled: p2 } = t2, f2 = { active: r2.value, selected: s2.value, disabled: p2 }, b2 = { id: o2, role: "option", tabIndex: p2 === true ? void 0 : -1, "aria-disabled": p2 === true ? true : void 0, "aria-selected": s2.value === true ? s2.value : void 0, disabled: void 0, onClick: a2, onFocus: i2, onPointermove: l2, onMousemove: l2, onPointerleave: c2, onMouseleave: c2 };
    return x({ props: __spreadValues(__spreadValues({}, t2), b2), slot: f2, attrs: u2, slots: n2, name: "ListboxOption" });
  };
} });
function Rn(t2) {
  requestAnimationFrame(() => requestAnimationFrame(t2));
}
var Nt = Symbol("MenuContext");
function De(t2) {
  let n2 = inject(Nt, null);
  if (n2 === null) {
    let u2 = new Error(`<${t2} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(u2, De), u2;
  }
  return n2;
}
defineComponent({ name: "Menu", props: { as: { type: [Object, String], default: "template" } }, setup(t2, { slots: n2, attrs: u2 }) {
  let e2 = ref(1), o2 = ref(null), r2 = ref(null), s2 = ref([]), d2 = ref(""), a2 = ref(null), i2 = { menuState: e2, buttonRef: o2, itemsRef: r2, items: s2, searchQuery: d2, activeItemIndex: a2, closeMenu: () => {
    e2.value = 1, a2.value = null;
  }, openMenu: () => e2.value = 0, goToItem(l2, c2) {
    let p2 = J(l2 === 4 ? { focus: 4, id: c2 } : { focus: l2 }, { resolveItems: () => s2.value, resolveActiveIndex: () => a2.value, resolveId: (f2) => f2.id, resolveDisabled: (f2) => f2.dataRef.disabled });
    d2.value === "" && a2.value === p2 || (d2.value = "", a2.value = p2);
  }, search(l2) {
    let p2 = d2.value !== "" ? 0 : 1;
    d2.value += l2.toLowerCase();
    let b2 = (a2.value !== null ? s2.value.slice(a2.value + p2).concat(s2.value.slice(0, a2.value + p2)) : s2.value).find((g2) => g2.dataRef.textValue.startsWith(d2.value) && !g2.dataRef.disabled), m2 = b2 ? s2.value.indexOf(b2) : -1;
    m2 === -1 || m2 === a2.value || (a2.value = m2);
  }, clearSearch() {
    d2.value = "";
  }, registerItem(l2, c2) {
    var f2, b2;
    let p2 = Array.from((b2 = (f2 = r2.value) == null ? void 0 : f2.querySelectorAll('[id^="headlessui-menu-item-"]')) != null ? b2 : []).reduce((m2, g2, S2) => Object.assign(m2, { [g2.id]: S2 }), {});
    s2.value = [...s2.value, { id: l2, dataRef: c2 }].sort((m2, g2) => p2[m2.id] - p2[g2.id]);
  }, unregisterItem(l2) {
    let c2 = s2.value.slice(), p2 = a2.value !== null ? c2[a2.value] : null, f2 = c2.findIndex((b2) => b2.id === l2);
    f2 !== -1 && c2.splice(f2, 1), s2.value = c2, a2.value = (() => f2 === a2.value || p2 === null ? null : c2.indexOf(p2))();
  } };
  return C("mousedown", (l2) => {
    var f2, b2, m2;
    let c2 = l2.target, p2 = document.activeElement;
    e2.value === 0 && (((f2 = v(o2)) == null ? void 0 : f2.contains(c2)) || (((b2 = v(r2)) == null ? void 0 : b2.contains(c2)) || i2.closeMenu(), !(p2 !== document.body && (p2 == null ? void 0 : p2.contains(c2))) && (l2.defaultPrevented || (m2 = v(o2)) == null || m2.focus({ preventScroll: true }))));
  }), provide(Nt, i2), M(computed(() => T(e2.value, { [0]: 0, [1]: 1 }))), () => {
    let l2 = { open: e2.value === 0 };
    return x({ props: t2, slot: l2, slots: n2, attrs: u2, name: "Menu" });
  };
} });
defineComponent({ name: "MenuButton", props: { disabled: { type: Boolean, default: false }, as: { type: [Object, String], default: "button" } }, setup(t2, { attrs: n2, slots: u2 }) {
  let e2 = De("MenuButton"), o2 = `headlessui-menu-button-${h()}`;
  function r2(i2) {
    switch (i2.key) {
      case " ":
      case "Enter":
      case "ArrowDown":
        i2.preventDefault(), i2.stopPropagation(), e2.openMenu(), nextTick(() => {
          var l2;
          (l2 = v(e2.itemsRef)) == null || l2.focus({ preventScroll: true }), e2.goToItem(0);
        });
        break;
      case "ArrowUp":
        i2.preventDefault(), i2.stopPropagation(), e2.openMenu(), nextTick(() => {
          var l2;
          (l2 = v(e2.itemsRef)) == null || l2.focus({ preventScroll: true }), e2.goToItem(3);
        });
        break;
    }
  }
  function s2(i2) {
    switch (i2.key) {
      case " ":
        i2.preventDefault();
        break;
    }
  }
  function d2(i2) {
    t2.disabled || (e2.menuState.value === 0 ? (e2.closeMenu(), nextTick(() => {
      var l2;
      return (l2 = v(e2.buttonRef)) == null ? void 0 : l2.focus({ preventScroll: true });
    })) : (i2.preventDefault(), i2.stopPropagation(), e2.openMenu(), Rn(() => {
      var l2;
      return (l2 = v(e2.itemsRef)) == null ? void 0 : l2.focus({ preventScroll: true });
    })));
  }
  let a2 = P(computed(() => ({ as: t2.as, type: n2.type })), e2.buttonRef);
  return () => {
    var c2;
    let i2 = { open: e2.menuState.value === 0 }, l2 = { ref: e2.buttonRef, id: o2, type: a2.value, "aria-haspopup": true, "aria-controls": (c2 = v(e2.itemsRef)) == null ? void 0 : c2.id, "aria-expanded": t2.disabled ? void 0 : e2.menuState.value === 0, onKeydown: r2, onKeyup: s2, onClick: d2 };
    return x({ props: __spreadValues(__spreadValues({}, t2), l2), slot: i2, attrs: n2, slots: u2, name: "MenuButton" });
  };
} });
defineComponent({ name: "MenuItems", props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: false }, unmount: { type: Boolean, default: true } }, setup(t2, { attrs: n2, slots: u2 }) {
  let e2 = De("MenuItems"), o2 = `headlessui-menu-items-${h()}`, r2 = ref(null);
  Y({ container: computed(() => v(e2.itemsRef)), enabled: computed(() => e2.menuState.value === 0), accept(l2) {
    return l2.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : l2.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(l2) {
    l2.setAttribute("role", "none");
  } });
  function s2(l2) {
    var c2;
    switch (r2.value && clearTimeout(r2.value), l2.key) {
      case " ":
        if (e2.searchQuery.value !== "")
          return l2.preventDefault(), l2.stopPropagation(), e2.search(l2.key);
      case "Enter":
        if (l2.preventDefault(), l2.stopPropagation(), e2.activeItemIndex.value !== null) {
          let { id: p2 } = e2.items.value[e2.activeItemIndex.value];
          (c2 = document.getElementById(p2)) == null || c2.click();
        }
        e2.closeMenu(), nextTick(() => {
          var p2;
          return (p2 = v(e2.buttonRef)) == null ? void 0 : p2.focus({ preventScroll: true });
        });
        break;
      case "ArrowDown":
        return l2.preventDefault(), l2.stopPropagation(), e2.goToItem(2);
      case "ArrowUp":
        return l2.preventDefault(), l2.stopPropagation(), e2.goToItem(1);
      case "Home":
      case "PageUp":
        return l2.preventDefault(), l2.stopPropagation(), e2.goToItem(0);
      case "End":
      case "PageDown":
        return l2.preventDefault(), l2.stopPropagation(), e2.goToItem(3);
      case "Escape":
        l2.preventDefault(), l2.stopPropagation(), e2.closeMenu(), nextTick(() => {
          var p2;
          return (p2 = v(e2.buttonRef)) == null ? void 0 : p2.focus({ preventScroll: true });
        });
        break;
      case "Tab":
        l2.preventDefault(), l2.stopPropagation();
        break;
      default:
        l2.key.length === 1 && (e2.search(l2.key), r2.value = setTimeout(() => e2.clearSearch(), 350));
        break;
    }
  }
  function d2(l2) {
    switch (l2.key) {
      case " ":
        l2.preventDefault();
        break;
    }
  }
  let a2 = I(), i2 = computed(() => a2 !== null ? a2.value === 0 : e2.menuState.value === 0);
  return () => {
    var f2, b2;
    let l2 = { open: e2.menuState.value === 0 }, c2 = { "aria-activedescendant": e2.activeItemIndex.value === null || (f2 = e2.items.value[e2.activeItemIndex.value]) == null ? void 0 : f2.id, "aria-labelledby": (b2 = v(e2.buttonRef)) == null ? void 0 : b2.id, id: o2, onKeydown: s2, onKeyup: d2, role: "menu", tabIndex: 0, ref: e2.itemsRef };
    return x({ props: __spreadValues(__spreadValues({}, t2), c2), slot: l2, attrs: n2, slots: u2, features: 1 | 2, visible: i2.value, name: "MenuItems" });
  };
} });
defineComponent({ name: "MenuItem", props: { as: { type: [Object, String], default: "template" }, disabled: { type: Boolean, default: false } }, setup(t2, { slots: n2, attrs: u2 }) {
  let e2 = De("MenuItem"), o2 = `headlessui-menu-item-${h()}`, r2 = computed(() => e2.activeItemIndex.value !== null ? e2.items.value[e2.activeItemIndex.value].id === o2 : false), s2 = ref({ disabled: t2.disabled, textValue: "" });
  onMounted(() => {
    var p2, f2;
    let c2 = (f2 = (p2 = document.getElementById(o2)) == null ? void 0 : p2.textContent) == null ? void 0 : f2.toLowerCase().trim();
    c2 !== void 0 && (s2.value.textValue = c2);
  }), onMounted(() => e2.registerItem(o2, s2)), onUnmounted(() => e2.unregisterItem(o2)), watchEffect(() => {
    e2.menuState.value === 0 && (!r2.value || nextTick(() => {
      var c2, p2;
      return (p2 = (c2 = document.getElementById(o2)) == null ? void 0 : c2.scrollIntoView) == null ? void 0 : p2.call(c2, { block: "nearest" });
    }));
  });
  function d2(c2) {
    if (t2.disabled)
      return c2.preventDefault();
    e2.closeMenu(), nextTick(() => {
      var p2;
      return (p2 = v(e2.buttonRef)) == null ? void 0 : p2.focus({ preventScroll: true });
    });
  }
  function a2() {
    if (t2.disabled)
      return e2.goToItem(5);
    e2.goToItem(4, o2);
  }
  function i2() {
    t2.disabled || r2.value || e2.goToItem(4, o2);
  }
  function l2() {
    t2.disabled || !r2.value || e2.goToItem(5);
  }
  return () => {
    let { disabled: c2 } = t2, p2 = { active: r2.value, disabled: c2 };
    return x({ props: __spreadValues(__spreadValues({}, t2), { id: o2, role: "menuitem", tabIndex: c2 === true ? void 0 : -1, "aria-disabled": c2 === true ? true : void 0, onClick: d2, onFocus: a2, onPointermove: i2, onMousemove: i2, onPointerleave: l2, onMouseleave: l2 }), slot: p2, attrs: u2, slots: n2, name: "MenuItem" });
  };
} });
var Wt = Symbol("PopoverContext");
function Le(t2) {
  let n2 = inject(Wt, null);
  if (n2 === null) {
    let u2 = new Error(`<${t2} /> is missing a parent <${Cn.name} /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(u2, Le), u2;
  }
  return n2;
}
var Ut = Symbol("PopoverGroupContext");
function $t() {
  return inject(Ut, null);
}
var Gt = Symbol("PopoverPanelContext");
function On() {
  return inject(Gt, null);
}
var Cn = defineComponent({ name: "Popover", props: { as: { type: [Object, String], default: "div" } }, setup(t2, { slots: n2, attrs: u2 }) {
  let e2 = `headlessui-popover-button-${h()}`, o2 = `headlessui-popover-panel-${h()}`, r2 = ref(1), s2 = ref(null), d2 = ref(null), a2 = { popoverState: r2, buttonId: e2, panelId: o2, panel: d2, button: s2, togglePopover() {
    r2.value = T(r2.value, { [0]: 1, [1]: 0 });
  }, closePopover() {
    r2.value !== 1 && (r2.value = 1);
  }, close(f2) {
    a2.closePopover();
    let b2 = (() => f2 ? f2 instanceof HTMLElement ? f2 : f2.value instanceof HTMLElement ? v(f2) : v(a2.button) : v(a2.button))();
    b2 == null || b2.focus();
  } };
  provide(Wt, a2), M(computed(() => T(r2.value, { [0]: 0, [1]: 1 })));
  let i2 = { buttonId: e2, panelId: o2, close() {
    a2.closePopover();
  } }, l2 = $t(), c2 = l2 == null ? void 0 : l2.registerPopover;
  function p2() {
    var f2, b2, m2;
    return (m2 = l2 == null ? void 0 : l2.isFocusWithinPopoverGroup()) != null ? m2 : ((f2 = v(s2)) == null ? void 0 : f2.contains(document.activeElement)) || ((b2 = v(d2)) == null ? void 0 : b2.contains(document.activeElement));
  }
  return watchEffect(() => c2 == null ? void 0 : c2(i2)), C("focus", () => {
    r2.value === 0 && (p2() || !s2 || !d2 || a2.closePopover());
  }, true), C("mousedown", (f2) => {
    var m2, g2, S2;
    let b2 = f2.target;
    r2.value === 0 && (((m2 = v(s2)) == null ? void 0 : m2.contains(b2)) || ((g2 = v(d2)) == null ? void 0 : g2.contains(b2)) || (a2.closePopover(), mt(b2, 1) || (f2.preventDefault(), (S2 = v(s2)) == null || S2.focus())));
  }), () => {
    let f2 = { open: r2.value === 0, close: a2.close };
    return x({ props: t2, slot: f2, slots: n2, attrs: u2, name: "Popover" });
  };
} });
defineComponent({ name: "PopoverButton", props: { as: { type: [Object, String], default: "button" }, disabled: { type: [Boolean], default: false } }, setup(t2, { attrs: n2, slots: u2 }) {
  let e2 = Le("PopoverButton"), o2 = $t(), r2 = o2 == null ? void 0 : o2.closeOthers, s2 = On(), d2 = s2 === null ? false : s2 === e2.panelId, a2 = ref(null), i2 = ref(typeof window == "undefined" ? null : document.activeElement);
  C("focus", () => {
    i2.value = a2.value, a2.value = document.activeElement;
  }, true);
  let l2 = ref(null);
  d2 || watchEffect(() => {
    e2.button.value = l2.value;
  });
  let c2 = P(computed(() => ({ as: t2.as, type: n2.type })), l2);
  function p2(m2) {
    var g2, S2, y2, R2;
    if (d2) {
      if (e2.popoverState.value === 1)
        return;
      switch (m2.key) {
        case " ":
        case "Enter":
          m2.preventDefault(), m2.stopPropagation(), e2.closePopover(), (g2 = v(e2.button)) == null || g2.focus();
          break;
      }
    } else
      switch (m2.key) {
        case " ":
        case "Enter":
          m2.preventDefault(), m2.stopPropagation(), e2.popoverState.value === 1 && (r2 == null || r2(e2.buttonId)), e2.togglePopover();
          break;
        case "Escape":
          if (e2.popoverState.value !== 0)
            return r2 == null ? void 0 : r2(e2.buttonId);
          if (!v(e2.button) || !((S2 = v(e2.button)) == null ? void 0 : S2.contains(document.activeElement)))
            return;
          m2.preventDefault(), m2.stopPropagation(), e2.closePopover();
          break;
        case "Tab":
          if (e2.popoverState.value !== 0 || !e2.panel || !e2.button)
            return;
          if (m2.shiftKey) {
            if (!i2.value || ((y2 = v(e2.button)) == null ? void 0 : y2.contains(i2.value)) || ((R2 = v(e2.panel)) == null ? void 0 : R2.contains(i2.value)))
              return;
            let E2 = ae(), D2 = E2.indexOf(i2.value);
            if (E2.indexOf(v(e2.button)) > D2)
              return;
            m2.preventDefault(), m2.stopPropagation(), O(v(e2.panel), 8);
          } else
            m2.preventDefault(), m2.stopPropagation(), O(v(e2.panel), 1);
          break;
      }
  }
  function f2(m2) {
    var g2, S2;
    if (!d2 && (m2.key === " " && m2.preventDefault(), e2.popoverState.value === 0 && !!e2.panel && !!e2.button))
      switch (m2.key) {
        case "Tab":
          if (!i2.value || ((g2 = v(e2.button)) == null ? void 0 : g2.contains(i2.value)) || ((S2 = v(e2.panel)) == null ? void 0 : S2.contains(i2.value)))
            return;
          let y2 = ae(), R2 = y2.indexOf(i2.value);
          if (y2.indexOf(v(e2.button)) > R2)
            return;
          m2.preventDefault(), m2.stopPropagation(), O(v(e2.panel), 8);
          break;
      }
  }
  function b2() {
    var m2, g2;
    t2.disabled || (d2 ? (e2.closePopover(), (m2 = v(e2.button)) == null || m2.focus()) : (e2.popoverState.value === 1 && (r2 == null || r2(e2.buttonId)), (g2 = v(e2.button)) == null || g2.focus(), e2.togglePopover()));
  }
  return () => {
    let m2 = { open: e2.popoverState.value === 0 }, g2 = d2 ? { ref: l2, type: c2.value, onKeydown: p2, onClick: b2 } : { ref: l2, id: e2.buttonId, type: c2.value, "aria-expanded": t2.disabled ? void 0 : e2.popoverState.value === 0, "aria-controls": v(e2.panel) ? e2.panelId : void 0, disabled: t2.disabled ? true : void 0, onKeydown: p2, onKeyup: f2, onClick: b2 };
    return x({ props: __spreadValues(__spreadValues({}, t2), g2), slot: m2, attrs: n2, slots: u2, name: "PopoverButton" });
  };
} });
defineComponent({ name: "PopoverOverlay", props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: false }, unmount: { type: Boolean, default: true } }, setup(t2, { attrs: n2, slots: u2 }) {
  let e2 = Le("PopoverOverlay"), o2 = `headlessui-popover-overlay-${h()}`, r2 = I(), s2 = computed(() => r2 !== null ? r2.value === 0 : e2.popoverState.value === 0);
  function d2() {
    e2.closePopover();
  }
  return () => {
    let a2 = { open: e2.popoverState.value === 0 };
    return x({ props: __spreadValues(__spreadValues({}, t2), { id: o2, "aria-hidden": true, onClick: d2 }), slot: a2, attrs: n2, slots: u2, features: 1 | 2, visible: s2.value, name: "PopoverOverlay" });
  };
} });
defineComponent({ name: "PopoverPanel", props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: false }, unmount: { type: Boolean, default: true }, focus: { type: Boolean, default: false } }, setup(t2, { attrs: n2, slots: u2 }) {
  let { focus: e2 } = t2, o2 = Le("PopoverPanel");
  provide(Gt, o2.panelId), onUnmounted(() => {
    o2.panel.value = null;
  }), watchEffect(() => {
    var i2;
    if (!e2 || o2.popoverState.value !== 0 || !o2.panel)
      return;
    let a2 = document.activeElement;
    ((i2 = v(o2.panel)) == null ? void 0 : i2.contains(a2)) || O(v(o2.panel), 1);
  }), C("keydown", (a2) => {
    var l2, c2;
    if (o2.popoverState.value !== 0 || !v(o2.panel) || a2.key !== "Tab" || !document.activeElement || !((l2 = v(o2.panel)) == null ? void 0 : l2.contains(document.activeElement)))
      return;
    a2.preventDefault();
    let i2 = O(v(o2.panel), a2.shiftKey ? 2 : 4);
    if (i2 === 3)
      return (c2 = v(o2.button)) == null ? void 0 : c2.focus();
    if (i2 === 1) {
      if (!v(o2.button))
        return;
      let p2 = ae(), f2 = p2.indexOf(v(o2.button)), b2 = p2.splice(f2 + 1).filter((m2) => {
        var g2;
        return !((g2 = v(o2.panel)) == null ? void 0 : g2.contains(m2));
      });
      O(b2, 1) === 0 && O(document.body, 1);
    }
  }), C("focus", () => {
    var a2;
    !e2 || o2.popoverState.value === 0 && (!v(o2.panel) || ((a2 = v(o2.panel)) == null ? void 0 : a2.contains(document.activeElement)) || o2.closePopover());
  }, true);
  let r2 = I(), s2 = computed(() => r2 !== null ? r2.value === 0 : o2.popoverState.value === 0);
  function d2(a2) {
    var i2, l2;
    switch (a2.key) {
      case "Escape":
        if (o2.popoverState.value !== 0 || !v(o2.panel) || !((i2 = v(o2.panel)) == null ? void 0 : i2.contains(document.activeElement)))
          return;
        a2.preventDefault(), a2.stopPropagation(), o2.closePopover(), (l2 = v(o2.button)) == null || l2.focus();
        break;
    }
  }
  return () => {
    let a2 = { open: o2.popoverState.value === 0, close: o2.close }, i2 = { ref: o2.panel, id: o2.panelId, onKeydown: d2 };
    return x({ props: __spreadValues(__spreadValues({}, t2), i2), slot: a2, attrs: n2, slots: u2, features: 1 | 2, visible: s2.value, name: "PopoverPanel" });
  };
} });
defineComponent({ name: "PopoverGroup", props: { as: { type: [Object, String], default: "div" } }, setup(t2, { attrs: n2, slots: u2 }) {
  let e2 = ref(null), o2 = ref([]);
  function r2(i2) {
    let l2 = o2.value.indexOf(i2);
    l2 !== -1 && o2.value.splice(l2, 1);
  }
  function s2(i2) {
    return o2.value.push(i2), () => {
      r2(i2);
    };
  }
  function d2() {
    var l2;
    let i2 = document.activeElement;
    return ((l2 = v(e2)) == null ? void 0 : l2.contains(i2)) ? true : o2.value.some((c2) => {
      var p2, f2;
      return ((p2 = document.getElementById(c2.buttonId)) == null ? void 0 : p2.contains(i2)) || ((f2 = document.getElementById(c2.panelId)) == null ? void 0 : f2.contains(i2));
    });
  }
  function a2(i2) {
    for (let l2 of o2.value)
      l2.buttonId !== i2 && l2.close();
  }
  return provide(Ut, { registerPopover: s2, unregisterPopover: r2, isFocusWithinPopoverGroup: d2, closeOthers: a2 }), () => x({ props: __spreadValues(__spreadValues({}, t2), { ref: e2 }), slot: {}, attrs: n2, slots: u2, name: "PopoverGroup" });
} });
var _t = Symbol("LabelContext");
function qt() {
  let t2 = inject(_t, null);
  if (t2 === null) {
    let n2 = new Error("You used a <Label /> component, but it is not inside a parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(n2, qt), n2;
  }
  return t2;
}
function fe({ slot: t2 = {}, name: n2 = "Label", props: u2 = {} } = {}) {
  let e2 = ref([]);
  function o2(r2) {
    return e2.value.push(r2), () => {
      let s2 = e2.value.indexOf(r2);
      s2 !== -1 && e2.value.splice(s2, 1);
    };
  }
  return provide(_t, { register: o2, slot: t2, name: n2, props: u2 }), computed(() => e2.value.length > 0 ? e2.value.join(" ") : void 0);
}
defineComponent({ name: "Label", props: { as: { type: [Object, String], default: "label" }, passive: { type: [Boolean], default: false } }, setup(t2, { slots: n2, attrs: u2 }) {
  let e2 = qt(), o2 = `headlessui-label-${h()}`;
  return onMounted(() => onUnmounted(e2.register(o2))), () => {
    let { name: r2 = "Label", slot: s2 = {}, props: d2 = {} } = e2, _a = t2, { passive: a2 } = _a, i2 = __objRest(_a, ["passive"]), l2 = __spreadProps(__spreadValues({}, Object.entries(d2).reduce((p2, [f2, b2]) => Object.assign(p2, { [f2]: unref(b2) }), {})), { id: o2 }), c2 = __spreadValues(__spreadValues({}, i2), l2);
    return a2 && delete c2.onClick, x({ props: c2, slot: s2, attrs: u2, slots: n2, name: r2 });
  };
} });
var Qt = Symbol("RadioGroupContext");
function Jt(t2) {
  let n2 = inject(Qt, null);
  if (n2 === null) {
    let u2 = new Error(`<${t2} /> is missing a parent <RadioGroup /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(u2, Jt), u2;
  }
  return n2;
}
defineComponent({ name: "RadioGroup", emits: { "update:modelValue": (t2) => true }, props: { as: { type: [Object, String], default: "div" }, disabled: { type: [Boolean], default: false }, modelValue: { type: [Object, String, Number, Boolean] } }, setup(t2, { emit: n2, attrs: u2, slots: e2 }) {
  let o2 = ref(null), r2 = ref([]), s2 = fe({ name: "RadioGroupLabel" }), d2 = G({ name: "RadioGroupDescription" }), a2 = computed(() => t2.modelValue), i2 = { options: r2, value: a2, disabled: computed(() => t2.disabled), firstOption: computed(() => r2.value.find((p2) => !p2.propsRef.disabled)), containsCheckedOption: computed(() => r2.value.some((p2) => toRaw(p2.propsRef.value) === toRaw(t2.modelValue))), change(p2) {
    var b2;
    if (t2.disabled || a2.value === p2)
      return false;
    let f2 = (b2 = r2.value.find((m2) => toRaw(m2.propsRef.value) === toRaw(p2))) == null ? void 0 : b2.propsRef;
    return (f2 == null ? void 0 : f2.disabled) ? false : (n2("update:modelValue", p2), true);
  }, registerOption(p2) {
    var b2;
    let f2 = Array.from((b2 = o2.value) == null ? void 0 : b2.querySelectorAll('[id^="headlessui-radiogroup-option-"]')).reduce((m2, g2, S2) => Object.assign(m2, { [g2.id]: S2 }), {});
    r2.value.push(p2), r2.value.sort((m2, g2) => f2[m2.id] - f2[g2.id]);
  }, unregisterOption(p2) {
    let f2 = r2.value.findIndex((b2) => b2.id === p2);
    f2 !== -1 && r2.value.splice(f2, 1);
  } };
  provide(Qt, i2), Y({ container: computed(() => v(o2)), accept(p2) {
    return p2.getAttribute("role") === "radio" ? NodeFilter.FILTER_REJECT : p2.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(p2) {
    p2.setAttribute("role", "none");
  } });
  function l2(p2) {
    if (!o2.value || !o2.value.contains(p2.target))
      return;
    let f2 = r2.value.filter((b2) => b2.propsRef.disabled === false).map((b2) => b2.element);
    switch (p2.key) {
      case "ArrowLeft":
      case "ArrowUp":
        if (p2.preventDefault(), p2.stopPropagation(), O(f2, 2 | 16) === 2) {
          let m2 = r2.value.find((g2) => g2.element === document.activeElement);
          m2 && i2.change(m2.propsRef.value);
        }
        break;
      case "ArrowRight":
      case "ArrowDown":
        if (p2.preventDefault(), p2.stopPropagation(), O(f2, 4 | 16) === 2) {
          let m2 = r2.value.find((g2) => g2.element === document.activeElement);
          m2 && i2.change(m2.propsRef.value);
        }
        break;
      case " ":
        {
          p2.preventDefault(), p2.stopPropagation();
          let b2 = r2.value.find((m2) => m2.element === document.activeElement);
          b2 && i2.change(b2.propsRef.value);
        }
        break;
    }
  }
  let c2 = `headlessui-radiogroup-${h()}`;
  return () => {
    let _a = t2, { modelValue: p2, disabled: f2 } = _a, b2 = __objRest(_a, ["modelValue", "disabled"]), m2 = { ref: o2, id: c2, role: "radiogroup", "aria-labelledby": s2.value, "aria-describedby": d2.value, onKeydown: l2 };
    return x({ props: __spreadValues(__spreadValues({}, b2), m2), slot: {}, attrs: u2, slots: e2, name: "RadioGroup" });
  };
} });
defineComponent({ name: "RadioGroupOption", props: { as: { type: [Object, String], default: "div" }, value: { type: [Object, String, Number, Boolean] }, disabled: { type: Boolean, default: false } }, setup(t2, { attrs: n2, slots: u2 }) {
  let e2 = Jt("RadioGroupOption"), o2 = `headlessui-radiogroup-option-${h()}`, r2 = fe({ name: "RadioGroupLabel" }), s2 = G({ name: "RadioGroupDescription" }), d2 = ref(null), a2 = computed(() => ({ value: t2.value, disabled: t2.disabled })), i2 = ref(1);
  onMounted(() => e2.registerOption({ id: o2, element: d2, propsRef: a2 })), onUnmounted(() => e2.unregisterOption(o2));
  let l2 = computed(() => {
    var S2;
    return ((S2 = e2.firstOption.value) == null ? void 0 : S2.id) === o2;
  }), c2 = computed(() => e2.disabled.value || t2.disabled), p2 = computed(() => toRaw(e2.value.value) === toRaw(t2.value)), f2 = computed(() => c2.value ? -1 : p2.value || !e2.containsCheckedOption.value && l2.value ? 0 : -1);
  function b2() {
    var S2;
    !e2.change(t2.value) || (i2.value |= 2, (S2 = d2.value) == null || S2.focus());
  }
  function m2() {
    i2.value |= 2;
  }
  function g2() {
    i2.value &= ~2;
  }
  return () => {
    let S2 = L(t2, ["value", "disabled"]), y2 = { checked: p2.value, disabled: c2.value, active: Boolean(i2.value & 2) }, R2 = { id: o2, ref: d2, role: "radio", "aria-checked": p2.value ? "true" : "false", "aria-labelledby": r2.value, "aria-describedby": s2.value, "aria-disabled": c2.value ? true : void 0, tabIndex: f2.value, onClick: c2.value ? void 0 : b2, onFocus: c2.value ? void 0 : m2, onBlur: c2.value ? void 0 : g2 };
    return x({ props: __spreadValues(__spreadValues({}, S2), R2), slot: y2, attrs: n2, slots: u2, name: "RadioGroupOption" });
  };
} });
var Zt = Symbol("GroupContext");
defineComponent({ name: "SwitchGroup", props: { as: { type: [Object, String], default: "template" } }, setup(t2, { slots: n2, attrs: u2 }) {
  let e2 = ref(null), o2 = fe({ name: "SwitchLabel", props: { onClick() {
    !e2.value || (e2.value.click(), e2.value.focus({ preventScroll: true }));
  } } }), r2 = G({ name: "SwitchDescription" });
  return provide(Zt, { switchRef: e2, labelledby: o2, describedby: r2 }), () => x({ props: t2, slot: {}, slots: n2, attrs: u2, name: "SwitchGroup" });
} });
defineComponent({ name: "Switch", emits: { "update:modelValue": (t2) => true }, props: { as: { type: [Object, String], default: "button" }, modelValue: { type: Boolean, default: false } }, setup(t2, { emit: n2, attrs: u2, slots: e2 }) {
  let o2 = inject(Zt, null), r2 = `headlessui-switch-${h()}`;
  function s2() {
    n2("update:modelValue", !t2.modelValue);
  }
  let d2 = ref(null), a2 = o2 === null ? d2 : o2.switchRef, i2 = P(computed(() => ({ as: t2.as, type: u2.type })), a2);
  function l2(f2) {
    f2.preventDefault(), s2();
  }
  function c2(f2) {
    f2.key !== "Tab" && f2.preventDefault(), f2.key === " " && s2();
  }
  function p2(f2) {
    f2.preventDefault();
  }
  return () => {
    let f2 = { checked: t2.modelValue }, b2 = { id: r2, ref: a2, role: "switch", type: i2.value, tabIndex: 0, "aria-checked": t2.modelValue, "aria-labelledby": o2 == null ? void 0 : o2.labelledby.value, "aria-describedby": o2 == null ? void 0 : o2.describedby.value, onClick: l2, onKeyup: c2, onKeypress: p2 };
    return x({ props: __spreadValues(__spreadValues({}, t2), b2), slot: f2, attrs: u2, slots: e2, name: "Switch" });
  };
} });
var oo = Symbol("TabsContext");
function ve(t2) {
  let n2 = inject(oo, null);
  if (n2 === null) {
    let u2 = new Error(`<${t2} /> is missing a parent <TabGroup /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(u2, ve), u2;
  }
  return n2;
}
defineComponent({ name: "TabGroup", emits: { change: (t2) => true }, props: { as: { type: [Object, String], default: "template" }, selectedIndex: { type: [Number], default: null }, defaultIndex: { type: [Number], default: 0 }, vertical: { type: [Boolean], default: false }, manual: { type: [Boolean], default: false } }, setup(t2, { slots: n2, attrs: u2, emit: e2 }) {
  let o2 = ref(null), r2 = ref([]), s2 = ref([]), d2 = { selectedIndex: o2, orientation: computed(() => t2.vertical ? "vertical" : "horizontal"), activation: computed(() => t2.manual ? "manual" : "auto"), tabs: r2, panels: s2, setSelectedIndex(a2) {
    o2.value !== a2 && (o2.value = a2, e2("change", a2));
  }, registerTab(a2) {
    r2.value.includes(a2) || r2.value.push(a2);
  }, unregisterTab(a2) {
    let i2 = r2.value.indexOf(a2);
    i2 !== -1 && r2.value.splice(i2, 1);
  }, registerPanel(a2) {
    s2.value.includes(a2) || s2.value.push(a2);
  }, unregisterPanel(a2) {
    let i2 = s2.value.indexOf(a2);
    i2 !== -1 && s2.value.splice(i2, 1);
  } };
  return provide(oo, d2), watchEffect(() => {
    var c2;
    if (d2.tabs.value.length <= 0 || t2.selectedIndex === null && o2.value !== null)
      return;
    let a2 = d2.tabs.value.map((p2) => v(p2)).filter(Boolean), i2 = a2.filter((p2) => !p2.hasAttribute("disabled")), l2 = (c2 = t2.selectedIndex) != null ? c2 : t2.defaultIndex;
    if (l2 < 0)
      o2.value = a2.indexOf(i2[0]);
    else if (l2 > d2.tabs.value.length)
      o2.value = a2.indexOf(i2[i2.length - 1]);
    else {
      let p2 = a2.slice(0, l2), b2 = [...a2.slice(l2), ...p2].find((m2) => i2.includes(m2));
      if (!b2)
        return;
      o2.value = a2.indexOf(b2);
    }
  }), () => {
    let a2 = { selectedIndex: o2.value };
    return x({ props: L(t2, ["selectedIndex", "defaultIndex", "manual", "vertical", "onChange"]), slot: a2, slots: n2, attrs: u2, name: "TabGroup" });
  };
} });
defineComponent({ name: "TabList", props: { as: { type: [Object, String], default: "div" } }, setup(t2, { attrs: n2, slots: u2 }) {
  let e2 = ve("TabList");
  return () => {
    let o2 = { selectedIndex: e2.selectedIndex.value }, r2 = { role: "tablist", "aria-orientation": e2.orientation.value };
    return x({ props: __spreadValues(__spreadValues({}, t2), r2), slot: o2, attrs: n2, slots: u2, name: "TabList" });
  };
} });
defineComponent({ name: "Tab", props: { as: { type: [Object, String], default: "button" }, disabled: { type: [Boolean], default: false } }, setup(t2, { attrs: n2, slots: u2 }) {
  let e2 = ve("Tab"), o2 = `headlessui-tabs-tab-${h()}`, r2 = ref();
  onMounted(() => e2.registerTab(r2)), onUnmounted(() => e2.unregisterTab(r2));
  let s2 = computed(() => e2.tabs.value.indexOf(r2)), d2 = computed(() => s2.value === e2.selectedIndex.value);
  function a2(p2) {
    let f2 = e2.tabs.value.map((b2) => v(b2)).filter(Boolean);
    if (p2.key === " " || p2.key === "Enter") {
      p2.preventDefault(), p2.stopPropagation(), e2.setSelectedIndex(s2.value);
      return;
    }
    switch (p2.key) {
      case "Home":
      case "PageUp":
        return p2.preventDefault(), p2.stopPropagation(), O(f2, 1);
      case "End":
      case "PageDown":
        return p2.preventDefault(), p2.stopPropagation(), O(f2, 8);
    }
    return T(e2.orientation.value, { vertical() {
      if (p2.key === "ArrowUp")
        return O(f2, 2 | 16);
      if (p2.key === "ArrowDown")
        return O(f2, 4 | 16);
    }, horizontal() {
      if (p2.key === "ArrowLeft")
        return O(f2, 2 | 16);
      if (p2.key === "ArrowRight")
        return O(f2, 4 | 16);
    } });
  }
  function i2() {
    var p2;
    (p2 = v(r2)) == null || p2.focus();
  }
  function l2() {
    var p2;
    t2.disabled || ((p2 = v(r2)) == null || p2.focus(), e2.setSelectedIndex(s2.value));
  }
  let c2 = P(computed(() => ({ as: t2.as, type: n2.type })), r2);
  return () => {
    var b2, m2;
    let p2 = { selected: d2.value }, f2 = { ref: r2, onKeydown: a2, onFocus: e2.activation.value === "manual" ? i2 : l2, onClick: l2, id: o2, role: "tab", type: c2.value, "aria-controls": (m2 = (b2 = e2.panels.value[s2.value]) == null ? void 0 : b2.value) == null ? void 0 : m2.id, "aria-selected": d2.value, tabIndex: d2.value ? 0 : -1, disabled: t2.disabled ? true : void 0 };
    return x({ props: __spreadValues(__spreadValues({}, t2), f2), slot: p2, attrs: n2, slots: u2, name: "Tab" });
  };
} });
defineComponent({ name: "TabPanels", props: { as: { type: [Object, String], default: "div" } }, setup(t2, { slots: n2, attrs: u2 }) {
  let e2 = ve("TabPanels");
  return () => {
    let o2 = { selectedIndex: e2.selectedIndex.value };
    return x({ props: t2, slot: o2, attrs: u2, slots: n2, name: "TabPanels" });
  };
} });
defineComponent({ name: "TabPanel", props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: false }, unmount: { type: Boolean, default: true } }, setup(t2, { attrs: n2, slots: u2 }) {
  let e2 = ve("TabPanel"), o2 = `headlessui-tabs-panel-${h()}`, r2 = ref();
  onMounted(() => e2.registerPanel(r2)), onUnmounted(() => e2.unregisterPanel(r2));
  let s2 = computed(() => e2.panels.value.indexOf(r2)), d2 = computed(() => s2.value === e2.selectedIndex.value);
  return () => {
    var l2, c2;
    let a2 = { selected: d2.value }, i2 = { ref: r2, id: o2, role: "tabpanel", "aria-labelledby": (c2 = (l2 = e2.tabs.value[s2.value]) == null ? void 0 : l2.value) == null ? void 0 : c2.id, tabIndex: d2.value ? 0 : -1 };
    return x({ props: __spreadValues(__spreadValues({}, t2), i2), slot: a2, attrs: n2, slots: u2, features: 2 | 1, visible: d2.value, name: "TabPanel" });
  };
} });
function no(t2) {
  let n2 = { called: false };
  return (...u2) => {
    if (!n2.called)
      return n2.called = true, t2(...u2);
  };
}
function Ze() {
  let t2 = [], n2 = [], u2 = { enqueue(e2) {
    n2.push(e2);
  }, requestAnimationFrame(...e2) {
    let o2 = requestAnimationFrame(...e2);
    u2.add(() => cancelAnimationFrame(o2));
  }, nextFrame(...e2) {
    u2.requestAnimationFrame(() => {
      u2.requestAnimationFrame(...e2);
    });
  }, setTimeout(...e2) {
    let o2 = setTimeout(...e2);
    u2.add(() => clearTimeout(o2));
  }, add(e2) {
    t2.push(e2);
  }, dispose() {
    for (let e2 of t2.splice(0))
      e2();
  }, async workQueue() {
    for (let e2 of n2.splice(0))
      await e2();
  } };
  return u2;
}
function et(t2, ...n2) {
  t2 && n2.length > 0 && t2.classList.add(...n2);
}
function Fe(t2, ...n2) {
  t2 && n2.length > 0 && t2.classList.remove(...n2);
}
function $n(t2, n2) {
  let u2 = Ze();
  if (!t2)
    return u2.dispose;
  let { transitionDuration: e2, transitionDelay: o2 } = getComputedStyle(t2), [r2, s2] = [e2, o2].map((d2) => {
    let [a2 = 0] = d2.split(",").filter(Boolean).map((i2) => i2.includes("ms") ? parseFloat(i2) : parseFloat(i2) * 1e3).sort((i2, l2) => l2 - i2);
    return a2;
  });
  return r2 !== 0 ? u2.setTimeout(() => n2("finished"), r2 + s2) : n2("finished"), u2.add(() => n2("cancelled")), u2.dispose;
}
function tt(t2, n2, u2, e2, o2, r2) {
  let s2 = Ze(), d2 = r2 !== void 0 ? no(r2) : () => {
  };
  return Fe(t2, ...o2), et(t2, ...n2, ...u2), s2.nextFrame(() => {
    Fe(t2, ...u2), et(t2, ...e2), s2.add($n(t2, (a2) => (Fe(t2, ...e2, ...n2), et(t2, ...o2), d2(a2))));
  }), s2.add(() => Fe(t2, ...n2, ...u2, ...e2, ...o2)), s2.add(() => d2("cancelled")), s2.dispose;
}
function Q(t2 = "") {
  return t2.split(" ").filter((n2) => n2.trim().length > 1);
}
var lt = Symbol("TransitionContext");
function _n() {
  return inject(lt, null) !== null;
}
function qn() {
  let t2 = inject(lt, null);
  if (t2 === null)
    throw new Error("A <TransitionChild /> is used but it is missing a parent <TransitionRoot />.");
  return t2;
}
function zn() {
  let t2 = inject(rt, null);
  if (t2 === null)
    throw new Error("A <TransitionChild /> is used but it is missing a parent <TransitionRoot />.");
  return t2;
}
var rt = Symbol("NestingContext");
function He(t2) {
  return "children" in t2 ? He(t2.children) : t2.value.filter(({ state: n2 }) => n2 === "visible").length > 0;
}
function io(t2) {
  let n2 = ref([]), u2 = ref(false);
  onMounted(() => u2.value = true), onUnmounted(() => u2.value = false);
  function e2(r2, s2 = 1) {
    let d2 = n2.value.findIndex(({ id: a2 }) => a2 === r2);
    d2 !== -1 && (T(s2, { [0]() {
      n2.value.splice(d2, 1);
    }, [1]() {
      n2.value[d2].state = "hidden";
    } }), !He(n2) && u2.value && (t2 == null || t2()));
  }
  function o2(r2) {
    let s2 = n2.value.find(({ id: d2 }) => d2 === r2);
    return s2 ? s2.state !== "visible" && (s2.state = "visible") : n2.value.push({ id: r2, state: "visible" }), () => e2(r2, 0);
  }
  return { children: n2, register: o2, unregister: e2 };
}
var uo = 1, Qn = defineComponent({ props: { as: { type: [Object, String], default: "div" }, show: { type: [Boolean], default: null }, unmount: { type: [Boolean], default: true }, appear: { type: [Boolean], default: false }, enter: { type: [String], default: "" }, enterFrom: { type: [String], default: "" }, enterTo: { type: [String], default: "" }, entered: { type: [String], default: "" }, leave: { type: [String], default: "" }, leaveFrom: { type: [String], default: "" }, leaveTo: { type: [String], default: "" } }, emits: { beforeEnter: () => true, afterEnter: () => true, beforeLeave: () => true, afterLeave: () => true }, setup(t2, { emit: n2, attrs: u2, slots: e2 }) {
  if (!_n() && it())
    return () => h$3(Yn, __spreadProps(__spreadValues({}, t2), { onBeforeEnter: () => n2("beforeEnter"), onAfterEnter: () => n2("afterEnter"), onBeforeLeave: () => n2("beforeLeave"), onAfterLeave: () => n2("afterLeave") }), e2);
  let o2 = ref(null), r2 = ref("visible"), s2 = computed(() => t2.unmount ? 0 : 1), { show: d2, appear: a2 } = qn(), { register: i2, unregister: l2 } = zn(), c2 = { value: true }, p2 = h(), f2 = { value: false }, b2 = io(() => {
    f2.value || (r2.value = "hidden", l2(p2), n2("afterLeave"));
  });
  onMounted(() => {
    let F2 = i2(p2);
    onUnmounted(F2);
  }), watchEffect(() => {
    if (s2.value === 1 && !!p2) {
      if (d2 && r2.value !== "visible") {
        r2.value = "visible";
        return;
      }
      T(r2.value, { hidden: () => l2(p2), visible: () => i2(p2) });
    }
  });
  let m2 = Q(t2.enter), g2 = Q(t2.enterFrom), S2 = Q(t2.enterTo), y2 = Q(t2.entered), R2 = Q(t2.leave), E2 = Q(t2.leaveFrom), D2 = Q(t2.leaveTo);
  onMounted(() => {
    watchEffect(() => {
      if (r2.value === "visible") {
        let F2 = v(o2);
        if (F2 instanceof Comment && F2.data === "")
          throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
      }
    });
  });
  function w2(F2) {
    let xe = c2.value && !a2.value, U2 = v(o2);
    !U2 || !(U2 instanceof HTMLElement) || xe || (f2.value = true, d2.value && n2("beforeEnter"), d2.value || n2("beforeLeave"), F2(d2.value ? tt(U2, m2, g2, S2, y2, (ye) => {
      f2.value = false, ye === "finished" && n2("afterEnter");
    }) : tt(U2, R2, E2, D2, y2, (ye) => {
      f2.value = false, ye === "finished" && (He(b2) || (r2.value = "hidden", l2(p2), n2("afterLeave")));
    })));
  }
  return onMounted(() => {
    watch([d2, a2], (F2, xe, U2) => {
      w2(U2), c2.value = false;
    }, { immediate: true });
  }), provide(rt, b2), M(computed(() => T(r2.value, { visible: 0, hidden: 1 }))), () => {
    let _a = t2, { appear: F2, show: xe, enter: U2, enterFrom: ye, enterTo: Xn, entered: Zn, leave: el, leaveFrom: tl, leaveTo: ol } = _a, so = __objRest(_a, ["appear", "show", "enter", "enterFrom", "enterTo", "entered", "leave", "leaveFrom", "leaveTo"]);
    return x({ props: __spreadValues(__spreadValues({}, so), { ref: o2 }), slot: {}, slots: e2, attrs: u2, features: uo, visible: r2.value === "visible", name: "TransitionChild" });
  };
} }), Jn = Qn, Yn = defineComponent({ inheritAttrs: false, props: { as: { type: [Object, String], default: "div" }, show: { type: [Boolean], default: null }, unmount: { type: [Boolean], default: true }, appear: { type: [Boolean], default: false }, enter: { type: [String], default: "" }, enterFrom: { type: [String], default: "" }, enterTo: { type: [String], default: "" }, entered: { type: [String], default: "" }, leave: { type: [String], default: "" }, leaveFrom: { type: [String], default: "" }, leaveTo: { type: [String], default: "" } }, emits: { beforeEnter: () => true, afterEnter: () => true, beforeLeave: () => true, afterLeave: () => true }, setup(t2, { emit: n2, attrs: u2, slots: e2 }) {
  let o2 = I(), r2 = computed(() => t2.show === null && o2 !== null ? T(o2.value, { [0]: true, [1]: false }) : t2.show);
  watchEffect(() => {
    if (![true, false].includes(r2.value))
      throw new Error('A <Transition /> is used but it is missing a `:show="true | false"` prop.');
  });
  let s2 = ref(r2.value ? "visible" : "hidden"), d2 = io(() => {
    s2.value = "hidden";
  }), a2 = { value: true }, i2 = { show: r2, appear: computed(() => t2.appear || !a2.value) };
  return onMounted(() => {
    watchEffect(() => {
      a2.value = false, r2.value ? s2.value = "visible" : He(d2) || (s2.value = "hidden");
    });
  }), provide(rt, d2), provide(lt, i2), () => {
    let l2 = L(t2, ["show", "appear", "unmount"]), c2 = { unmount: t2.unmount };
    return x({ props: __spreadProps(__spreadValues({}, c2), { as: "template" }), slot: {}, slots: __spreadProps(__spreadValues({}, e2), { default: () => [h$3(Jn, __spreadValues(__spreadValues(__spreadValues({ onBeforeEnter: () => n2("beforeEnter"), onAfterEnter: () => n2("afterEnter"), onBeforeLeave: () => n2("beforeLeave"), onAfterLeave: () => n2("afterLeave") }, u2), c2), l2), e2.default)] }), attrs: {}, features: uo, visible: s2.value === "visible", name: "Transition" });
  };
} });
var ModalTitle_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1$k = { class: "container" };
const _sfc_main$k = {
  props: { title: String, contents: String },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$k, [
        createVNode(unref(qr), { as: "h3" }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(__props.title), 1)
          ]),
          _: 1
        }),
        createBaseVNode("p", null, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(__props.contents), 1)
          ], true)
        ])
      ]);
    };
  }
};
var ModalTitle = /* @__PURE__ */ _export_sfc$1(_sfc_main$k, [["__scopeId", "data-v-c0a30450"]]);
var Connecting_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1$j = { class: "connecting" };
const _hoisted_2$i = { class: "inner" };
const _hoisted_3$b = /* @__PURE__ */ createTextVNode(" Accept the request from your browser extension to continue ");
const _sfc_main$j = {
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$j, [
        createVNode(unref(Loading$1), { class: "spinner" }),
        createBaseVNode("div", _hoisted_2$i, [
          createVNode(ModalTitle, { title: "Waiting for approval" }, {
            default: withCtx(() => [
              _hoisted_3$b
            ]),
            _: 1
          })
        ])
      ]);
    };
  }
};
var Connecting = /* @__PURE__ */ _export_sfc$1(_sfc_main$j, [["__scopeId", "data-v-50b9deb1"]]);
var DefaultAvatar = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAIAAADTED8xAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAABAKADAAQAAAABAAABAAAAAABn6hpJAAALnklEQVR4Ae2dv48cZxnH593dw+dYMQZkmdic6axECk6MCytyOlLQoFAg4Ya/gJoKqCgjCur8A0GkSI/pIkUuTJCxRRoioSMJzsnCXBR82Lc7zN7crL2zMzs/9rnLPu/3Y0WZndnZZ9/38/1+fOdLrA3pg3sJvyCgSmCgunH2DYEpAQSgB9IEEEA6fjaPAHRAmgACSMfP5hGADkgTQADp+Nk8AtABaQIIIB0/m0cAOiBNAAGk42fzCEAHpAkggHT8bB4B6IA0AQSQjp/NIwAdkCaAANLxs3kEoAPSBBBAOn42jwB0QJoAAkjHz+YRgA5IE0AA6fjZPALQAWkCCCAdP5tHADogTQABpONn8whAB6QJIIB0/GweAeiANAEEkI6fzSMAHZAmgADS8bN5BKAD0gQQQDp+No8AdECaAAJIx8/mEYAOSBNAAOn42TwC0AFpAgggHT+bRwA6IE0AAaTjZ/MIQAekCSCAdPxsHgHogDQBBJCOn80jAB2QJoAA0vGzeQSgA9IEEEA6fjaPAHRAmgACSMfP5hGADkgTQADp+Nk8AtABaQIIIB0/m0cAOiBNAAGk42fzCEAHpAkggHT8bB4B6IA0AQSQjp/NIwAdkCaAANLxs3kEoAPSBBBAOn42jwB0QJoAAkjHz+YRgA5IE0AA6fjZPALQAWkCCCAdP5tHgKPpwPhJkv1j8iubs7drMokhiwRGi5e40p/A3m56/07ycDvd38uGhNFmcmYrnLucbJ7uPPPxo8nt9yZ3b052Pp6OGm6Ei68Mr/44XLreeRQvqCcQ0gf36p/lmS4Edj5Kt2+l6aT0mhAGYetacvbF0vUlp+nnf9//w6/S//xr8Z7BpeujH/0yOXFy8Smu9CCAAD2gVbwk/ewv6acfVjxRXArnr4QXXi3Olh3TT/62/84v0v99WXfT4MJLoxtvJSdO1d3A9fYE+DNAe1a1dza2P3tlpkd2W+2I4onG9mc3Tg4MSeoNKYZxbCaAAM2Mlt/Rpv35hEYH2rQ/H4UDy0Np/ywCtGdVcWf79ucvXuJA+/bno3CgIo/ulxCgO7PiFV3bn7+u0oGu7c9H4UARRf8jAvRk16/9+ZuVHOjX/nwUDvTMr3gZAhQkuhxXaX/+PjMHVml/PgoHukRXvpcfg5aJNJ6v3v6nb7HxzfEf317yE8+ndzY94mejTYSqn0eAai51Vw3bnz7cGd++mewb/R8TSYIDdaktuc63QEvglJ9a5/Zna+V7oXJgLc4RoAWkg1vWvP35NnCgbZzFfQhQkFh6dNH+fAc4sDTJ8pMIUCayeO6o/fnicWAxxLorCFBH5vC6u/bn68aBhlyLpxGgIFF1dNr+fCs4UBVp+RoClInMzl23P98FDszSrHuAANVkImg/DlRHO38VAeZ5HJxF0/58b3wdqMi4uIQABYniGFn7823hQBFv+YgAc0SibD8OzGU8f4IAT3lE3H4ceBrz/CMEOOQRfftxYL75h2cIMAUh0v48c/48cNj9gwMCaLUfB55tf/ZYXQCp3/ufzZ6vAzkNaQFk259njwPSXwHE248D0l8BaH8ef/Zv8a8Dit8C0f5Z+/MHyg7ICUD7S+0Xd0BLANpf2X5lB4QEoP1L2i/rgIoAtL+x/ZoOSAhA+1u2X9CB+AWg/Z3ar+ZA5ALQ/h7tl3IgZgFof+/26zgQrQC0f8X2izgQpwC036T9Cg5EKADtN2x/9A7EJgDtN29/3A5EJQDtP6L2R+xAPALQ/iNtf6wORCIA7T+G9kfpQAwC0P5ja398DrgXgPYfc/sjc8C5ADsfZR+4a9OA/34x/vOfDD+z0WZVazxl+vfI3v11Mhmv8Rqbl+ZZgL3ddPtW8xbb3TH+6/vJk8ft7uWuQwKTf3w4ufV71zgcC5Dev5OmExP66YNPs0/tNRmlNmT8wTvJ2Oyjjo+fnmMBkofbVrzSnU+sRqnNSfe+SP951++u3QowfpLu71lxT7/ctRolOCf9t+PfPtwKIFg0tnwEBNwKMNwIo00rIOHUaatRgnPCNy743bVbATLkZ7asuIezjiO0gtBvTth8Pnzn5X6vXYdXORYgnLscgs36w7fOhzNn1yEPd2sYvnYjGW64W/ZswTYFmo071gebp8PWNat3HH7v9WTja1bTROYMvntlcO2nrjfrWYAM/NkXw/krNgE89/zw+z9IRo5/M7Ph0HrK4MJLo5/8JhkMW79iHW90LkCShBdetXIg+y5oePUNHGjT02n7b7yVnDjV5uZ1vse9ABlcHDjmhkXT/oxbDALgwHEKEFP74xEAB47HgcjaH5UAOHDUDsTX/tgEwIGjcyDK9kcoAA4chQOxtj9OAXDA1oGI2x+tADhg5UDc7Y9ZABxY3YHo2x+5ADiwigMK7Y9fABzo54BI+yUEwIGuDui0X0UAHGjvgFT7hQTAgTYOqLVfSwAcWO6AYPvlBMCBOgc0268oAA4sOiDbflEBcOBZB5TbrysADuQOiLdfWgAcoP3qAig7QPuz9LNfkfyd4Hwz/f4t+Hfqaf+sKggwRSHlAO2ftT97gACHNEQcoP3Pth8B5mhE7wDtn8v74ISvAHNMInaA9s8lXZwgQEGiOEbpAO0v4i0fEaBMJDuPzAHaX5FxcQkBChLzx2gcoP3zwZbPEKBMZHYegQO0f5Zm3QMEqCMzve7aAdq/LNriOQQoSNQcnTpA+2vyLF9GgDKRxXN3DtD+xRDrriBAHZm5644coP1zyTWdIEAToeJ5Fw7Q/iKutkcEaEsqu2/NHaD9HbIsbkWAgkS7o60Dox/+PBh9zhztbxdg+S4EKBNpPLdyIPtwy8HlN7PPWlzdAdrfmFrdDQhQR2bZ9dUdyNqfDcneIxx83ugqDtD+ZVE1PYcATYRqnl/FgVn789mrOED7a/JpexkB2pJavK+fA6X252P7OUD7F0PpegUBuhKbu7+rA5Xtzyd2dYD2zyXR9wQB+pIrXtfegSXtz4e1d4D2F/hXPSLAqgSz17dxoLH9+TraOED7DTIrRiBAQWK1Y+bA4OJrIVTwzC5Onzr4mU+bN5k68LPfha9/u/LmwaXroxu/TYz+60HlW0hdDOmDe1IbPtrN7u2m9+8kD7fT/b3sjcJoMzmzFc5dTjZPd37fx48mt9+b3L2Z7nycZqOGG+HiK8Orb4ZLr3cexQvqCSBAPZtVnhk/mb56uLHKjMPXZqMeP0pOdlfI4L3jHzGKf4tfyQ5Nqp+vPBt10kKkr4TD2r9pxfesa79mFggBMwIIYIaSQR4JIIDH1FizGQEEMEPJII8EEMBjaqzZjAACmKFkkEcCCOAxNdZsRgABzFAyyCMBBPCYGms2I4AAZigZ5JEAAnhMjTWbEUAAM5QM8kgAATymxprNCCCAGUoGeSSAAB5TY81mBBDADCWDPBJAAI+psWYzAghghpJBHgkggMfUWLMZAQQwQ8kgjwQQwGNqrNmMAAKYoWSQRwII4DE11mxGAAHMUDLIIwEE8JgaazYjgABmKBnkkQACeEyNNZsRQAAzlAzySAABPKbGms0IIIAZSgZ5JIAAHlNjzWYEEMAMJYM8EkAAj6mxZjMCCGCGkkEeCSCAx9RYsxkBBDBDySCPBBDAY2qs2YwAApihZJBHAgjgMTXWbEYAAcxQMsgjAQTwmBprNiOAAGYoGeSRAAJ4TI01mxFAADOUDPJIAAE8psaazQgggBlKBnkkgAAeU2PNZgQQwAwlgzwSQACPqbFmMwIIYIaSQR4JIIDH1FizGQEEMEPJII8EEMBjaqzZjAACmKFkkEcCCOAxNdZsRgABzFAyyCMBBPCYGms2I4AAZigZ5JEAAnhMjTWbEUAAM5QM8kgAATymxprNCCCAGUoGeSSAAB5TY81mBBDADCWDPBJAAI+psWYzAghghpJBHgkggMfUWLMZAQQwQ8kgjwQQwGNqrNmMAAKYoWSQRwII4DE11mxGAAHMUDLIIwEE8JgaazYj8H82S7nbjDptnAAAAABJRU5ErkJggg==";
var Avatar$1 = "";
var Avatar_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1$i = { class: "avatar" };
const _hoisted_2$h = ["src"];
const _sfc_main$i = {
  props: { ring: Boolean },
  setup(__props) {
    const metadata = inject("contractMetadata");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("span", _hoisted_1$i, [
        createBaseVNode("img", {
          class: normalizeClass({ ring: __props.ring }),
          src: unref(metadata).avatarImage || unref(DefaultAvatar),
          alt: ""
        }, null, 10, _hoisted_2$h),
        createBaseVNode("span", null, [
          createVNode(unref(render$9), { "aria-hidden": "true" })
        ])
      ]);
    };
  }
};
var Avatar = /* @__PURE__ */ _export_sfc$1(_sfc_main$i, [["__scopeId", "data-v-3c5b8d7a"]]);
var AvatarMini_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1$h = { class: "avatar" };
const _hoisted_2$g = ["src"];
const _sfc_main$h = {
  setup(__props) {
    const metadata = inject("contractMetadata");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("span", _hoisted_1$h, [
        createBaseVNode("img", {
          src: unref(metadata).avatarImage || unref(DefaultAvatar),
          alt: ""
        }, null, 8, _hoisted_2$g)
      ]);
    };
  }
};
var AvatarMini = /* @__PURE__ */ _export_sfc$1(_sfc_main$h, [["__scopeId", "data-v-6293b51d"]]);
var AvatarFailed_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1$g = { class: "avatar" };
const _hoisted_2$f = ["src"];
const _sfc_main$g = {
  setup(__props) {
    const metadata = inject("contractMetadata");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("span", _hoisted_1$g, [
        createBaseVNode("img", {
          src: unref(metadata).avatarImage || unref(DefaultAvatar),
          alt: ""
        }, null, 8, _hoisted_2$f),
        createBaseVNode("span", null, [
          createVNode(unref(render$3), { "aria-hidden": "true" })
        ])
      ]);
    };
  }
};
var AvatarFailed = /* @__PURE__ */ _export_sfc$1(_sfc_main$g, [["__scopeId", "data-v-50218e7c"]]);
var AvatarError_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1$f = { class: "avatar" };
const _hoisted_2$e = ["src"];
const _sfc_main$f = {
  setup(__props) {
    const metadata = inject("contractMetadata");
    const image = computed(() => {
      var _a;
      return ((_a = metadata.value) == null ? void 0 : _a.avatarImage) || DefaultAvatar;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("span", _hoisted_1$f, [
        createBaseVNode("img", {
          src: unref(image),
          alt: ""
        }, null, 8, _hoisted_2$e),
        createBaseVNode("span", null, [
          createVNode(unref(render$b), { "aria-hidden": "true" })
        ])
      ]);
    };
  }
};
var AvatarError = /* @__PURE__ */ _export_sfc$1(_sfc_main$f, [["__scopeId", "data-v-1c35ac42"]]);
var AvatarSuccess_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1$e = { class: "avatar" };
const _hoisted_2$d = ["src"];
const _sfc_main$e = {
  props: { ring: Boolean },
  setup(__props) {
    const metadata = inject("contractMetadata");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("span", _hoisted_1$e, [
        createBaseVNode("img", {
          class: normalizeClass({ ring: __props.ring }),
          src: unref(metadata).avatarImage || unref(DefaultAvatar),
          alt: ""
        }, null, 10, _hoisted_2$d),
        createBaseVNode("span", null, [
          createVNode(unref(render$8), { "aria-hidden": "true" })
        ])
      ]);
    };
  }
};
var AvatarSuccess = /* @__PURE__ */ _export_sfc$1(_sfc_main$e, [["__scopeId", "data-v-1ebd8e85"]]);
var SocialLinks_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1$d = { class: "links" };
const _hoisted_2$c = ["href"];
const _hoisted_3$a = ["href"];
const _sfc_main$d = {
  setup(__props) {
    const platforms = {
      OPENSEA: {
        name: "OpenSea",
        icon: OpenSeaIcon
      },
      SOLANART: {
        name: "Solanart",
        icon: SolanartIcon
      },
      MAGIC_EDEN: {
        name: "MagicEden",
        icon: MagicEdenIcon
      },
      LOOKS_RARE: {
        name: "LooksRare",
        icon: LooksRareIcon
      }
    };
    const metadata = inject("contractMetadata");
    const marketplace = computed(() => {
      var _a;
      if ((_a = metadata.value) == null ? void 0 : _a.listing) {
        return __spreadProps(__spreadValues({}, platforms[metadata.value.listing.platform]), {
          url: metadata.value.listing.url
        });
      }
      return null;
    });
    return (_ctx, _cache) => {
      const _directive_tooltip = resolveDirective("tooltip");
      return openBlock(), createElementBlock("div", _hoisted_1$d, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(metadata).socials, (item) => {
          return openBlock(), createElementBlock("a", {
            key: item.url,
            href: item.url,
            target: "_blank"
          }, [
            createBaseVNode("span", null, toDisplayString(item.type), 1),
            item.type === "WEB" ? withDirectives((openBlock(), createBlock(unref(render$a), {
              key: 0,
              "aria-hidden": "true"
            }, null, 512)), [
              [_directive_tooltip, "Website"]
            ]) : createCommentVNode("", true),
            item.type === "TWITTER" ? withDirectives((openBlock(), createBlock(unref(TwitterIcon), {
              key: 1,
              "aria-hidden": "true"
            }, null, 512)), [
              [_directive_tooltip, "Twitter"]
            ]) : createCommentVNode("", true),
            item.type === "DISCORD" ? withDirectives((openBlock(), createBlock(unref(DiscordIcon), {
              key: 2,
              "aria-hidden": "true"
            }, null, 512)), [
              [_directive_tooltip, "Discord"]
            ]) : createCommentVNode("", true)
          ], 8, _hoisted_2$c);
        }), 128)),
        unref(marketplace) ? withDirectives((openBlock(), createElementBlock("a", {
          key: 0,
          href: unref(marketplace).url,
          target: "_blank"
        }, [
          createBaseVNode("span", null, "Buy on " + toDisplayString(unref(marketplace).name), 1),
          (openBlock(), createBlock(resolveDynamicComponent(unref(marketplace).icon), { "aria-hidden": "true" }))
        ], 8, _hoisted_3$a)), [
          [_directive_tooltip, `Buy on ${unref(marketplace).name}`]
        ]) : createCommentVNode("", true)
      ]);
    };
  }
};
var SocialLinks = /* @__PURE__ */ _export_sfc$1(_sfc_main$d, [["__scopeId", "data-v-0c884638"]]);
var StartHeader_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1$c = {
  key: 0,
  class: "banner-img"
};
const _hoisted_2$b = { class: "img" };
const _hoisted_3$9 = ["src"];
const _hoisted_4$9 = { class: "avatar-outer" };
const _hoisted_5$7 = {
  key: 1,
  class: "banner"
};
const _sfc_main$c = {
  setup(__props) {
    const metadata = inject("contractMetadata");
    return (_ctx, _cache) => {
      return unref(metadata).bannerImage ? (openBlock(), createElementBlock("div", _hoisted_1$c, [
        createBaseVNode("div", _hoisted_2$b, [
          createBaseVNode("img", {
            src: unref(metadata).bannerImage
          }, null, 8, _hoisted_3$9)
        ]),
        createBaseVNode("div", _hoisted_4$9, [
          createVNode(Avatar, { ring: "" })
        ])
      ])) : (openBlock(), createElementBlock("div", _hoisted_5$7, [
        createVNode(Avatar)
      ]));
    };
  }
};
var StartHeader = /* @__PURE__ */ _export_sfc$1(_sfc_main$c, [["__scopeId", "data-v-459eb8e8"]]);
var Error_vue_vue_type_style_index_0_scoped_true_lang = "";
const _withScopeId$2 = (n2) => (pushScopeId("data-v-5b9e2840"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$b = { class: "error" };
const _hoisted_2$a = { class: "avatar-outer" };
const _hoisted_3$8 = /* @__PURE__ */ createTextVNode(" Please try again or ");
const _hoisted_4$8 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("a", {
  href: "mailto:frontdesk@diamondhandshotel.com",
  class: "link"
}, "contact support", -1));
const _hoisted_5$6 = /* @__PURE__ */ createTextVNode(". ");
const _hoisted_6$2 = {
  key: 0,
  class: "fields"
};
const _hoisted_7$3 = {
  key: 1,
  class: "debug-info"
};
const _hoisted_8$2 = { key: 0 };
const _hoisted_9$2 = { key: 1 };
const _hoisted_10$2 = { class: "actions" };
const _sfc_main$b = {
  setup(__props) {
    const store2 = useStore();
    computed(() => store2.getters.response);
    const app = computed(() => store2.getters.app);
    const fields = computed(() => store2.getters.error.fields);
    const requestId = computed(() => store2.getters.error.requestId);
    const title2 = computed(() => {
      switch (store2.getters.error.code) {
        case "BAD_REQUEST":
          return "Bad request";
        case "BAD_CREDENTIALS":
          return "Unauthorized";
        case "CONNECTION_DENIED":
        case "NETWORK":
          return "Connection failed";
        case "SERVER_ERROR":
          return "Server error";
        default:
          return "Verification error";
      }
    });
    const message = computed(() => {
      switch (store2.getters.error.code) {
        case "CONNECTION_DENIED":
          return "You declined the connection request.";
        case "CHAIN_INVALID":
          return "You denied the request to switch chain.";
        case "SIGNATURE_DENIED":
          return "You declined the request to sign a verification message.";
        case "UNSUPPORTED_CHAIN":
          return "This build doesn't include dependancies for the requested chain. Install the combined bundle or correct chain bundle to continue.";
        case "NETWORK":
          return "Unable to connect to the Verify API. Check internet connection and @DiamondHH for incident alerts.";
        case "BAD_REQUEST":
        case "BAD_CREDENTIALS":
        case "UKNOWN":
          return store2.getters.error.message;
        case "SERVER_ERROR":
          return "Sorry, something went wrong during verification. Our engineers have been notified.";
        default:
          return "Sorry, something went wrong during verification.";
      }
    });
    const canRetry = computed(() => {
      switch (store2.getters.error.code) {
        case "UNSUPPORTED_CHAIN":
        case "BAD_REQUEST":
        case "BAD_CREDENTIALS":
        case "NETWORK":
          return false;
        default:
          return true;
      }
    });
    const retry = () => store2.commit("SET_VIEW", "START");
    const cancel = () => store2.commit("CLOSE_MODAL");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$b, [
        createBaseVNode("div", _hoisted_2$a, [
          createVNode(unref(AvatarError))
        ]),
        createVNode(ModalTitle, { title: unref(title2) }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(unref(message)) + " ", 1),
            unref(canRetry) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              _hoisted_3$8,
              _hoisted_4$8,
              _hoisted_5$6
            ], 64)) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["title"]),
        unref(fields) && unref(fields).length ? (openBlock(), createElementBlock("ul", _hoisted_6$2, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(fields), (field) => {
            return openBlock(), createElementBlock("li", { key: field }, toDisplayString(field), 1);
          }), 128))
        ])) : createCommentVNode("", true),
        unref(requestId) || unref(app) ? (openBlock(), createElementBlock("div", _hoisted_7$3, [
          unref(requestId) ? (openBlock(), createElementBlock("code", _hoisted_8$2, " Request ID: " + toDisplayString(unref(requestId)), 1)) : createCommentVNode("", true),
          unref(app).id ? (openBlock(), createElementBlock("code", _hoisted_9$2, " App ID: " + toDisplayString(unref(app).id), 1)) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_10$2, [
          unref(canRetry) ? (openBlock(), createElementBlock("button", {
            key: 0,
            onClick: retry,
            type: "button",
            class: "btn primary"
          }, "Try again")) : createCommentVNode("", true),
          createBaseVNode("button", {
            onClick: cancel,
            type: "button",
            class: "btn"
          }, "Cancel")
        ])
      ]);
    };
  }
};
var ErrorView = /* @__PURE__ */ _export_sfc$1(_sfc_main$b, [["__scopeId", "data-v-5b9e2840"]]);
var RateLimited_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1$a = { class: "rate-limited" };
const _hoisted_2$9 = { class: "avatar" };
const _hoisted_3$7 = /* @__PURE__ */ createTextVNode(" Sorry, you're making too many requests and have been rate limited. Please try again later. ");
const _hoisted_4$7 = {
  key: 0,
  class: "debug-info"
};
const _hoisted_5$5 = { key: 0 };
const _sfc_main$a = {
  setup(__props) {
    const store2 = useStore();
    const requestId = computed(() => store2.getters.error.requestId);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$a, [
        createBaseVNode("div", _hoisted_2$9, [
          createBaseVNode("span", null, [
            createVNode(unref(render$6), { "aria-hidden": "true" })
          ])
        ]),
        createVNode(ModalTitle, { title: "Try again later" }, {
          default: withCtx(() => [
            _hoisted_3$7
          ]),
          _: 1
        }),
        unref(requestId) || _ctx.app ? (openBlock(), createElementBlock("div", _hoisted_4$7, [
          unref(requestId) ? (openBlock(), createElementBlock("code", _hoisted_5$5, " Request ID: " + toDisplayString(unref(requestId)), 1)) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ]);
    };
  }
};
var RateLimited = /* @__PURE__ */ _export_sfc$1(_sfc_main$a, [["__scopeId", "data-v-3c7ee30b"]]);
function render$1(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "2",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"
    })
  ]);
}
function render2(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "2",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"
    })
  ]);
}
var Failed_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1$9 = { class: "failed" };
const _hoisted_2$8 = { class: "avatar-outer" };
const _hoisted_3$6 = /* @__PURE__ */ createTextVNode(" You must own an NFT from the ");
const _hoisted_4$6 = ["href"];
const _hoisted_5$4 = {
  key: 1,
  class: "link"
};
const _hoisted_6$1 = /* @__PURE__ */ createTextVNode(" collection to continue ");
const _hoisted_7$2 = { class: "actions" };
const _hoisted_8$1 = { class: "row" };
const _hoisted_9$1 = ["href"];
const _hoisted_10$1 = /* @__PURE__ */ createTextVNode(" Buy one ");
const _sfc_main$9 = {
  setup(__props) {
    const store2 = useStore();
    const metadata = inject("contractMetadata");
    const link = inject("contractLink");
    const restart = () => store2.dispatch("reset");
    const cancel = () => store2.commit("CLOSE_MODAL");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$9, [
        createBaseVNode("div", _hoisted_2$8, [
          createVNode(unref(AvatarFailed))
        ]),
        createVNode(ModalTitle, { title: "Verification failed" }, {
          default: withCtx(() => [
            _hoisted_3$6,
            unref(link) ? (openBlock(), createElementBlock("a", {
              key: 0,
              href: unref(link),
              class: "link",
              target: "_blank"
            }, toDisplayString(unref(metadata).name), 9, _hoisted_4$6)) : (openBlock(), createElementBlock("span", _hoisted_5$4, toDisplayString(unref(metadata).name), 1)),
            _hoisted_6$1
          ]),
          _: 1
        }),
        createVNode(unref(SocialLinks)),
        createBaseVNode("div", _hoisted_7$2, [
          createBaseVNode("button", {
            onClick: restart,
            type: "button",
            class: "btn primary"
          }, "Try another wallet"),
          createBaseVNode("div", _hoisted_8$1, [
            createBaseVNode("button", {
              onClick: cancel,
              type: "button",
              class: "btn"
            }, "Cancel"),
            createBaseVNode("a", {
              href: unref(link),
              target: "_blank",
              class: "btn"
            }, [
              createVNode(unref(render$1), { "aria-hidden": "true" }),
              _hoisted_10$1
            ], 8, _hoisted_9$1)
          ])
        ])
      ]);
    };
  }
};
var Failed = /* @__PURE__ */ _export_sfc$1(_sfc_main$9, [["__scopeId", "data-v-98959604"]]);
var Loading_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1$8 = { class: "loading" };
const _hoisted_2$7 = { key: 0 };
const _sfc_main$8 = {
  setup(__props) {
    let timeout;
    const showFetchWarning = ref(false);
    onMounted(() => {
      timeout = setTimeout(() => {
        showFetchWarning.value = true;
      }, 2e3);
    });
    onBeforeUnmount(() => {
      if (timeout)
        clearTimeout(timeout);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$8, [
        createVNode(unref(Loading$1), { class: "spinner" }),
        showFetchWarning.value ? (openBlock(), createElementBlock("p", _hoisted_2$7, " We're loading this collection for the first time so it could take a minute... ")) : createCommentVNode("", true)
      ]);
    };
  }
};
var Loading = /* @__PURE__ */ _export_sfc$1(_sfc_main$8, [["__scopeId", "data-v-38692a0e"]]);
var Signing_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1$7 = { class: "signing" };
const _hoisted_2$6 = /* @__PURE__ */ createTextVNode(" Please sign the message to prove ownership of your wallet address ");
const _sfc_main$7 = {
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$7, [
        createVNode(unref(Loading$1), { class: "spinner" }),
        createVNode(ModalTitle, { title: "Waiting for signature" }, {
          default: withCtx(() => [
            _hoisted_2$6
          ]),
          _: 1
        })
      ]);
    };
  }
};
var Signing = /* @__PURE__ */ _export_sfc$1(_sfc_main$7, [["__scopeId", "data-v-091ca39f"]]);
var LinkWalletButton_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1$6 = { class: "icon" };
const _hoisted_2$5 = { class: "content" };
const _hoisted_3$5 = { class: "title" };
const _hoisted_4$5 = { class: "arrow" };
const _sfc_main$6 = {
  props: { provider: Object },
  setup(__props) {
    const store2 = useStore();
    const connect = (provider) => {
      if (provider.available) {
        return store2.dispatch("connectWallet", provider.name);
      }
      alert(`Unable to connect to ${provider.name} (wasn't able to detect). Please check that it's installed and try again.`);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("button", {
        type: "button",
        class: "link-wallet-btn",
        onClick: _cache[0] || (_cache[0] = ($event) => connect(__props.provider))
      }, [
        createBaseVNode("div", _hoisted_1$6, [
          (openBlock(), createBlock(resolveDynamicComponent(__props.provider.metadata.icon), { "aria-hidden": "true" }))
        ]),
        createBaseVNode("div", _hoisted_2$5, [
          createBaseVNode("div", _hoisted_3$5, toDisplayString(__props.provider.name), 1),
          createBaseVNode("p", null, toDisplayString(__props.provider.metadata.desc), 1)
        ]),
        createBaseVNode("div", _hoisted_4$5, [
          createVNode(unref(render$f), { "aria-hidden": "true" })
        ])
      ]);
    };
  }
};
var LinkWalletButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$6, [["__scopeId", "data-v-e3deb5ea"]]);
var LinkWalletButtons_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1$5 = { role: "list" };
const _sfc_main$5 = {
  setup(__props) {
    const store2 = useStore();
    const providers = computed(() => Wallet$1.providersForChain(store2.getters.request.chain));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("ul", _hoisted_1$5, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(providers), (provider) => {
          return openBlock(), createElementBlock("li", {
            key: provider.name
          }, [
            createVNode(LinkWalletButton, { provider }, null, 8, ["provider"])
          ]);
        }), 128))
      ]);
    };
  }
};
var LinkWalletButtons = /* @__PURE__ */ _export_sfc$1(_sfc_main$5, [["__scopeId", "data-v-51dbf680"]]);
var Start_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1$4 = { class: "start" };
const _hoisted_2$4 = /* @__PURE__ */ createTextVNode(" You must own an NFT from the ");
const _hoisted_3$4 = ["href"];
const _hoisted_4$4 = {
  key: 1,
  class: "link"
};
const _hoisted_5$3 = /* @__PURE__ */ createTextVNode(" collection to continue ");
const _sfc_main$4 = {
  setup(__props) {
    const metadata = inject("contractMetadata");
    const link = inject("contractLink");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(unref(StartHeader)),
        createBaseVNode("div", _hoisted_1$4, [
          createVNode(ModalTitle, { title: "Connect your wallet" }, {
            default: withCtx(() => [
              _hoisted_2$4,
              unref(link) ? (openBlock(), createElementBlock("a", {
                key: 0,
                href: unref(link),
                class: "link",
                target: "_blank"
              }, toDisplayString(unref(metadata).name), 9, _hoisted_3$4)) : (openBlock(), createElementBlock("span", _hoisted_4$4, toDisplayString(unref(metadata).name), 1)),
              _hoisted_5$3
            ]),
            _: 1
          }),
          createVNode(unref(SocialLinks)),
          createVNode(unref(LinkWalletButtons), { class: "btns" })
        ])
      ], 64);
    };
  }
};
var Start = /* @__PURE__ */ _export_sfc$1(_sfc_main$4, [["__scopeId", "data-v-b624bf34"]]);
var Success_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1$3 = { class: "success" };
const _hoisted_2$3 = { class: "avatar-outer" };
const _hoisted_3$3 = /* @__PURE__ */ createTextVNode(" Owner of ");
const _hoisted_4$3 = ["href"];
const _hoisted_5$2 = { class: "actions" };
const _hoisted_6 = /* @__PURE__ */ createStaticVNode('<div class="dl-label" data-v-84a90e9a><div class="inner" data-v-84a90e9a><div class="line" aria-hidden="true" data-v-84a90e9a><div class="inner" data-v-84a90e9a></div></div><div class="text" data-v-84a90e9a><span class="inner" data-v-84a90e9a> Unlocked </span></div></div></div>', 1);
const _hoisted_7$1 = {
  role: "list",
  class: "dl-list"
};
const _hoisted_8 = ["href"];
const _hoisted_9 = { class: "inner" };
const _hoisted_10 = { class: "text" };
const _sfc_main$3 = {
  setup(__props) {
    const store2 = useStore();
    const app = computed(() => store2.getters.app);
    const tokens = computed(() => store2.getters.response.tokens);
    const unlockables = computed(() => {
      var _a;
      return (_a = store2.getters.response.unlockables) == null ? void 0 : _a.filter(({ type, sdkDownloadBtn }) => sdkDownloadBtn && ["image", "video", "file"].includes(type));
    });
    const exit = () => store2.commit("CLOSE_MODAL");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$3, [
        createBaseVNode("div", _hoisted_2$3, [
          createVNode(unref(AvatarSuccess))
        ]),
        createVNode(ModalTitle, { title: "Verification complete" }, {
          default: withCtx(() => [
            _hoisted_3$3,
            createBaseVNode("a", {
              href: unref(tokens)[0].explorer,
              class: "link",
              target: "_blank"
            }, toDisplayString(unref(tokens)[0].metadata.name), 9, _hoisted_4$3),
            unref(tokens).length > 1 ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createTextVNode(" and " + toDisplayString(unref(tokens).length - 1) + " others ", 1)
            ], 64)) : createCommentVNode("", true)
          ]),
          _: 1
        }),
        createBaseVNode("div", _hoisted_5$2, [
          createBaseVNode("button", {
            type: "button",
            class: "btn",
            onClick: exit
          }, "Continue to " + toDisplayString(unref(app).name), 1)
        ]),
        unref(unlockables).length ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          _hoisted_6,
          createBaseVNode("ul", _hoisted_7$1, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(unlockables), (item) => {
              return openBlock(), createElementBlock("a", {
                key: item.id,
                href: item.content,
                target: "_blank",
                class: "item"
              }, [
                createBaseVNode("li", null, [
                  createBaseVNode("div", _hoisted_9, [
                    createBaseVNode("div", _hoisted_10, [
                      createBaseVNode("h3", null, toDisplayString(item.name), 1)
                    ]),
                    createVNode(unref(_sfc_main$m), {
                      type: item.type,
                      class: "icon"
                    }, null, 8, ["type"])
                  ])
                ])
              ], 8, _hoisted_8);
            }), 128))
          ])
        ], 64)) : createCommentVNode("", true)
      ]);
    };
  }
};
var Success = /* @__PURE__ */ _export_sfc$1(_sfc_main$3, [["__scopeId", "data-v-84a90e9a"]]);
var Verifying_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1$2 = { class: "verifying" };
const _hoisted_2$2 = { class: "avatar-outer" };
const _hoisted_3$2 = { class: "icon" };
const _hoisted_4$2 = /* @__PURE__ */ createTextVNode(" Please wait a moment while we verify your ownership on the blockchain ");
const _sfc_main$2 = {
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$2, [
        createBaseVNode("div", _hoisted_2$2, [
          createVNode(unref(AvatarMini)),
          createVNode(unref(LoadingDots), { class: "spinner" }),
          createBaseVNode("span", _hoisted_3$2, [
            createVNode(unref(render2), { "aria-hidden": "true" })
          ])
        ]),
        createVNode(ModalTitle, { title: "Hang in there!" }, {
          default: withCtx(() => [
            _hoisted_4$2
          ]),
          _: 1
        })
      ]);
    };
  }
};
var Verifying = /* @__PURE__ */ _export_sfc$1(_sfc_main$2, [["__scopeId", "data-v-41e07a4d"]]);
var _imports_0 = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMjg2cHgiIGhlaWdodD0iNzJweCIgdmlld0JveD0iMCAwIDI4NiA3MiIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj4KICAgIDx0aXRsZT52ZXJpZnk8L3RpdGxlPgogICAgPGcgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9IkFydGJvYXJkLUNvcHkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDMuMDAwMDAwLCAtMzQ0LjAwMDAwMCkiPgogICAgICAgICAgICA8ZyBpZD0idmVyaWZ5IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMi41NjI0NDYsIDM0NC4xNDQ2NjEpIj4KICAgICAgICAgICAgICAgIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEwOC4yMDI0NDYsIDQuNjc5MzM5KSIgZmlsbD0iIzBGMTcyQSIgZmlsbC1ydWxlPSJub256ZXJvIj4KICAgICAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aCIgcG9pbnRzPSIxOC41NiA0MS45MiAyNy41MiAxNC43MiAzNy4wNTYgMTQuNzIgMjMuOTM2IDUwLjE3NiAxMy4wNTYgNTAuMTc2IDAgMTQuNzIgOS42IDE0LjcyIj48L3BvbHlnb24+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTczLjk2ODU1MTcsMzEuNjggQzczLjk2ODU1MTcsMzIuOTYgNzMuODgzMjE4NCwzNC4xMTIgNzMuNzEyNTUxNywzNS4xMzYgTDQ3Ljc5MjU1MTcsMzUuMTM2IEM0OC4wMDU4ODUxLDM3LjY5NiA0OC45MDE4ODUxLDM5LjcwMTMzMzMgNTAuNDgwNTUxNyw0MS4xNTIgQzUyLjA1OTIxODQsNDIuNjAyNjY2NyA1NC4wMDA1NTE3LDQzLjMyOCA1Ni4zMDQ1NTE3LDQzLjMyOCBDNTkuNjMyNTUxNyw0My4zMjggNjIuMDAwNTUxNyw0MS44OTg2NjY3IDYzLjQwODU1MTcsMzkuMDQgTDczLjA3MjU1MTcsMzkuMDQgQzcyLjA0ODU1MTcsNDIuNDUzMzMzMyA3MC4wODU4ODUxLDQ1LjI1ODY2NjcgNjcuMTg0NTUxNyw0Ny40NTYgQzY0LjI4MzIxODQsNDkuNjUzMzMzMyA2MC43MjA1NTE3LDUwLjc1MiA1Ni40OTY1NTE3LDUwLjc1MiBDNTMuMDgzMjE4NCw1MC43NTIgNTAuMDIxODg1MSw0OS45OTQ2NjY3IDQ3LjMxMjU1MTcsNDguNDggQzQ0LjYwMzIxODQsNDYuOTY1MzMzMyA0Mi40OTEyMTg0LDQ0LjgyMTMzMzMgNDAuOTc2NTUxNyw0Mi4wNDggQzM5LjQ2MTg4NTEsMzkuMjc0NjY2NyAzOC43MDQ1NTE3LDM2LjA3NDY2NjcgMzguNzA0NTUxNywzMi40NDggQzM4LjcwNDU1MTcsMjguNzc4NjY2NyAzOS40NTEyMTg0LDI1LjU1NzMzMzMgNDAuOTQ0NTUxNywyMi43ODQgQzQyLjQzNzg4NTEsMjAuMDEwNjY2NyA0NC41Mjg1NTE3LDE3Ljg3NzMzMzMgNDcuMjE2NTUxNywxNi4zODQgQzQ5LjkwNDU1MTcsMTQuODkwNjY2NyA1Mi45OTc4ODUxLDE0LjE0NCA1Ni40OTY1NTE3LDE0LjE0NCBDNTkuODY3MjE4NCwxNC4xNDQgNjIuODg1ODg1MSwxNC44NjkzMzMzIDY1LjU1MjU1MTcsMTYuMzIgQzY4LjIxOTIxODQsMTcuNzcwNjY2NyA3MC4yODg1NTE3LDE5LjgyOTMzMzMgNzEuNzYwNTUxNywyMi40OTYgQzczLjIzMjU1MTcsMjUuMTYyNjY2NyA3My45Njg1NTE3LDI4LjIyNCA3My45Njg1NTE3LDMxLjY4IFogTTY0LjY4ODU1MTcsMjkuMTIgQzY0LjY0NTg4NTEsMjYuODE2IDYzLjgxMzg4NTEsMjQuOTcwNjY2NyA2Mi4xOTI1NTE3LDIzLjU4NCBDNjAuNTcxMjE4NCwyMi4xOTczMzMzIDU4LjU4NzIxODQsMjEuNTA0IDU2LjI0MDU1MTcsMjEuNTA0IEM1NC4wMjE4ODUxLDIxLjUwNCA1Mi4xNTUyMTg0LDIyLjE3NiA1MC42NDA1NTE3LDIzLjUyIEM0OS4xMjU4ODUxLDI0Ljg2NCA0OC4xOTc4ODUxLDI2LjczMDY2NjcgNDcuODU2NTUxNywyOS4xMiBMNjQuNjg4NTUxNywyOS4xMiBaIiBpZD0iU2hhcGUiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNODguMzUzMTAzNCwyMC4yMjQgQzg5LjUwNTEwMzQsMTguMzQ2NjY2NyA5MS4wMDkxMDM0LDE2Ljg3NDY2NjcgOTIuODY1MTAzNCwxNS44MDggQzk0LjcyMTEwMzQsMTQuNzQxMzMzMyA5Ni44NDM3NzAxLDE0LjIwOCA5OS4yMzMxMDM0LDE0LjIwOCBMOTkuMjMzMTAzNCwyMy42MTYgTDk2Ljg2NTEwMzQsMjMuNjE2IEM5NC4wNDkxMDM0LDIzLjYxNiA5MS45MjY0MzY4LDI0LjI3NzMzMzMgOTAuNDk3MTAzNCwyNS42IEM4OS4wNjc3NzAxLDI2LjkyMjY2NjcgODguMzUzMTAzNCwyOS4yMjY2NjY3IDg4LjM1MzEwMzQsMzIuNTEyIEw4OC4zNTMxMDM0LDUwLjE3NiBMNzkuMzkzMTAzNCw1MC4xNzYgTDc5LjM5MzEwMzQsMTQuNzIgTDg4LjM1MzEwMzQsMTQuNzIgTDg4LjM1MzEwMzQsMjAuMjI0IFoiIGlkPSJQYXRoIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEwOC42ODk2NTUsMTAuNDk2IEMxMDcuMTEwOTg5LDEwLjQ5NiAxMDUuNzk4OTg5LDkuOTk0NjY2NjcgMTA0Ljc1MzY1NSw4Ljk5MiBDMTAzLjcwODMyMiw3Ljk4OTMzMzMzIDEwMy4xODU2NTUsNi43NDEzMzMzMyAxMDMuMTg1NjU1LDUuMjQ4IEMxMDMuMTg1NjU1LDMuNzU0NjY2NjcgMTAzLjcwODMyMiwyLjUwNjY2NjY3IDEwNC43NTM2NTUsMS41MDQgQzEwNS43OTg5ODksMC41MDEzMzMzMzMgMTA3LjExMDk4OSwwIDEwOC42ODk2NTUsMCBDMTEwLjI2ODMyMiwwIDExMS41ODAzMjIsMC41MDEzMzMzMzMgMTEyLjYyNTY1NSwxLjUwNCBDMTEzLjY3MDk4OSwyLjUwNjY2NjY3IDExNC4xOTM2NTUsMy43NTQ2NjY2NyAxMTQuMTkzNjU1LDUuMjQ4IEMxMTQuMTkzNjU1LDYuNzQxMzMzMzMgMTEzLjY3MDk4OSw3Ljk4OTMzMzMzIDExMi42MjU2NTUsOC45OTIgQzExMS41ODAzMjIsOS45OTQ2NjY2NyAxMTAuMjY4MzIyLDEwLjQ5NiAxMDguNjg5NjU1LDEwLjQ5NiBaIE0xMTMuMTA1NjU1LDE0LjcyIEwxMTMuMTA1NjU1LDUwLjE3NiBMMTA0LjE0NTY1NSw1MC4xNzYgTDEwNC4xNDU2NTUsMTQuNzIgTDExMy4xMDU2NTUsMTQuNzIgWiIgaWQ9IlNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEzNy4wOTAyMDcsMjIuMDggTDEzMC44ODIyMDcsMjIuMDggTDEzMC44ODIyMDcsNTAuMTc2IEwxMjEuNzk0MjA3LDUwLjE3NiBMMTIxLjc5NDIwNywyMi4wOCBMMTE3Ljc2MjIwNywyMi4wOCBMMTE3Ljc2MjIwNywxNC43MiBMMTIxLjc5NDIwNywxNC43MiBMMTIxLjc5NDIwNywxMi45MjggQzEyMS43OTQyMDcsOC41NzYgMTIzLjAzMTU0LDUuMzc2IDEyNS41MDYyMDcsMy4zMjggQzEyNy45ODA4NzQsMS4yOCAxMzEuNzE0MjA3LDAuMzIgMTM2LjcwNjIwNywwLjQ0OCBMMTM2LjcwNjIwNyw4IEMxMzQuNTMwMjA3LDcuOTU3MzMzMzMgMTMzLjAxNTU0LDguMzIgMTMyLjE2MjIwNyw5LjA4OCBDMTMxLjMwODg3NCw5Ljg1NiAxMzAuODgyMjA3LDExLjI0MjY2NjcgMTMwLjg4MjIwNywxMy4yNDggTDEzMC44ODIyMDcsMTQuNzIgTDEzNy4wOTAyMDcsMTQuNzIgTDEzNy4wOTAyMDcsMjIuMDggWiIgaWQ9IlBhdGgiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aCIgcG9pbnRzPSIxNzYuODM0MjA3IDE0LjcyIDE1NC44ODIyMDcgNjYuOTQ0IDE0NS4zNDYyMDcgNjYuOTQ0IDE1My4wMjYyMDcgNDkuMjggMTM4LjgxODIwNyAxNC43MiAxNDguODY2MjA3IDE0LjcyIDE1OC4wMTgyMDcgMzkuNDg4IDE2Ny4yOTgyMDcgMTQuNzIiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxnIGlkPSJHcm91cCI+CiAgICAgICAgICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZSIgZmlsbD0iI0ZEQkE3NCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzUuMzU1MzM5LCAzNS4zNTUzMzkpIHJvdGF0ZSg0NS4wMDAwMDApIHRyYW5zbGF0ZSgtMzUuMzU1MzM5LCAtMzUuMzU1MzM5KSAiIHg9IjEwLjM1NTMzOTEiIHk9IjEwLjM1NTMzOTEiIHdpZHRoPSI1MCIgaGVpZ2h0PSI1MCIgcng9IjciPjwvcmVjdD4KICAgICAgICAgICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLUNvcHkiIGZpbGw9IiNGOTczMTYiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUxLjM1NTMzOSwgMzUuMzU1MzM5KSByb3RhdGUoNDUuMDAwMDAwKSB0cmFuc2xhdGUoLTUxLjM1NTMzOSwgLTM1LjM1NTMzOSkgIiB4PSIyNi4zNTUzMzkxIiB5PSIxMC4zNTUzMzkxIiB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIHJ4PSI3Ij48L3JlY3Q+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg==";
var Footer_vue_vue_type_style_index_0_scoped_true_lang = "";
const _withScopeId$1 = (n2) => (pushScopeId("data-v-15bda34c"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$1 = {
  key: 0,
  class: "footer"
};
const _hoisted_2$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", null, [
  /* @__PURE__ */ createBaseVNode("a", {
    href: "mailto:frontdesk@diamondhandshotel.com",
    class: "link"
  }, "Legal"),
  /* @__PURE__ */ createTextVNode(" \u2022 "),
  /* @__PURE__ */ createBaseVNode("a", {
    href: "mailto:frontdesk@diamondhandshotel.com",
    class: "link"
  }, "Report issue")
], -1));
const _hoisted_3$1 = [
  _hoisted_2$1
];
const _hoisted_4$1 = {
  key: 1,
  class: "footer branded"
};
const _hoisted_5$1 = /* @__PURE__ */ createStaticVNode('<span class="logo" data-v-15bda34c><span data-v-15bda34c>Secured by</span><a href="https://diamondhandshotel.com/verify" target="_blank" data-v-15bda34c><img src="' + _imports_0 + '" data-v-15bda34c></a></span><span data-v-15bda34c><a href="mailto:frontdesk@diamondhandshotel.com" class="link" data-v-15bda34c>Legal</a> \u2022 <a href="mailto:frontdesk@diamondhandshotel.com" class="link" data-v-15bda34c>Report issue</a></span>', 2);
const _hoisted_7 = [
  _hoisted_5$1
];
const _sfc_main$1 = {
  setup(__props) {
    const store2 = useStore();
    const whitelabel = computed(() => !store2.getters.app || !store2.getters.app.attributionRequired);
    return (_ctx, _cache) => {
      return unref(whitelabel) ? (openBlock(), createElementBlock("div", _hoisted_1$1, _hoisted_3$1)) : (openBlock(), createElementBlock("div", _hoisted_4$1, _hoisted_7));
    };
  }
};
var Footer = /* @__PURE__ */ _export_sfc$1(_sfc_main$1, [["__scopeId", "data-v-15bda34c"]]);
var Modal_vue_vue_type_style_index_0_scoped_true_lang = "";
const _withScopeId = (n2) => (pushScopeId("data-v-fb40a706"), n2 = n2(), popScopeId(), n2);
const _hoisted_1 = { class: "dialog-root" };
const _hoisted_2 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", {
  class: "center-hack",
  "aria-hidden": "true"
}, "\u200B", -1));
const _hoisted_3 = { class: "modal-outer" };
const _hoisted_4 = { class: "close" };
const _hoisted_5 = { class: "modal-inner" };
const _sfc_main = {
  setup(__props) {
    const store2 = useStore();
    const showFooter = computed(() => store2.getters.view !== "LOADING");
    const view = computed(() => {
      switch (store2.getters.view) {
        case "LOADING":
          return Loading;
        case "START":
          return Start;
        case "CONNECTING":
          return Connecting;
        case "SIGNING":
          return Signing;
        case "VERIFYING":
          return Verifying;
        case "SUCCESS":
          return Success;
        case "FAILED":
          return Failed;
        case "ERROR":
          return ErrorView;
        case "RATE_LIMITED":
          return RateLimited;
      }
    });
    const contractMetadata2 = computed(() => store2.getters.contractMetadata);
    const contractLink = computed(() => store2.getters.contractLink);
    const open2 = computed({
      get: () => store2.getters.open,
      set: (val) => store2.commit("CLOSE_MODAL")
    });
    const getActiveElem = () => document.activeElement;
    provide("contractMetadata", contractMetadata2);
    provide("contractLink", contractLink);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Yn), {
        as: "template",
        show: unref(open2),
        "initial-focus": getActiveElem()
      }, {
        default: withCtx(() => [
          createVNode(unref(Gr), {
            as: "div",
            class: "dhh-verify-root"
          }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_1, [
                createVNode(unref(Qn), {
                  as: "template",
                  enter: "overlay-enter",
                  "enter-from": "overlay-enter-from",
                  "enter-to": "overlay-enter-to",
                  leave: "overlay-leave",
                  "leave-from": "overlay-leave-from",
                  "leave-to": "overlay-leave-to"
                }, {
                  default: withCtx(() => [
                    createVNode(unref(_r), { class: "overlay" })
                  ]),
                  _: 1
                }),
                _hoisted_2,
                createVNode(unref(Qn), {
                  as: "template",
                  enter: "modal-enter",
                  "enter-from": "modal-enter-from",
                  "enter-to": "modal-enter-to",
                  leave: "modal-leave",
                  "leave-from": "modal-leave-from",
                  "leave-to": "modal-leave-to"
                }, {
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_3, [
                      createBaseVNode("div", _hoisted_4, [
                        createBaseVNode("button", {
                          onClick: _cache[0] || (_cache[0] = ($event) => open2.value = false),
                          type: "button"
                        }, [
                          createVNode(unref(render$3), { "aria-hidden": "true" })
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_5, [
                        (openBlock(), createBlock(resolveDynamicComponent(unref(view)))),
                        unref(showFooter) ? (openBlock(), createBlock(Footer, { key: 0 })) : createCommentVNode("", true)
                      ])
                    ])
                  ]),
                  _: 1
                })
              ])
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["show", "initial-focus"]);
    };
  }
};
var Modal = /* @__PURE__ */ _export_sfc$1(_sfc_main, [["__scopeId", "data-v-fb40a706"]]);
var style = "";
var tailwind = "";
var initializeUI = (el, { apiKey, providers }) => {
  const app = createApp(Modal);
  app.use(store);
  app.directive("tooltip", VTooltip);
  app.mount(el);
  return { app, store };
};
class VerifySdk$1 extends EventEmitter$1 {
  constructor(apiKey, { providers, endpoint }) {
    super();
    if (apiKey.slice(0, 3) === "sk_") {
      throw new DumbassError();
    }
    setupClient(endpoint);
    this.el = null;
    this.app = null;
    this._storeUnsub = null;
    this._initialize(apiKey, providers);
  }
  set apiKey(apiKey) {
    this.store.commit("SET_API_KEY", apiKey);
    return apiKey;
  }
  get wallet() {
    if (Wallet$1.active) {
      return Wallet$1.active;
    }
    throw new WalletConnectionError("Wallet not yet connected");
  }
  _initialize(apiKey, providers) {
    if (this.app) {
      this.app.unmount();
      this.el.remove();
      this._mutation();
      this._action();
    }
    Wallet$1.registerProviders(providers);
    this.el = document.createElement("div");
    this.el.setAttribute("style", "display: hidden;");
    this.supportedChains = providers.map((provider) => provider.supportedChains).flat().filter(function(item, pos, self2) {
      return self2.indexOf(item) === pos;
    });
    const { app, store: store2 } = initializeUI(this.el, { providers, apiKey });
    this.app = app;
    this.store = store2;
    this.store.dispatch("initialize", { apiKey, providers });
    this._mutation = store2.subscribe(this.onMutation.bind(this));
    this._action = store2.subscribeAction(this.onAction.bind(this));
  }
  onMutation(mutation, state2) {
    switch (mutation.type) {
      case "SHOW_MODAL":
        this.emit("opened");
        break;
      case "CLOSE_MODAL":
        this.emit("closed");
        break;
      case "METADATA_LOADED":
        this.emit("contract_metadata", mutation.payload);
        break;
      case "WALLET_CONNECTED":
        this.emit("wallet_connected", this.wallet);
        break;
      case "NONCE_VERIFIED":
        this.emit("wallet_verified", mutation.payload);
        break;
      case "SET_RESPONSE":
        if (mutation.payload) {
          this.emit("results", mutation.payload);
        }
        break;
    }
  }
  onAction(action, state2) {
    switch (action.type) {
      case "handleError":
        this.emit("error", action.payload);
        break;
    }
  }
  nft(config2) {
    return new Promise(async (r2, j2) => {
      this.store.commit("SET_VIEW", "LOADING");
      this.store.commit("SHOW_MODAL");
      await this.store.dispatch("startRequest", config2);
      if (!this.supportedChains.includes(config2.chain)) {
        const err = new UnsupportedChainError(`This bundle doesn't include dependancies for ${config2.chain}, install the combined or correct chain bundle`);
        this.store.dispatch("handleError", err);
        return j2(err);
      }
      const unsubscribe2 = this.store.subscribe((mutation, state2) => {
        if (mutation.type === "NONCE_VERIFIED") {
          this.store.dispatch("verifyNft", mutation.payload);
        }
        if (mutation.type === "CLOSE_MODAL") {
          unsubscribe2();
          if (!state2.response) {
            return j2(new VerificationAbortedError("User aborted the verification"));
          }
          return r2(state2.response);
        }
      });
    });
  }
}
class VerifySdk extends VerifySdk$1 {
  constructor(apiKey, opts = {}) {
    super(apiKey, __spreadValues({
      providers: EthereumProviders
    }, opts));
  }
}
export { VerifySdk as default };
